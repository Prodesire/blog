<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python 命令行大乱斗</title>
    <url>/2020/07/02/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E4%B9%B1%E6%96%97/</url>
    <content><![CDATA[<p>本文首发于 <a href="https://mp.weixin.qq.com/s/szn0qm8_u6GTbVoW9GBP3Q" target="_blank" rel="noopener">凌云时刻公众号</a>。</p>
<p>当你想实现一个命令行程序时，或许第一个想到的是用 Python 来实现。比如 CentOS 上大名鼎鼎的包管理工具 <code>yum</code> 就是基于 Python 实现的。</p>
<p>而 Python 的世界中有很多命令行库，每个库都各具特色。但我们往往不知道其背后的设计理念，也因此在选择时感到迷茫。这些库的作者为何在重复造轮子，他是从哪个角度来考虑，来让命令行库“演变”到一个新的更好用的形态。</p>
<p>为了能够更加直观地感受到命令行库的设计理念，在此之前，我们不妨设计一个名为 <code>calc</code> 的命令行程序，它能：</p>
<ul>
<li>支持 <code>echo</code> 子命令，对输入的字符串做处理来输出<ul>
<li>若不提供任何选项，则输出原始内容</li>
<li>若提供 <code>--lower</code> 选项，则输出小写字符串</li>
<li>若提供 <code>--upper</code> 选项，则输出大写字符串</li>
</ul>
</li>
<li>支持 <code>eval</code> 子命令，针对输入调用 Python 的 <code>eval</code> 函数，将结果输出（作为示例，我们不考虑安全性问题）</li>
</ul>
<a id="more"></a>
<h2 id="argparse"><a href="#argparse" class="headerlink" title="argparse"></a>argparse</h2><p><a href="https://docs.python.org/3/library/argparse.html" target="_blank" rel="noopener">argparse</a> 作为 Python 的标准库，可能会是你想到第一个命令行库。</p>
<p><code>argparse</code> 的设计理念就是提供给开发者最细粒度的控制。换句话说，你需要告诉它必不可少的细节，比如参数的类型是什么，处理参数的动作是怎样的。</p>
<p>在 <code>argparse</code> 的世界中，需要：</p>
<ul>
<li>设置解析器，作为后续定义参数和解析命令行的基础。如果要实现子命令，则还要设置子解析器。</li>
<li>定义参数，包括名称、类型、动作、帮助等。其中的动作是指对于此参数的初步处理，是直接存下来，还是作为布尔值，亦或是追加到列表中等等</li>
<li>解析参数</li>
<li>根据参数编写业务逻辑</li>
</ul>
<p>以下示例是基于 <code>argparse</code> 的 <code>calc</code> 程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_text</span><span class="params">(args)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args.lower:</span><br><span class="line">        print(args.text.lower())</span><br><span class="line">    <span class="keyword">elif</span> args.upper:</span><br><span class="line">        print(args.text.upper())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(args.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval_expression</span><span class="params">(args)</span>:</span></span><br><span class="line">    print(eval(args.expression))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 设置解析器</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Calculator Program.'</span>)</span><br><span class="line">subparsers = parser.add_subparsers()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 定义参数</span></span><br><span class="line"><span class="comment"># 2.1 echo 子命令</span></span><br><span class="line"><span class="comment"># echo 子解析器</span></span><br><span class="line">echo_parser = subparsers.add_parser(</span><br><span class="line">    <span class="string">'echo'</span>, help=<span class="string">'Echo input text in multiple forms'</span>)</span><br><span class="line"><span class="comment"># 添加位置参数 text</span></span><br><span class="line">echo_parser.add_argument(<span class="string">'text'</span>, help=<span class="string">'Input text'</span>)</span><br><span class="line"><span class="comment"># --lower/--upper 互斥，需要设置互斥组</span></span><br><span class="line">echo_group = echo_parser.add_mutually_exclusive_group()</span><br><span class="line"><span class="comment"># 添加选项参数 --lower/--upper，这里action的作用就是将之变为布尔变量</span></span><br><span class="line">echo_parser.add_argument(<span class="string">'--lower'</span>, action=<span class="string">'store_true'</span>, help=<span class="string">'Lower input text'</span>)</span><br><span class="line">echo_parser.add_argument(<span class="string">'--upper'</span>, action=<span class="string">'store_true'</span>, help=<span class="string">'Upper input text'</span>)</span><br><span class="line"><span class="comment"># 设置此命令的处理函数</span></span><br><span class="line">echo_parser.set_defaults(handle=echo_text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># eval 子解析器</span></span><br><span class="line">eval_parser = subparsers.add_parser(</span><br><span class="line">    <span class="string">'eval'</span>, help=<span class="string">'Eval input expression and return result'</span>)</span><br><span class="line"><span class="comment"># 添加位置参数 expression</span></span><br><span class="line">eval_parser.add_argument(<span class="string">'expression'</span>, help=<span class="string">'Expression to eval'</span>)</span><br><span class="line"><span class="comment"># 设置此命令的处理函数</span></span><br><span class="line">eval_parser.set_defaults(handle=eval_expression)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 解析参数</span></span><br><span class="line">args = parser.parse_args([<span class="string">'echo'</span>, <span class="string">'--upper'</span>, <span class="string">'Hello, World'</span>])</span><br><span class="line">print(args)  <span class="comment"># 结果：Namespace(lower=True, text='Hello, World', upper=False)</span></span><br><span class="line"><span class="comment"># args = parser.parse_args(['eval', '1+2*3'])</span></span><br><span class="line"><span class="comment"># print(args)  # 结果：Namespace(expression='1+2*3')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 业务逻辑处理</span></span><br><span class="line">args.handle(args)</span><br></pre></td></tr></table></figure>
<p>从上述示例可以看到，要实现子命令，对应地需要添加子解析器。然后最为关键的就是要定义参数，需要通过 <code>add_argument</code> 很明确地告诉 <code>argparse</code> 参数长什么样，需要怎么处理：</p>
<ul>
<li>它是位置参数 <code>text</code>/<code>expression</code>，还是选项参数 <code>--lower</code>/<code>--upper</code></li>
<li>若是选项参数，是否互斥</li>
<li>参数的是存成什么形式，比如 <code>action=&#39;store_true&#39;</code> 表示存成布尔</li>
<li>子命令的响应函数</li>
</ul>
<p>通过 <code>argparse</code> 实现的整个过程是很计算机思维的，且比较冗长。其优点是灵活，所有的功能都涵盖到了；但缺点则是将定义和处理割裂，尤其在程序功能复杂时会愈加凌乱和不直观，难以理解和维护。</p>
<h2 id="docopt"><a href="#docopt" class="headerlink" title="docopt"></a>docopt</h2><p>有人喜欢 <code>argparse</code> 这样命令式的写法，就会有人喜欢声明式的写法。而 <a href="http://docopt.org/" target="_blank" rel="noopener">docopt</a> 恰巧这就是这样一个命令行库。设计它的初衷就是对于熟悉命令行程序帮助信息的开发者来说，直接通过编写帮助信息来描述整个命令行参数定义的元信息会是更加简单快捷的方式。这种声明式的语法描述某种程度上会比过程式地定义参数来的更加简单和直观。</p>
<p>在 <code>docopt</code> 的世界中，需要：</p>
<ul>
<li>定义接口描述/帮助信息，这一步是它的特色和重点</li>
<li>解析参数，获得一个字典</li>
<li>根据参数编写业务逻辑</li>
</ul>
<p>以下示例是基于 <code>docopt</code> 的 <code>calc</code> 程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 定义接口描述/帮助信息</span></span><br><span class="line"><span class="string">"""Calculator Program.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">  calc echo [--lower | --upper] &lt;text&gt;</span></span><br><span class="line"><span class="string">  calc eval &lt;expression&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Commands:</span></span><br><span class="line"><span class="string">  echo          Echo input text in multiple forms</span></span><br><span class="line"><span class="string">  eval          Eval input expression and return result</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">  -h --help     Show help</span></span><br><span class="line"><span class="string">  --lower       Lower input text</span></span><br><span class="line"><span class="string">  --upper       Upper input text</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> docopt <span class="keyword">import</span> docopt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_text</span><span class="params">(args)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'--lower'</span>]:</span><br><span class="line">        print(args[<span class="string">'&lt;text&gt;'</span>].lower())</span><br><span class="line">    <span class="keyword">elif</span> args[<span class="string">'--upper'</span>]:</span><br><span class="line">        print(args[<span class="string">'&lt;text&gt;'</span>].upper())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(args[<span class="string">'&lt;text&gt;'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval_expression</span><span class="params">(args)</span>:</span></span><br><span class="line">    print(eval(args[<span class="string">'&lt;expression&gt;'</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 解析命令行</span></span><br><span class="line">args = docopt(__doc__, argv=[<span class="string">'echo'</span>, <span class="string">'--upper'</span>, <span class="string">'Hello, World'</span>])</span><br><span class="line"><span class="comment"># 结果：&#123;'--lower': False, '--upper': True, '&lt;expression&gt;': None, '&lt;text&gt;': 'Hello, World', 'echo': True, 'eval': False&#125;</span></span><br><span class="line">print(args)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 业务逻辑</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="string">'echo'</span>]:</span><br><span class="line">    echo_text(args)</span><br><span class="line"><span class="keyword">elif</span> args[<span class="string">'eval'</span>]:</span><br><span class="line">    eval_expression(args)</span><br></pre></td></tr></table></figure>
<p>从上述示例可以看到，我们通过文档字符串 <code>__doc__</code> 定义了接口描述，这和 <code>argparse</code> 中 一系列参数定义的行为是等价的，然后 <code>docopt</code> 便会根据这个元信息把命令行参数转换为一个字典。业务逻辑中就需要对这个字典进行处理。</p>
<p>相比于 <code>argparse</code>：</p>
<ul>
<li>对于较为复杂的命令，命令和参数元信息的定义上 <code>docopt</code> 会更加简单</li>
<li>在业务逻辑的处理上，<code>argparse</code> 在一些简单参数的处理上会更加便捷，且命令和处理函数之间可以方便路由（比如示例中的情形）；相对来说 <code>docopt</code> 转换为字典后就把所有处理交给业务逻辑的方式会更加复杂</li>
</ul>
<h2 id="click"><a href="#click" class="headerlink" title="click"></a>click</h2><p>不论是 <code>argparse</code> 还是 <code>docopt</code>，元信息的定义和处理都是割裂开的。而命令行程序本质上是定义参数并对参数进行处理，而处理参数的逻辑一定是与所定义的参数有关联的。那可不可以用函数和装饰器来实现处理参数逻辑与定义参数的关联呢？<a href="https://click.palletsprojects.com/en/7.x/" target="_blank" rel="noopener">click</a> 正好就是以这种使用方式来设计的。</p>
<p>装饰器这样一个优雅的语法糖是元信息定义和处理逻辑之间的绝妙胶水，从而暗示了两者的路有关系。对比于前两个命令行库的路由实现着实优雅了不少。</p>
<p>在 <code>click</code> 的世界中：</p>
<ul>
<li>通过装饰器定义命令和参数的元信息</li>
<li>使用此装饰器装饰处理函数</li>
</ul>
<p>对，就是这么简单。</p>
<p>以下示例是基于 <code>click</code> 的 <code>calc</code> 程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> click</span><br><span class="line"></span><br><span class="line">sys.argv = [<span class="string">'calc'</span>, <span class="string">'echo'</span>, <span class="string">'--upper'</span>, <span class="string">'Hello, World'</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@click.group(help='Calculator Program.')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 定义参数</span></span><br><span class="line"><span class="meta">@cli.command(name='echo', help='Echo input text in multiple forms')</span></span><br><span class="line"><span class="meta">@click.argument('text')</span></span><br><span class="line"><span class="meta">@click.option('--lower', is_flag=True, help='Lower input text')</span></span><br><span class="line"><span class="meta">@click.option('--upper', is_flag=True, help='Upper input text')</span></span><br><span class="line"><span class="comment"># 1. 业务逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_text</span><span class="params">(text, lower, upper)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> lower:</span><br><span class="line">        print(text.lower())</span><br><span class="line">    <span class="keyword">elif</span> upper:</span><br><span class="line">        print(text.upper())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@cli.command(name='eval', help='Eval input expression and return result')</span></span><br><span class="line"><span class="meta">@click.argument('expression')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval_expression</span><span class="params">(expression)</span>:</span></span><br><span class="line">    print(eval(expression))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cli()</span><br></pre></td></tr></table></figure>
<p>从上述示例可以看到，元信息定义和处理逻辑无缝绑定在一起，能够直观地看出对应的参数会如何处理，这个优势在有大量参数需要处理时显得尤为突出。在处理函数中，接收到不再是像 <code>argparse</code> 或 <code>docopt</code> 中的一个包含所有参数的变量，而是具体的参数变量，这让处理逻辑在参数使用上也变得更加简便。</p>
<p>此外，<code>click</code> 还内置了很多实用工具和增强能力，如参数自动补全、分页支持、颜色、进度条等功能，能够有效提升开发效率。</p>
<h2 id="fire"><a href="#fire" class="headerlink" title="fire"></a>fire</h2><p>虽然前面三个库已经足够强大，但是仍然会有人认为不够简单。是否还有进一步简化的空间呢？如果只是定义函数，是否能让框架推测出参数元信息呢？理论上还真是可以。</p>
<p><a href="https://github.com/google/python-fire" target="_blank" rel="noopener">fire</a> 用一种面向广义对象的方式来玩转命令行，这种对象可以是类、函数、字典、列表等，它更加灵活，也更加简单。你都不需要定义参数类型，<code>fire</code> 会根据输入和参数默认值来自动判断，这无疑进一步简化了实现过程。</p>
<p>在 <code>fire</code> 的世界中，定义 Python 对象就够了。</p>
<p>以下示例是基于 <code>fire</code> 的 <code>calc</code> 程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"></span><br><span class="line">sys.argv = [<span class="string">'calc'</span>, <span class="string">'echo'</span>, <span class="string">'"Hello, World"'</span>, <span class="string">'--upper'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 业务逻辑</span></span><br><span class="line"><span class="comment"># 类中有几个方法，就意味着命令行程序有几个同名命令</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calc</span>:</span></span><br><span class="line">    <span class="comment"># text 没有任何默认值，视为位置参数</span></span><br><span class="line">    <span class="comment"># lower/upper 有布尔类型的默认值，视为选项参数 --lower/--upper，</span></span><br><span class="line">    <span class="comment"># 且指定了为 True，不指定 False</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(self, text, lower=False, upper=False)</span>:</span></span><br><span class="line">        <span class="string">"""Echo input text in multiple forms"""</span></span><br><span class="line">        <span class="keyword">if</span> lower:</span><br><span class="line">            print(text.lower())</span><br><span class="line">        <span class="keyword">elif</span> upper:</span><br><span class="line">            print(text.upper())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(text)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eval</span><span class="params">(self, expression)</span>:</span></span><br><span class="line">        <span class="string">"""Eval input expression and return result"""</span></span><br><span class="line">        print(eval(expression))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fire.Fire(Calc)</span><br></pre></td></tr></table></figure>
<p>从上面的示例可以看出，使用 <code>fire</code> 足够的简单，一切都是根据约定来进行推断，包括支持哪些命令，每个命令接受的什么参数和选项。这种方式可以说是足够的 Pythonic，相比于 <code>click</code>，<code>fire</code> 把命令行参数的定义和函数参数的定义融为了一体。通过它，我们真的就只用关注业务逻辑。</p>
<p>不过简单往往也意味着对于复杂需求的捉襟见肘。仅仅通过默认值来推导命令行参数所能表达的情况是有限的，比如互斥选项、位置参数的类型限定都无法通过框架来表达，而只能由业务逻辑去判断。</p>
<h2 id="typer"><a href="#typer" class="headerlink" title="typer"></a>typer</h2><p>那么该如何在保持像 <code>fire</code> 这样简单实现的方式下，增强参数元信息的表达能力呢？既然默认参数的能力有限，那么如果使用 Python 3 的类型注解呢？</p>
<p><a href="https://typer.tiangolo.com/" target="_blank" rel="noopener">typer</a> 站在 <code>click</code> 巨人的肩膀上，借助 Python 3 类型注解的特性，既满足了简单直观编写的需要，又达到了应对复杂场景的目的，可谓是现代化的命令行库。</p>
<p>在 <code>typer</code> 的世界中，也是直接编写业务逻辑，和 <code>fire</code> 稍稍不同的点是使用了类型注解和默认值来表达参数元信息定义。</p>
<p>以下示例是基于 <code>typer</code> 的 <code>calc</code> 程序：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> typer</span><br><span class="line"></span><br><span class="line">sys.argv = [<span class="string">'calc'</span>, <span class="string">'echo'</span>, <span class="string">'"Hello, World"'</span>, <span class="string">'--upper'</span>]</span><br><span class="line">cli = typer.Typer(help=<span class="string">'Calculator Program.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义命令 echo，及处理函数</span></span><br><span class="line"><span class="comment"># text 无默认值，视为位置参数，类型为字符串</span></span><br><span class="line"><span class="comment"># lower/upper 类型为 bool，默认值为 False，视为选项 --lower/--upper，</span></span><br><span class="line"><span class="comment"># 且指定了为 True，不指定 False</span></span><br><span class="line"><span class="meta">@cli.command(name='echo')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo_text</span><span class="params">(text: str, lower: bool = False, upper: bool = False)</span>:</span></span><br><span class="line">    <span class="string">"""Echo input text in multiple forms"""</span></span><br><span class="line">    <span class="keyword">if</span> lower:</span><br><span class="line">        print(text.lower())</span><br><span class="line">    <span class="keyword">elif</span> upper:</span><br><span class="line">        print(text.upper())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义命令 eval，及处理函数</span></span><br><span class="line"><span class="comment"># expression 无默认值，视为位置参数，类型为字符串</span></span><br><span class="line"><span class="meta">@cli.command(name='eval')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eval_expression</span><span class="params">(expression: str)</span>:</span></span><br><span class="line">    <span class="string">"""Eval input expression and return result"""</span></span><br><span class="line">    print(eval(expression))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cli()</span><br></pre></td></tr></table></figure>
<p>从上面的示例可以看出，相比于 <code>click</code>，它免去了参数元信息的繁琐定义，取而代之的是类型注解；相比于 <code>fire</code>，它的元信息定义能力则大大增强，可以通过指定默认值为 <code>typer.Option</code> 或 <code>typer.Argument</code> 来进一步扩展参数和选项的语义。可以说是，<code>typer</code> 达到了简单与灵活的完美平衡。</p>
<h2 id="横向对比"><a href="#横向对比" class="headerlink" title="横向对比"></a>横向对比</h2><p>最后，我们横向对比下 <code>argparse</code>、<code>docopt</code>、<code>click</code>、<code>fire</code>、<code>typer</code> 库的各项功能和特点：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:left">argpase</th>
<th style="text-align:left">docopt</th>
<th style="text-align:left">click</th>
<th style="text-align:left">fire</th>
<th style="text-align:left">typer</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用步骤数</td>
<td style="text-align:left">4 步</td>
<td style="text-align:left">3 步</td>
<td style="text-align:left">2 步</td>
<td style="text-align:left">1 步</td>
<td style="text-align:left">1 步</td>
</tr>
<tr>
<td>使用步骤数</td>
<td style="text-align:left">1. 设置解析器<br>2. 定义参数<br>3. 解析命令行<br>4. 业务逻辑</td>
<td style="text-align:left">1. 定义接口描述<br>2. 解析命令行<br>3. 业务逻辑</td>
<td style="text-align:left">1. 业务逻辑<br>2. 定义参数</td>
<td style="text-align:left">1. 业务逻辑</td>
<td style="text-align:left">1 . 业务逻辑</td>
</tr>
<tr>
<td>选项参数<br>（如 <code>--sum</code>）</td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
</tr>
<tr>
<td>位置参数<br>（如 <code>X Y</code>）</td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
</tr>
<tr>
<td>参数默认值<br></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="red">✘</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
</tr>
<tr>
<td>互斥选项<br>（如 <code>--car</code> 和 <code>--bus</code> 只能二选一）</td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="yellow">✔</font><br>可通过第三方库支持</td>
<td style="text-align:left"><font color="red">✘</font></td>
<td style="text-align:left"><font color="red">✘</font></td>
</tr>
<tr>
<td>可变参数<br>（如指定多个 <code>--file</code>）</td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
</tr>
<tr>
<td>嵌套/父子命令<br></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
</tr>
<tr>
<td>工具箱<br></td>
<td style="text-align:left"><font color="red">✘</font></td>
<td style="text-align:left"><font color="red">✘</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
</tr>
<tr>
<td>链式命令调用<br></td>
<td style="text-align:left"><font color="red">✘</font></td>
<td style="text-align:left"><font color="red">✘</font></td>
<td style="text-align:left"><font color="red">✘</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="red">✘</font></td>
</tr>
<tr>
<td>类型约束</td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="red">✘</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="red">✘</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
</tr>
</tbody>
</table>
<p>Python 的命令行库种类繁多、各具特色，它们并非是重复造轮子的产物，其背后的思想值得学习。结合横向对比的总结，可以选择出符合使用场景的库。如果几个库都符合，那么就选择你所偏爱的风格。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>argparse</tag>
        <tag>click</tag>
        <tag>docopt</tag>
        <tag>fire</tag>
        <tag>typer</tag>
      </tags>
  </entry>
  <entry>
    <title>限流后，你可以通过指数退避来重试</title>
    <url>/2020/03/04/%E9%99%90%E6%B5%81%E5%90%8E%EF%BC%8C%E4%BD%A0%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E6%8C%87%E6%95%B0%E8%A1%A5%E5%81%BF%E6%9D%A5%E9%87%8D%E8%AF%95/</url>
    <content><![CDATA[<h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>最近做云服务 API 测试项目的过程中，发现某些时候会大批量调用 API，从而导致限流的报错。在遇到这种报错时，传统的重试策略是每隔一段时间重试一次。但由于是固定的时间重试一次，重试时又会有大量的请求在同一时刻涌入，会不断地造成限流。</p>
<p>这让我回想起两年前在查阅<a href="http://docs.celeryproject.org/en/latest/userguide/tasks.html?highlight=exponential#Task.retry_backoff" title="Celery Task文档" target="_blank" rel="noopener">Celery Task 文档</a>的时候发现可以为任务设置 <code>retry_backoff</code> 的经历，它让任务在失败时以 <code>指数退避</code> 的方式进行重试。那么指数退避究竟是什么样的呢？</p>
<h2 id="二、指数退避"><a href="#二、指数退避" class="headerlink" title="二、指数退避"></a>二、指数退避</h2><p>根据 wiki 上对 <a href="https://en.wikipedia.org/wiki/Exponential_backoff" title="Exponential backoff" target="_blank" rel="noopener">Exponential backoff</a> 的说明，指数退避是一种通过反馈，成倍地降低某个过程的速率，以逐渐找到合适速率的算法。</p>
<p>在以太网中，该算法通常用于冲突后的调度重传。根据时隙和重传尝试次数来决定延迟重传。</p>
<p>在 <code>c</code> 次碰撞后（比如请求失败），会选择 0 和 $2^c-1$ 之间的随机值作为时隙的数量。</p>
<ul>
<li>对于第 1 次碰撞来说，每个发送者将会等待 0 或 1 个时隙进行发送。</li>
<li>而在第 2 次碰撞后，发送者将会等待 0 到 3（ 由 $2^2-1$ 计算得到）个时隙进行发送。</li>
<li>而在第 3 次碰撞后，发送者将会等待 0 到 7（ 由 $2^3-1$ 计算得到）个时隙进行发送。</li>
<li>以此类推……</li>
</ul>
<p>随着重传次数的增加，延迟的程度也会指数增长。</p>
<p>说的通俗点，每次重试的时间间隔都是上一次的两倍。</p>
<h2 id="三、指数退避的期望值"><a href="#三、指数退避的期望值" class="headerlink" title="三、指数退避的期望值"></a>三、指数退避的期望值</h2><p>考虑到退避时间的均匀分布，退避时间的数学期望是所有可能性的平均值。也就是说，在 <code>c</code> 次冲突之后，退避时隙数量在 <code>[0,1，...，N]</code> 中，其中 $N=2^c-1$ ，则退避时间的数学期望（以时隙为单位）是</p>
<p>$$E(c)=\frac{1}{N+1}\sum_{i=0}^{N}{i}=\frac{1}{N+1}\frac{N(N+1)}{2}=\frac{N}{2}=\frac{2^c-1}{2}$$</p>
<p>那么对于前面讲到的例子来说：</p>
<ul>
<li>第 1 次碰撞后，退避时间期望为 $E(1)=\frac{2^1-1}{2}=0.5$</li>
<li>第 2 次碰撞后，退避时间期望为 $E(2)=\frac{2^2-1}{2}=1.5$</li>
<li>第 3 次碰撞后，退避时间期望为 $E(3)=\frac{2^3-1}{2}=3.5$</li>
</ul>
<h2 id="四、指数退避的应用"><a href="#四、指数退避的应用" class="headerlink" title="四、指数退避的应用"></a>四、指数退避的应用</h2><h3 id="4-1-Celery-中的指数退避算法"><a href="#4-1-Celery-中的指数退避算法" class="headerlink" title="4.1 Celery 中的指数退避算法"></a>4.1 Celery 中的指数退避算法</h3><p>来看下 <a href="https://github.com/celery/celery/blob/v4.3.0/celery/utils/time.py#L392" title="celery/utils/time.py" target="_blank" rel="noopener">celery/utils/time.py</a> 中获取指数退避时间的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_exponential_backoff_interval</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    factor,</span></span></span><br><span class="line"><span class="function"><span class="params">    retries,</span></span></span><br><span class="line"><span class="function"><span class="params">    maximum,</span></span></span><br><span class="line"><span class="function"><span class="params">    full_jitter=False</span></span></span><br><span class="line"><span class="function"><span class="params">)</span>:</span></span><br><span class="line">    <span class="string">"""Calculate the exponential backoff wait time."""</span></span><br><span class="line">    <span class="comment"># Will be zero if factor equals 0</span></span><br><span class="line">    countdown = factor * (<span class="number">2</span> ** retries)</span><br><span class="line">    <span class="comment"># Full jitter according to</span></span><br><span class="line">    <span class="comment"># https://www.awsarchitectureblog.com/2015/03/backoff.html</span></span><br><span class="line">    <span class="keyword">if</span> full_jitter:</span><br><span class="line">        countdown = random.randrange(countdown + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># Adjust according to maximum wait time and account for negative values.</span></span><br><span class="line">    <span class="keyword">return</span> max(<span class="number">0</span>, min(maximum, countdown))</span><br></pre></td></tr></table></figure>
<p>这里 <code>factor</code> 是退避系数，作用于整体的退避时间。而 <code>retries</code> 则对应于上文的 <code>c</code>（也就是碰撞次数）。核心内容 <code>countdown = factor * (2 ** retries)</code> 和上文提到的指数退避算法思路一致。<br>在此基础上，可以将 <code>full_jitter</code> 设置为 <code>True</code>，含义是对退避时间做一个“抖动”，以具有一定的随机性。最后呢，则是限定给定值不能超过最大值 <code>maximum</code>，以避免无限长的等待时间。不过一旦取最大的退避时间，也就可能导致多个任务同时再次执行。更多见 <a href="http://docs.celeryproject.org/en/latest/userguide/tasks.html#Task.retry_jitter" title="Task.retry_jitter" target="_blank" rel="noopener">Task.retry_jitter</a> 。</p>
<h3 id="4-2-《UNIX-环境高级编程》中的连接示例"><a href="#4-2-《UNIX-环境高级编程》中的连接示例" class="headerlink" title="4.2 《UNIX 环境高级编程》中的连接示例"></a>4.2 《UNIX 环境高级编程》中的连接示例</h3><p>在 《UNIX 环境高级编程》（第 3 版）的 16.4 章节中，也有一个使用指数退避来建立连接的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSLEEP 128</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect_retry</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> alen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numsec, fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 使用指数退避尝试连接</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span> (numsec = <span class="number">1</span>; numsec &lt; MAXSLEEP; numsec &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (fd = socket(domain, type, protocol) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (connect(fd, addr, alen) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 连接接受</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">return</span> (fd);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 延迟后重试</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (numsec &lt;= MAXSLEEP / <span class="number">2</span>)</span><br><span class="line">            sleep(numsec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果连接失败，进程会休眠一小段时间（<code>numsec</code>），然后进入下次循环再次尝试。每次循环休眠时间是上一次的 2 倍，直到最大延迟 1 分多钟，之后便不再重试。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到开头的问题，在遇到限流错误的时候，通过指数退避算法进行重试，我们可以最大程度地避免再次限流。相比于固定时间重试，指数退避加入了时间放大性和随机性，从而变得更加“智能”。至此，我们再也不用担心限流让整个测试程序运行中断了~</p>
]]></content>
      <tags>
        <tag>限流</tag>
        <tag>指数退避</tag>
      </tags>
  </entry>
  <entry>
    <title>PEP 584：字典合并操作符来了</title>
    <url>/2020/02/29/PEP-584%EF%BC%9A%E5%AD%97%E5%85%B8%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%9D%A5%E4%BA%86/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>就在本周，字典合并特性（<a href="https://www.python.org/dev/peps/pep-0584/" title="PEP584" target="_blank" rel="noopener">PEP 584</a>）的提交被合入了 CPython 的主干分支，并在 2020-02-26 发布了 <a href="https://www.python.org/downloads/release/python-390a4/" title="Python 3.9.0a4" target="_blank" rel="noopener">Python 3.9.0a4</a> 预览版本。</p>
<img src="/2020/02/29/PEP-584：字典合并操作符来了/1.png">
<p>那什么是字典合并操作符呢？在回答这个问题前，我们不妨回忆下集合的合并操作。当我们想要对两个结合做合并操作时，会怎么做呢？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = &#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 | s2  <span class="comment"># s1 和 s2 取并集，生成新的集合；与 s1.union(s2) 等价</span></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 |= s2 <span class="comment"># s1 和 s2 取并集，并更新到 s1 上；与 s1.update(s2) 等价</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1</span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>类似地，我们希望 Python 中的字典能像集合一样，使用 <code>|</code> 和 <code>|=</code> 作为合并操作符，以解决我们在过去合并字典时感受到的“痛苦”，于是就有了 <code>PEP 584</code>。</p>
<p>今天就想和大家聊聊这个提案，不仅是要了解字典合并操作符的前世今生，更是要学习提案作者以及参与者是如何对引入一个新特性的思考，辩证性地分析利弊，最终确定引入。最后还想和大家分享下在 CPython 层面是如何实现的。</p>
<a id="more"></a>
<h2 id="二、背景"><a href="#二、背景" class="headerlink" title="二、背景"></a>二、背景</h2><p>在平时使用 Python 的过程中，我们有时会需要合并字典。目前合并字典有多种方式，它们或多或少都有些缺点。</p>
<h3 id="2-1-dict-update"><a href="#2-1-dict-update" class="headerlink" title="2.1 dict.update"></a>2.1 dict.update</h3><p><code>d1.update(d2)</code> 确实能合并两个字典，但它是在修改<code>d1</code>的基础上进行。如果我们想要合并成一个新的字典，没有一个直接使用表达式的方式，而需要借助临时变量进行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">e = d1.copy()</span><br><span class="line">e.update(d2)</span><br></pre></td></tr></table></figure>
<h3 id="2-2-d1-d2"><a href="#2-2-d1-d2" class="headerlink" title="2.2 {d1, d2}"></a>2.2 {<strong>d1, </strong>d2}</h3><p>字典解包可以将两个字典合并为一个新的字典，但看起来有些丑陋，并且不能让人显而易见地看出这是在合并字典。</p>
<p><code>{**d1, **d2}</code> 还会忽略映射类型，并始终返回字典类型。</p>
<h3 id="2-3-collections-ChainMap"><a href="#2-3-collections-ChainMap" class="headerlink" title="2.3 collections.ChainMap"></a>2.3 collections.ChainMap</h3><p><code>ChainMap</code> 很少有人知道，它也可以用作合并字典。但和前面合并方式相反，在合并两个字典时，第一个字典的键会覆盖第二个字典的相同键。</p>
<p>此外，由于 <code>ChainMap</code> 是对入参字典的封装，这意味着写入 <code>ChainMap</code> 会修改原始字典：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> ChainMap</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d1 = &#123;<span class="string">'a'</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d2 = &#123;<span class="string">'a'</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>merged = ChainMap(d1, d2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>merged[<span class="string">'a'</span>]     <span class="comment"># d1['a'] 会覆盖 d2['a']</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>merged[<span class="string">'a'</span>] = <span class="number">3</span> <span class="comment"># 实际等同于 d1['a'] = 3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d1</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-dict-d1-d2"><a href="#2-4-dict-d1-d2" class="headerlink" title="2.4 dict(d1, **d2)"></a>2.4 dict(d1, **d2)</h3><p>这是一种鲜为人知的合并字典的“巧妙方法”，但如果字典的键不是字符串，它就不能有效工作了：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d1 = &#123;<span class="string">'a'</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d2 = &#123;<span class="number">2</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(d1, **d2)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: keywords must be strings</span><br></pre></td></tr></table></figure>
<h2 id="三、原理"><a href="#三、原理" class="headerlink" title="三、原理"></a>三、原理</h2><p>新操作符同 <code>dict.update</code> 方法的关系，就和列表连接（<code>+</code>）、扩展（<code>+=</code>）操作符同 <code>list.extend</code> 方法的关系一样。需要注意的是，这和集合中 <code>|</code>/<code>|=</code> 操作符同 <code>set.update</code> 的关系稍有不同。作者明确了允许就地运算符接受更广泛的类型（就像 <code>list</code> 那样）是一种更有用的设计，并且限制二进制操作符的操作数类型（就像 <code>list</code> 那样）将有助于避免由复杂的隐式类型转换引起的错误被吞掉。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 + (<span class="number">3</span>,) <span class="comment"># 限制操作数的类型，不是列表就报错</span></span><br><span class="line">Traceback (most recent call last)</span><br><span class="line">...</span><br><span class="line">TypeError: can only concatenate list (<span class="keyword">not</span> <span class="string">"tuple"</span>) to list</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 += (<span class="number">3</span>,) <span class="comment"># 允许就地运算符接受更广泛的类型（如元组）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>当合并字典发生键冲突时，以最右边的值为准。这和现存的字典类似操作相符，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'a'</span>: <span class="number">2</span>&#125; <span class="comment"># 2 覆盖 1</span></span><br><span class="line">&#123;**d, **e&#125;       <span class="comment"># e覆盖d中相同键所对应的值</span></span><br><span class="line">d.update(e)      <span class="comment"># e覆盖d中相同键所对应的值</span></span><br><span class="line">d[k] = v         <span class="comment"># v 覆盖原有值</span></span><br><span class="line">&#123;k: v <span class="keyword">for</span> x <span class="keyword">in</span> (d, e) <span class="keyword">for</span> (k, v) <span class="keyword">in</span> x.items()&#125; <span class="comment"># e覆盖d中相同键所对应的值</span></span><br></pre></td></tr></table></figure>
<h2 id="四、规范"><a href="#四、规范" class="headerlink" title="四、规范"></a>四、规范</h2><p>字典合并会返回一个新字典，该字典由左操作数与右操作数合并而成，每个操作数必须是 <code>dict</code>（或 <code>dict</code> 子类的实例）。如果两个操作数中都出现一个键，则最后出现的值（即来自右侧操作数的值）将会覆盖：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="string">'spam'</span>: <span class="number">1</span>, <span class="string">'eggs'</span>: <span class="number">2</span>, <span class="string">'cheese'</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e = &#123;<span class="string">'cheese'</span>: <span class="string">'cheddar'</span>, <span class="string">'aardvark'</span>: <span class="string">'Ethel'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d | e</span><br><span class="line">&#123;<span class="string">'spam'</span>: <span class="number">1</span>, <span class="string">'eggs'</span>: <span class="number">2</span>, <span class="string">'cheese'</span>: <span class="string">'cheddar'</span>, <span class="string">'aardvark'</span>: <span class="string">'Ethel'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e | d <span class="comment"># 不符合交换律，左右互换操作数会得到不同的结果</span></span><br><span class="line">&#123;<span class="string">'aardvark'</span>: <span class="string">'Ethel'</span>, <span class="string">'spam'</span>: <span class="number">1</span>, <span class="string">'eggs'</span>: <span class="number">2</span>, <span class="string">'cheese'</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>
<p>扩展赋值版本的就地操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d |= e <span class="comment"># 将 e 更新到 d 中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'spam'</span>: <span class="number">1</span>, <span class="string">'eggs'</span>: <span class="number">2</span>, <span class="string">'cheese'</span>: <span class="string">'cheddar'</span>, <span class="string">'aardvark'</span>: <span class="string">'Ethel'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>扩展赋值的行为和字典的 <code>update</code> 方法完全一样，它还支持任何实现了映射协议（更确切地说是实现了 <code>keys</code> 和 <code>__getitem__</code> 方法）或键值对迭代对象。所以：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d | [(<span class="string">'spam'</span>, <span class="number">999</span>)]   <span class="comment"># “原理”章节中提到限制操作数的类型，不是字典或字典子类就报错</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">TypeError: can only merge dict (<span class="keyword">not</span> <span class="string">"list"</span>) to dict</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d |= [(<span class="string">'spam'</span>, <span class="number">999</span>)]  <span class="comment"># “原理”章节中提到允许就地运算符接受更广泛的类型，其行为和 update 一样，接受键值对迭代对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">&#123;<span class="string">'eggs'</span>: <span class="number">2</span>, <span class="string">'cheese'</span>: <span class="string">'cheddar'</span>, <span class="string">'aardvark'</span>: <span class="string">'Ethel'</span>, <span class="string">'spam'</span>: <span class="number">999</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、主流观点"><a href="#五、主流观点" class="headerlink" title="五、主流观点"></a>五、主流观点</h2><h3 id="5-1-字典合并不符合交换律"><a href="#5-1-字典合并不符合交换律" class="headerlink" title="5.1 字典合并不符合交换律"></a>5.1 字典合并不符合交换律</h3><p>合并是符合交换律的，但是字典联合却没有（<code>d | e != e | d</code>）。</p>
<blockquote>
<p>回应</p>
</blockquote>
<p>Python 中有过不符合交换律的合并先例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">0</span>&#125; | &#123;<span class="keyword">False</span>&#125;</span><br><span class="line">&#123;<span class="number">0</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="keyword">False</span>&#125; | &#123;<span class="number">0</span>&#125;</span><br><span class="line">&#123;<span class="keyword">False</span>&#125;</span><br></pre></td></tr></table></figure>
<p>上述结果虽然是相等的，但是本质是不同的。通常来说，<code>a | b</code> 和 <code>b | a</code> 并不相同。</p>
<h3 id="5-2-字典合并并不高效"><a href="#5-2-字典合并并不高效" class="headerlink" title="5.2 字典合并并不高效"></a>5.2 字典合并并不高效</h3><p>类似管道写法使用多次字典合并并不高效，比如 <code>d | e | f | g | h</code> 会创建和销毁三个临时映射。</p>
<blockquote>
<p>回应</p>
</blockquote>
<p>这种问题在序列级联时同样会出现。</p>
<p>序列级联的每一次合并都会使序列中的元素总数增加，最终会带来 O(N^2) 的性能开销。而字典合并有可能会有重复键，因此临时映射的大小并不会如此快速地增长。</p>
<p>正如我们很少将大量的列表或元组连接在一起一样，PEP的作者任务合并大量的字典也是少见情况。若是确实有这样的诉求，那么最好使用显式的循环和就地合并：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">new = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> many_dicts:</span><br><span class="line">    new |= d</span><br></pre></td></tr></table></figure>
<h3 id="5-3-字典合并是有损的"><a href="#5-3-字典合并是有损的" class="headerlink" title="5.3 字典合并是有损的"></a>5.3 字典合并是有损的</h3><p>字典合并可能会丢失数据（相同键的值可能消失），其他形式的合并并不会。</p>
<blockquote>
<p>回应</p>
</blockquote>
<p>作者并不觉得这种有损是一个问题。此外，<code>dict.update</code> 也会发生这种情况，但并不会丢弃键，这其实是符合预期的。只不过是现在使用的不是 <code>update</code> 而是 <code>|</code>。</p>
<p>如果从不可逆的角度考虑，其他类型的合并也是有损的。假设 <code>a | b</code> 的结果是365，那么 <code>a</code> 和 <code>b</code> 是多少却不得而知。</p>
<h3 id="5-4-只有一种方法达到目的"><a href="#5-4-只有一种方法达到目的" class="headerlink" title="5.4 只有一种方法达到目的"></a>5.4 只有一种方法达到目的</h3><p>字典合并不符合“Only One Way”的禅宗。</p>
<blockquote>
<p>回应</p>
</blockquote>
<p>其实并没有这样的禅宗。“Only One Way”起源于很早之前Perl社区对Python的诽谤。</p>
<h3 id="5-5-超过一种方法达到目的"><a href="#5-5-超过一种方法达到目的" class="headerlink" title="5.5 超过一种方法达到目的"></a>5.5 超过一种方法达到目的</h3><p>好吧，禅宗并没有说“Only One Way To Do It”。但是它明确禁止“超过一种方法达到目的”。</p>
<blockquote>
<p>回应</p>
</blockquote>
<p>并没有这样的禁止。Python 之禅仅表达了对“仅一种显而易见的方式”的偏爱。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">There should be one-- and preferably only one --obvious way to do</span><br><span class="line">it.</span><br></pre></td></tr></table></figure>
<p>它的重点是应该有一种明显的方式达到目的。对于字典更新操作来说，我们可能希望至少执行两个不同的操作：</p>
<ul>
<li>就地更新字典：显而易见的方式是使用 <code>update()</code> 方法。如果此提案被接受，<code>|=</code> 扩展赋值操作符也将等效，但这是扩展赋值如何定义的副作用。选择哪种取决于使用者口味。</li>
<li>合并两个现存的字典到新字典中：此提案中显而易见的方法是使用 <code>|</code> 合并操作符。</li>
</ul>
<p>实际上，Python 里经常违反对“仅一种方式”的偏爱。例如，每个 <code>for</code> 循环都可以重写为 <code>while</code> 循环；每个 <code>if</code> 块都可以写为 <code>if/else</code> 块。列表、集合和字典推导都可以用生成器表达式代替。列表提供了不少于五种方法来实现级联：</p>
<ul>
<li>级联操作符：<code>a + b</code></li>
<li>就地级联操作符：<code>a + = b</code></li>
<li>切片分配：<code>a[len(a):] = b</code></li>
<li>序列解压缩：<code>[*a, *b]</code></li>
<li>扩展方法：<code>a.extend(b)</code></li>
</ul>
<p>我们不能太教条主义，不能因为它违反了“仅一种方式”就非常严格的拒绝有用的功能。</p>
<h3 id="5-6-字典合并让代码更难理解"><a href="#5-6-字典合并让代码更难理解" class="headerlink" title="5.6 字典合并让代码更难理解"></a>5.6 字典合并让代码更难理解</h3><p>字典合并让人们更难理解代码的含义。为了解释该异议，而不是具体引用任何人的话：“在看到 <code>spam | eggs</code>，如果不知道 <code>spam</code> 和 <code>eggs</code> 是什么，根本就不知道这个表达式的作用”。</p>
<blockquote>
<p>回应</p>
</blockquote>
<p>这确实如此，即使没有该提案，<code>|</code> 操作符的现状也是如此：</p>
<ul>
<li>对于 <code>int</code>/<code>bool</code> 是按位或</li>
<li>对于 <code>set</code>/<code>forzenset</code> 是并集</li>
<li>还可能是任何其他的重载操作</li>
</ul>
<p>添加字典合并看起来并不会让理解代码变得更困难。确定 <code>spam</code> 和 <code>eggs</code> 是映射类型并不比确定是集合还是整数要花更多的工作。其实良好的命名约定将会有助于改善情况：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">flags |= WRITEABLE  <span class="comment"># 可能就是数字的按位或</span></span><br><span class="line">DO_NOT_RUN = WEEKENDS | HOLIDAYS  <span class="comment"># 可能就是集合合并</span></span><br><span class="line">settings = DEFAULT_SETTINGS | user_settings | workspace_settings  <span class="comment"># 可能就是字典合并</span></span><br></pre></td></tr></table></figure></p>
<h3 id="5-7-参考下完整的集合API"><a href="#5-7-参考下完整的集合API" class="headerlink" title="5.7 参考下完整的集合API"></a>5.7 参考下完整的集合API</h3><p>字典和集合很相似，应该要支持集合所支持的操作符：<code>|</code>、<code>&amp;</code>、<code>^</code> 和 <code>-</code>。</p>
<blockquote>
<p>回应</p>
</blockquote>
<p>也许后续会有PEP来专门说明这些操作符如何用于字典。简单来说：</p>
<p>把集合的对称差集（^）操作用在字典上面是显而易见且自然。比如：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d1 = &#123;<span class="string">"spam"</span>: <span class="number">1</span>, <span class="string">"eggs"</span>: <span class="number">2</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d2 = &#123;<span class="string">"ham"</span>: <span class="number">3</span>, <span class="string">"eggs"</span>: <span class="number">4</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于 <code>d1</code> 和 <code>d2</code> 对称差集，我们期望 <code>d1 ^ d2</code> 应该是 <code>{&quot;spam&quot;: 1, &quot;ham&quot;: 3}</code></p>
<p>把集合的差集（-）操作用在字典上面也是显而易见和自然的。比如 <code>d1</code> 和 <code>d2</code> 的差集，我们期望：</p>
<ul>
<li><code>d1 - d2</code> 为 <code>{&quot;spam&quot;: 1}</code></li>
<li><code>d2 - d1</code> 为 <code>{&quot;ham&quot;: 3}</code></li>
</ul>
<p>把集合的交集（&amp;）操作用在字典上面就有些问题了。虽然很容易确定两个字典中键的交集，但是如何处理键所对应的值就比较模糊。不难看出 <code>d1</code> 和 <code>d2</code> 的共同键是 <code>eggs</code>，如果我们遵循“后者胜出”的一致性原则，那么值就是 4。</p>
<h2 id="六、已拒绝的观点"><a href="#六、已拒绝的观点" class="headerlink" title="六、已拒绝的观点"></a>六、已拒绝的观点</h2><p><code>PEP 584</code> 提案中罗列了很多已拒绝的观点，比如使用 <code>+</code> 来合并字典；在合并字典时也合并值类型为列表的值等等。这些观点都非常有意思，被拒绝的理由也同样有说服力。限于篇幅的原因不再进一步展开，感兴趣的可以阅读 <a href="https://www.python.org/dev/peps/pep-0584/#id34。" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0584/#id34。</a></p>
<h2 id="七、实现"><a href="#七、实现" class="headerlink" title="七、实现"></a>七、实现</h2><h3 id="7-1-纯-Python-实现"><a href="#7-1-纯-Python-实现" class="headerlink" title="7.1 纯 Python 实现"></a>7.1 纯 Python 实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__or__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(other, dict):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">    new = dict(self)</span><br><span class="line">    new.update(other)</span><br><span class="line">    <span class="keyword">return</span> new</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__ror__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isinstance(other, dict):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">NotImplemented</span></span><br><span class="line">    new = dict(other)</span><br><span class="line">    new.update(self)</span><br><span class="line">    <span class="keyword">return</span> new</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__ior__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">    dict.update(self, other)</span><br><span class="line">    <span class="keyword">return</span> self</span><br></pre></td></tr></table></figure>
<p>纯 Python 实现并不复杂，我们只需让 dict 实现几个魔法方法：</p>
<ul>
<li><code>__or__</code> 和 <code>__ror__</code> 魔法方法对应于 <code>|</code> 操作符，<code>__or__</code> 表示对象在操作符左侧，<code>__ror__</code> 表示对象在操作符右侧。实现就是根据左侧操作数生成一个新字典，再把右侧操作数更新到新字典中，并返回新字典。</li>
<li><code>__ior__</code> 魔法方法对应于 <code>|=</code> 操作符，将右侧操作数更新到自身即可。</li>
</ul>
<h3 id="7-2-CPython-实现"><a href="#7-2-CPython-实现" class="headerlink" title="7.2 CPython 实现"></a>7.2 CPython 实现</h3><p>CPython 中字典合并的详细实现可见此 PR： <a href="https://github.com/python/cpython/pull/12088/files" target="_blank" rel="noopener">https://github.com/python/cpython/pull/12088/files</a> 。</p>
<p>最核心的实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现字典合并生成新字典的逻辑，对应于 | 操作符</span></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">dict_or(PyObject *self, PyObject *other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!PyDict_Check(self) || !PyDict_Check(other)) &#123;</span><br><span class="line">        Py_RETURN_NOTIMPLEMENTED;</span><br><span class="line">    &#125;</span><br><span class="line">    PyObject *<span class="keyword">new</span> = PyDict_Copy(self);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dict_update_arg(<span class="keyword">new</span>, other)) &#123;</span><br><span class="line">        Py_DECREF(<span class="keyword">new</span>); <span class="comment">// 减少引用计数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现字典就地合并逻辑，对应于 |= 操作符</span></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">dict_ior(PyObject *self, PyObject *other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (dict_update_arg(self, other)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(self); <span class="comment">// 增加引用计数</span></span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CPython 的实现逻辑和纯Python实现几乎一样，唯独需要注意的就是引用计数的问题，这关系到对象的垃圾回收。</p>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p><code>PEP 584</code> 是一个非常精彩的提案，引入 <code>|</code> 和 <code>|=</code> 操作符用作字典合并，看似是一个比较简单的功能，但所要考虑的情况却不少。不仅需要说明这个提案的背景，目前有哪些方式可以达到目的，它们有哪些痛点；还要考虑对既有类型引入操作符所带来的各种影响，对开发者提出的质疑和顾虑进行思考和解决。整个提案所涉及到的方法论、思考维度、知识点都非常值得学习。</p>
<p>对使用者来说，合并字典将会变得更加方便。在提案的最后，作者给出了许多第三方库在合并字典时采用新方式编写的例子，可谓是简洁了不少。详见 <a href="https://www.python.org/dev/peps/pep-0584/#id50" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0584/#id50</a> 。</p>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>PEP</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>PEP</tag>
      </tags>
  </entry>
  <entry>
    <title>图表即代码：使用 Diagrams 制作云系统架构原型图</title>
    <url>/2020/02/16/%E5%9B%BE%E8%A1%A8%E5%8D%B3%E4%BB%A3%E7%A0%81%EF%BC%9A%E4%BD%BF%E7%94%A8-Diagrams-%E5%88%B6%E4%BD%9C%E4%BA%91%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E5%8E%9F%E5%9E%8B%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>昨天发现了一款非常不错的云系统架构原型图制作库 <a href="https://github.com/mingrammer/diagrams" title="Diagrams" target="_blank" rel="noopener">Diagrams</a>，通过它，我们便可以使用代码的方式绘制诸如阿里云、AWS、Azure、K8S 等系统架构原型图。</p>
<p>相比于在 UI 上对各种图标进行拖拽和调整，这种方式更符合我们程序员的使用习惯。</p>
<p>本文不仅要介绍下这个库，也想说说我是如何参与到这个库中以支持阿里云资源。</p>
<h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><p><code>Diagrams</code> 使用 <a href="https://www.graphviz.org/" title="Graphviz" target="_blank" rel="noopener">Graphviz</a> 来渲染图表，在安装 <code>diagrams</code> 之前需要先<a href="https://graphviz.gitlab.io/download/" title="安装 Graphviz" target="_blank" rel="noopener">安装 Graphviz</a>。</p>
<blockquote>
<p>macOS 用户（如果使用 <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>）可以使用 <code>brew install graphviz</code> 的方式来安装 <code>Graphviz</code>。</p>
</blockquote>
<p>安装 <code>diagrams</code> 的方式有多种，通过 <code>pip</code>、<code>pipenv</code> 和 <code>poetry</code> 均可：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 pip (pip3)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pip install diagrams</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 pipenv</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pipenv install diagrams</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 poetry</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> poetry add diagrams</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="三、快速开始"><a href="#三、快速开始" class="headerlink" title="三、快速开始"></a>三、快速开始</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># diagram.py</span></span><br><span class="line"><span class="keyword">from</span> diagrams <span class="keyword">import</span> Diagram</span><br><span class="line"><span class="keyword">from</span> diagrams.alibabacloud.network <span class="keyword">import</span> SLB</span><br><span class="line"><span class="keyword">from</span> diagrams.alibabacloud.compute <span class="keyword">import</span> ECS</span><br><span class="line"><span class="keyword">from</span> diagrams.alibabacloud.database <span class="keyword">import</span> RDS</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Diagram(<span class="string">"Web Service"</span>, show=<span class="keyword">False</span>):</span><br><span class="line">    SLB(<span class="string">"lb"</span>) &gt;&gt; ECS(<span class="string">"web"</span>) &gt;&gt; RDS(<span class="string">"userdb"</span>)</span><br></pre></td></tr></table></figure>
<p>执行后，就能生成如下架构图：</p>
<figure class="highlight shell"><figcaption><span>script</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> python diagram.py</span></span><br></pre></td></tr></table></figure>
<img src="/2020/02/16/图表即代码：使用-Diagrams-制作云系统架构原型图/1.jpg">
<h2 id="四、指南"><a href="#四、指南" class="headerlink" title="四、指南"></a>四、指南</h2><p><code>Diagrams</code> 库非常容易掌握，我们仅需要掌握三个概念就能轻松绘制云系统架构图：</p>
<ul>
<li><code>Diagram</code>：这是表示图的最主要的对象，代表一个架构图</li>
<li><code>Node</code>：表示一个节点或系统组件，比如<code>快速开始</code>中的<code>SLB</code>、<code>ECS</code>和<code>RDS</code>都是架构图中的节点</li>
<li><code>Cluster</code>：表示集群或分组，可将多个节点放到一个集群中</li>
</ul>
<h3 id="4-1-图-Diagram"><a href="#4-1-图-Diagram" class="headerlink" title="4.1 图 Diagram"></a>4.1 图 Diagram</h3><p>使用 <code>Diagram</code> 类来创建图环境上下文，使用 <code>with</code> 语法来使用这个上下文。<code>Diagram</code> 的第一个参数是会被用作架构图的名称以及输出的图片文件名（转换为小写+下划线）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> diagrams <span class="keyword">import</span> Diagram</span><br><span class="line"><span class="keyword">from</span> diagrams.aws.compute <span class="keyword">import</span> EC2</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Diagram(<span class="string">"Simple Diagram"</span>):</span><br><span class="line">    EC2(<span class="string">"web"</span>)</span><br></pre></td></tr></table></figure>
<p>运行上述代码，会生成一个包含 <code>EC2</code> 节点的架构图，并存放在当前的 <code>simple_diagram.png</code> 中。</p>
<p><code>Diagram</code> 类还支持如下参数：</p>
<ul>
<li><code>outformat</code>：指定输出图片的类型，默认是 <code>png</code>，可以是 <code>png</code>、<code>jpg</code>、<code>svg</code> 和 <code>pdf</code></li>
<li><code>show</code>：指定是否显示图片，默认是 <code>False</code></li>
<li><code>graph_attr</code>、<code>node_attr</code> 和 <code>edge_attr</code>：指定 <code>Graphviz</code> 属性选项，用来控制图、点、线的样式，详情查看 <a href="https://www.graphviz.org/doc/info/attrs.html" title="参考链接" target="_blank" rel="noopener">参考链接</a></li>
</ul>
<h3 id="4-2-节点-Node"><a href="#4-2-节点-Node" class="headerlink" title="4.2 节点 Node"></a>4.2 节点 Node</h3><p>目前，<code>Diagrams</code> 支持五类云资源节点，分别是 <code>AWS</code>、<code>Azure</code>、<code>AlibabaCloud</code>、<code>GCP</code> 和 <code>K8S</code>。</p>
<p>节点之间的关系使用操作符来表示，分别是：</p>
<ul>
<li><code>&gt;&gt;</code>：左节点指向右节点</li>
<li><code>&lt;&lt;</code>：右节点指向左节点</li>
<li><code>-</code>：节点互相连接，没有方向</li>
</ul>
<p>以下是一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> diagrams <span class="keyword">import</span> Diagram</span><br><span class="line"><span class="keyword">from</span> diagrams.aws.compute <span class="keyword">import</span> EC2</span><br><span class="line"><span class="keyword">from</span> diagrams.aws.database <span class="keyword">import</span> RDS</span><br><span class="line"><span class="keyword">from</span> diagrams.aws.network <span class="keyword">import</span> ELB</span><br><span class="line"><span class="keyword">from</span> diagrams.aws.storage <span class="keyword">import</span> S3</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Diagram(<span class="string">"Web Services"</span>, show=<span class="keyword">False</span>):</span><br><span class="line">    ELB(<span class="string">"lb"</span>) &gt;&gt; EC2(<span class="string">"web"</span>) &gt;&gt; RDS(<span class="string">"userdb"</span>) &gt;&gt; S3(<span class="string">"store"</span>)</span><br><span class="line">    ELB(<span class="string">"lb"</span>) &gt;&gt; EC2(<span class="string">"web"</span>) &gt;&gt; RDS(<span class="string">"userdb"</span>) &lt;&lt; EC2(<span class="string">"stat"</span>)</span><br><span class="line">    (ELB(<span class="string">"lb"</span>) &gt;&gt; EC2(<span class="string">"web"</span>)) - EC2(<span class="string">"web"</span>) &gt;&gt; RDS(<span class="string">"userdb"</span>)</span><br></pre></td></tr></table></figure>
<img src="/2020/02/16/图表即代码：使用-Diagrams-制作云系统架构原型图/2.jpg">
<p><code>Diagrams</code> 不仅支持单个节点的关系建立，还支持一组节点和其他节点的关系建立，使用 <code>list</code> 来表示一组节点。示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> diagrams <span class="keyword">import</span> Diagram</span><br><span class="line"><span class="keyword">from</span> diagrams.aws.compute <span class="keyword">import</span> EC2</span><br><span class="line"><span class="keyword">from</span> diagrams.aws.database <span class="keyword">import</span> RDS</span><br><span class="line"><span class="keyword">from</span> diagrams.aws.network <span class="keyword">import</span> ELB</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Diagram(<span class="string">"Grouped Workers"</span>, show=<span class="keyword">False</span>, direction=<span class="string">"TB"</span>):</span><br><span class="line">    ELB(<span class="string">"lb"</span>) &gt;&gt; [EC2(<span class="string">"worker1"</span>),</span><br><span class="line">                  EC2(<span class="string">"worker2"</span>),</span><br><span class="line">                  EC2(<span class="string">"worker3"</span>),</span><br><span class="line">                  EC2(<span class="string">"worker4"</span>),</span><br><span class="line">                  EC2(<span class="string">"worker5"</span>)] &gt;&gt; RDS(<span class="string">"events"</span>)</span><br></pre></td></tr></table></figure>
<img src="/2020/02/16/图表即代码：使用-Diagrams-制作云系统架构原型图/3.jpg">
<h3 id="4-3-集群-组-Cluster"><a href="#4-3-集群-组-Cluster" class="headerlink" title="4.3 集群/组 Cluster"></a>4.3 集群/组 Cluster</h3><p>当我们需要在架构图上表示几个节点属于一个集群时，就要用到 <code>Cluster</code>。和 <code>Diagram</code> 的使用方式类似，它也是一个上下文管理器，使用 <code>with</code> 语法。<br>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> diagrams <span class="keyword">import</span> Cluster, Diagram</span><br><span class="line"><span class="keyword">from</span> diagrams.aws.compute <span class="keyword">import</span> ECS</span><br><span class="line"><span class="keyword">from</span> diagrams.aws.database <span class="keyword">import</span> RDS</span><br><span class="line"><span class="keyword">from</span> diagrams.aws.network <span class="keyword">import</span> Route53</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Diagram(<span class="string">"Simple Web Service with DB Cluster"</span>, show=<span class="keyword">False</span>):</span><br><span class="line">    dns = Route53(<span class="string">"dns"</span>)</span><br><span class="line">    web = ECS(<span class="string">"service"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> Cluster(<span class="string">"DB Cluster"</span>):</span><br><span class="line">        db_master = RDS(<span class="string">"master"</span>)</span><br><span class="line">        db_master - [RDS(<span class="string">"slave1"</span>),</span><br><span class="line">                     RDS(<span class="string">"slave2"</span>)]</span><br><span class="line"></span><br><span class="line">    dns &gt;&gt; web &gt;&gt; db_master</span><br></pre></td></tr></table></figure>
<img src="/2020/02/16/图表即代码：使用-Diagrams-制作云系统架构原型图/4.jpg">
<p><code>Diagrams</code> 还支持嵌套集群，只需嵌套使用 <code>with Cluster()</code> 即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> diagrams <span class="keyword">import</span> Cluster, Diagram</span><br><span class="line"><span class="keyword">from</span> diagrams.aws.compute <span class="keyword">import</span> ECS, EKS, Lambda</span><br><span class="line"><span class="keyword">from</span> diagrams.aws.database <span class="keyword">import</span> Redshift</span><br><span class="line"><span class="keyword">from</span> diagrams.aws.integration <span class="keyword">import</span> SQS</span><br><span class="line"><span class="keyword">from</span> diagrams.aws.storage <span class="keyword">import</span> S3</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Diagram(<span class="string">"Event Processing"</span>, show=<span class="keyword">False</span>):</span><br><span class="line">    source = EKS(<span class="string">"k8s source"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> Cluster(<span class="string">"Event Flows"</span>):</span><br><span class="line">        <span class="keyword">with</span> Cluster(<span class="string">"Event Workers"</span>):</span><br><span class="line">            workers = [ECS(<span class="string">"worker1"</span>),</span><br><span class="line">                       ECS(<span class="string">"worker2"</span>),</span><br><span class="line">                       ECS(<span class="string">"worker3"</span>)]</span><br><span class="line"></span><br><span class="line">        queue = SQS(<span class="string">"event queue"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">with</span> Cluster(<span class="string">"Processing"</span>):</span><br><span class="line">            handlers = [Lambda(<span class="string">"proc1"</span>),</span><br><span class="line">                        Lambda(<span class="string">"proc2"</span>),</span><br><span class="line">                        Lambda(<span class="string">"proc3"</span>)]</span><br><span class="line"></span><br><span class="line">    store = S3(<span class="string">"events store"</span>)</span><br><span class="line">    dw = Redshift(<span class="string">"analytics"</span>)</span><br><span class="line"></span><br><span class="line">    source &gt;&gt; workers &gt;&gt; queue &gt;&gt; handlers</span><br><span class="line">    handlers &gt;&gt; store</span><br><span class="line">    handlers &gt;&gt; dw</span><br></pre></td></tr></table></figure>
<img src="/2020/02/16/图表即代码：使用-Diagrams-制作云系统架构原型图/5.jpg">
<h2 id="五、我是如何贡献代码"><a href="#五、我是如何贡献代码" class="headerlink" title="五、我是如何贡献代码"></a>五、我是如何贡献代码</h2><p>看到 <code>Diagrams</code> 库时，我感到很兴奋。我们画示意图无外乎两种，一种是通过<code>UI</code>来画，一种是通过<code>DSL</code>来制作。在流程图、时序图方面，<a href="https://plantuml.com/zh/" title="PlantUML" target="_blank" rel="noopener">PlantUML</a> 是我很喜欢的 <code>DSL</code>，然而在云系统架构图方面，过去确实没发现相关的库，直到看到了 <code>Diagrams</code>。</p>
<p>在我看到 <code>Diagrams</code> 时，它还只是支持 <code>AWS</code>、<code>Azure</code>、<code>GCP</code> 和 <code>K8S</code>，我心想怎么能没有<code>阿里云</code>呢？这么好的库我岂不是用不了了。既然如此，不如自己动手，丰衣足食吧。阅读 <code>Diagrams</code> 的代码，会发现写的还真不错，代码清晰简单，还提供了完善的脚手架。</p>
<p>对于它所支持的云供应商（比如 <code>AWS</code>），当我们想更新里面的资源时，只需要在 <code>resources/aws</code> 文件夹中更新资源图片，然后执行 <code>./autogen.sh</code> 即可。<code>./autogen.sh</code> 会对 <code>resources/</code> 做这么几件事：</p>
<ul>
<li>将特定云供应商的 <code>svg</code> 图片转换为 <code>png</code></li>
<li>将特定云供应商的图片调整为圆角图片</li>
<li>自动生成节点类代码</li>
<li>自动生成文档</li>
<li>使用 <code>black</code> 格式化自动生成的代码</li>
</ul>
<p>对于它所不支持的云供应商（比如 <code>AlibabaCloud</code>），则要先修改脚手架和配置文件以支持新的云供应商，然后遵循上面的方法即可。具体改动内容可见 <a href="https://github.com/mingrammer/diagrams/pull/19" title="Diagrams 支持阿里云 PR" target="_blank" rel="noopener">此 PR</a>。</p>
<p>参与一个开源项目其实就是这么简单，当你发现满足不了你的需求时，就阅读它的源码以了解实现原理，然后再自己动手实现需求，最后就是向作者提个 PR。</p>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Diagrams</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</title>
    <url>/2020/02/09/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9Aargparse%E3%80%81docopt%E3%80%81click-%E5%92%8C-fire-%E6%80%BB%E7%BB%93%E7%AF%87/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在近半年的 Python 命令行旅程中，我们依次学习了 <code>argparse</code>、<code>docopt</code>、<code>click</code> 和 <code>fire</code> 库的特点和用法，逐步了解到 Python 命令行库的设计哲学与演变。<br>本文作为本次旅程的终点，希望从一个更高的视角对这些库进行横向对比，总结它们的异同点和使用场景，以期在应对不同场景时能够分析利弊，选择合适的库为己所用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<h2 id="二、设计理念"><a href="#二、设计理念" class="headerlink" title="二、设计理念"></a>二、设计理念</h2><p>在讨论各个库的设计理念之前，我们先设计一个<code>计算器程序</code>，其实这个例子在 <code>argparse</code> 库的第一篇讲解中出现过，也就是：</p>
<ul>
<li>命令行程序接受一个位置参数，它能出现多次，且是数字</li>
<li>默认情况下，命令行程序会求出给定的一串数字的最大值</li>
<li>如果指定了选项参数 <code>--sum</code>，那么就会将求出给定的一串数字的和</li>
</ul>
<p>希望从各个库实现该例子的代码中能进一步体会它们的设计理念。</p>
<a id="more"></a>
<h3 id="2-1、argparse"><a href="#2-1、argparse" class="headerlink" title="2.1、argparse"></a>2.1、argparse</h3><p><code>argparse</code> 的设计理念就是提供给你最细粒度的控制，你需要详细地告诉它参数是选项参数还是位置参数、参数值的类型是什么、该参数的处理动作是怎样的。<br>总之，它就像是一个没有智能分析能力的初代机器人，你需要告诉它明确的信息，它才会根据给定的信息去帮助你做事情。</p>
<p>以下示例为 <code>argparse</code> 实现的 <code>计算器程序</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 设置解析器</span></span><br><span class="line">parser = argparse.ArgumentParser(description=<span class="string">'Calculator Program.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 定义参数</span></span><br><span class="line"><span class="comment"># 添加位置参数 nums，在帮助信息中显示为 num</span></span><br><span class="line"><span class="comment"># 其类型为 int，且支持输入多个，且至少需要提供一个</span></span><br><span class="line">parser.add_argument(<span class="string">'nums'</span>,  metavar=<span class="string">'num'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                    help=<span class="string">'a num for the accumulator'</span>)</span><br><span class="line"><span class="comment"># 添加选项参数 --sum，该参数被 parser 解析后所对应的属性名为 accumulate</span></span><br><span class="line"><span class="comment"># 若不提供 --sum，默认值为 max 函数，否则为 sum 函数</span></span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                    const=sum, default=max,</span><br><span class="line">                    help=<span class="string">'sum the nums (default: find the max)'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 解析参数</span></span><br><span class="line">args = parser.parse_args([<span class="string">'--sum'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>])</span><br><span class="line">print(args) <span class="comment"># 结果：Namespace(accumulate=&lt;built-in function sum&gt;, nums=[1, 2, 3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 业务逻辑</span></span><br><span class="line">result = args.accumulate(args.nums)</span><br><span class="line">print(result)  <span class="comment"># 基于上文的 ['--sum', '1', '2', '3'] 参数，accumulate 为 sum 函数，其结果为 6</span></span><br></pre></td></tr></table></figure>
<p>从上述示例可以看到，我们需要通过 <code>add_argument</code> 很明确地告诉 <code>argparse</code> 参数长什么样：</p>
<ul>
<li>它是位置参数 <code>nums</code>，还是选项参数 <code>--sum</code></li>
<li>它的类型是什么，比如 <code>type=int</code> 表示类型是 int</li>
<li>这个参数能重复出现几次，比如 <code>nargs=&#39;+&#39;</code> 表示至少提供 1 个</li>
<li>参数的是存什么的，比如 <code>action=&#39;store_const&#39;</code> 表示存常量</li>
</ul>
<p>然后它才根据给定的这些元信息来解析命令行参数（也就是示例中的 <code>[&#39;--sum&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</code>）。</p>
<p>这是很计算机的思维，虽然冗长，但也带来了灵活性。</p>
<h3 id="2-2、docopt"><a href="#2-2、docopt" class="headerlink" title="2.2、docopt"></a>2.2、docopt</h3><p>从 <code>argparse</code> 的理念可以看出，它是命令式的。这时候 <code>docopt</code> 另辟蹊径，声明式是不是也可以？一个命令行程序的帮助信息其实已然包含了这个命令行的完整元信息，那不就可以通过定义帮助信息来定义命令行？<code>docopt</code> 就是基于这样的想法去设计的。</p>
<p>声明式的好处在于只要你掌握了声明式的语法，那么定义命令行的元信息就会很简单。</p>
<p>以下示例为 <code>docopt</code> 实现的 <code>计算器程序</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1. 定义接口描述/帮助信息</span></span><br><span class="line"><span class="string">"""Calculator Program.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">  calculator.py [--sum] &lt;num&gt;...</span></span><br><span class="line"><span class="string">  calculator.py (-h | --help)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">  -h --help     Show help.</span></span><br><span class="line"><span class="string">  --sum         Sum the nums (default: find the max).</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> docopt <span class="keyword">import</span> docopt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 解析命令行</span></span><br><span class="line">arguments = docopt(__doc__, options_first=<span class="keyword">True</span>, argv=[<span class="string">'--sum'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>])</span><br><span class="line">print(arguments) <span class="comment"># 结果：&#123;'--help': False, '--sum': True, '&lt;num&gt;': ['1', '2', '3']&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 业务逻辑</span></span><br><span class="line">nums = (int(num) <span class="keyword">for</span> num <span class="keyword">in</span> arguments[<span class="string">'&lt;num&gt;'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> arguments[<span class="string">'--sum'</span>]:</span><br><span class="line">    result = sum(nums)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    result = max(nums)</span><br><span class="line"></span><br><span class="line">print(result) <span class="comment"># 基于上文的 ['--sum', '1', '2', '3'] 参数，处理函数为 sum 函数，其结果为 6</span></span><br></pre></td></tr></table></figure>
<p>从上述示例可以看到，我们通过 <code>__doc__</code> 定义了接口描述，这和 <code>argparse</code> 中 <code>add_argument</code> 是等价的，然后 <code>docopt</code> 便会根据这个元信息把命令行参数转换为一个字典。业务逻辑中就需要对这个字典进行处理。</p>
<p>对比与 <code>argparse</code>：</p>
<ul>
<li>对于更为复杂的命令程序，元信息的定义上 <code>docopt</code> 会更加简单</li>
<li>然而在业务逻辑的处理上，由于 <code>argparse</code> 在一些简单参数的处理上会更加便捷（比如示例中的情形），相对来说 <code>docopt</code> 转换为字典后就把所有处理交给业务逻辑的方式会更加复杂</li>
</ul>
<h3 id="2-3、click"><a href="#2-3、click" class="headerlink" title="2.3、click"></a>2.3、click</h3><p>命令行程序本质上是定义参数和处理参数，而处理参数的逻辑一定是与所定义的参数有关联的。那可不可以用函数和装饰器来实现处理参数逻辑与定义参数的关联呢？而 <code>click</code> 正好就是以这种使用方式来设计的。</p>
<p><code>click</code> 使用装饰器的好处就在于用装饰器优雅的语法将参数定义和处理逻辑整合在一起，从而暗示了路由关系。相比于 <code>argparse</code> 和 <code>docopt</code> 需要自行对解析后的参数来做路由关系，简单了不少。</p>
<p>以下示例为 <code>click</code> 实现的 <code>计算器程序</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> click</span><br><span class="line"></span><br><span class="line">sys.argv = [<span class="string">'calculator.py'</span>, <span class="string">'--sum'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 定义参数</span></span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.argument('nums', nargs=-1, type=int)</span></span><br><span class="line"><span class="meta">@click.option('--sum', 'use_sum', is_flag=True, help='sum the nums (default: find the max)')</span></span><br><span class="line"><span class="comment"># 1. 业务逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculator</span><span class="params">(nums, use_sum)</span>:</span></span><br><span class="line">    <span class="string">"""Calculator Program."""</span></span><br><span class="line">    print(nums, use_sum) <span class="comment"># 输出：(1, 2, 3) True</span></span><br><span class="line">    <span class="keyword">if</span> use_sum:</span><br><span class="line">        result = sum(nums)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = max(nums)</span><br><span class="line"></span><br><span class="line">    print(result) <span class="comment"># 基于上文的 ['--sum', '1', '2', '3'] 参数，处理函数为 sum 函数，其结果为 6</span></span><br><span class="line"></span><br><span class="line">calculator()</span><br></pre></td></tr></table></figure>
<p>从上述示例可以看出，参数和对应的处理逻辑非常好地绑定在了一起，看上去就很直观，使得我们可以明确了解参数会怎么处理，这在有大量参数时显得尤为重要，这边是 <code>click</code> 相比于 <code>argparse</code> 和 <code>docopt</code> 最明显的优势。</p>
<p>此外，<code>click</code> 还内置了很多实用工具和额外能力，比如说 Bash 补全、颜色、分页支持、进度条等诸多实用功能，可谓是如虎添翼。</p>
<h3 id="2-4、fire"><a href="#2-4、fire" class="headerlink" title="2.4、fire"></a>2.4、fire</h3><p><code>fire</code> 则是用一种面向广义对象的方式来玩转命令行，这种对象可以是类、函数、字典、列表等，它更加灵活，也更加简单。你都不需要定义参数类型，<code>fire</code> 会根据输入和参数默认值来自动判断，这无疑进一步简化了实现过程。</p>
<p>以下示例为 <code>click</code> 实现的 <code>计算器程序</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"></span><br><span class="line">sys.argv = [<span class="string">'calculator.py'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'--sum'</span>]</span><br><span class="line"></span><br><span class="line">builtin_sum = sum</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 业务逻辑</span></span><br><span class="line"><span class="comment"># sum=False，暗示它是一个选项参数 --sum，不提供的时候为 False</span></span><br><span class="line"><span class="comment"># *nums 暗示它是一个能提供任意数量的位置参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculator</span><span class="params">(sum=False, *nums)</span>:</span></span><br><span class="line">    <span class="string">"""Calculator Program."""</span></span><br><span class="line">    print(sum, nums) <span class="comment"># 输出：True (1, 2, 3)</span></span><br><span class="line">    <span class="keyword">if</span> sum:</span><br><span class="line">        result = builtin_sum(nums)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        result = max(nums)</span><br><span class="line"></span><br><span class="line">    print(result) <span class="comment"># 基于上文的 ['1', '2', '3', '--sum'] 参数，处理函数为 sum 函数，其结果为 6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fire.Fire(calculator)</span><br></pre></td></tr></table></figure>
<p>从上述示例可以看出，<code>fire</code> 提供的方式无疑是最简单、并且最 Pythonic 的了。我们只需关注业务逻辑，而命令行参数的定义则和函数参数的定义融为了一体。</p>
<p>不过，有利自然也有弊，比如 <code>nums</code> 并没有说是什么类型，也就意味着输入字符串’abc’也是合法的，这就意味着一个严格的命令行程序必须在自己的业务逻辑中来对期望的类型进行约束。</p>
<h2 id="三、横向对比"><a href="#三、横向对比" class="headerlink" title="三、横向对比"></a>三、横向对比</h2><p>最后，我们横向对比下<code>argparse</code>、<code>docopt</code>、<code>click</code> 和 <code>fire</code> 库的各项功能和特点：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:left">argpase</th>
<th style="text-align:left">docopt</th>
<th style="text-align:left">click</th>
<th style="text-align:left">fire</th>
</tr>
</thead>
<tbody>
<tr>
<td>使用步骤数</td>
<td style="text-align:left">4 步</td>
<td style="text-align:left">3 步</td>
<td style="text-align:left">2 步</td>
<td style="text-align:left">1 步</td>
</tr>
<tr>
<td>使用步骤数</td>
<td style="text-align:left">1. 设置解析器<br>2. 定义参数<br>3. 解析命令行<br>4. 业务逻辑</td>
<td style="text-align:left">1. 定义接口描述<br>2. 解析命令行<br>3. 业务逻辑</td>
<td style="text-align:left">1. 业务逻辑<br>2. 定义参数</td>
<td style="text-align:left">1. 业务逻辑</td>
</tr>
<tr>
<td>选项参数<br>（如 <code>--sum</code>）</td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
</tr>
<tr>
<td>位置参数<br>（如 <code>X Y</code>）</td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
</tr>
<tr>
<td>参数默认值<br></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="red">✘</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
</tr>
<tr>
<td>互斥选项<br>（如 <code>--car</code> 和 <code>--bus</code> 只能二选一）</td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="yellow">✔</font><br>可通过第三方库支持</td>
<td style="text-align:left"><font color="red">✘</font></td>
</tr>
<tr>
<td>可变参数<br>（如指定多个 <code>--file</code>）</td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
</tr>
<tr>
<td>嵌套/父子命令<br></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
</tr>
<tr>
<td>工具箱<br></td>
<td style="text-align:left"><font color="red">✘</font></td>
<td style="text-align:left"><font color="red">✘</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
</tr>
<tr>
<td>链式命令调用<br></td>
<td style="text-align:left"><font color="red">✘</font></td>
<td style="text-align:left"><font color="red">✘</font></td>
<td style="text-align:left"><font color="red">✘</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
</tr>
<tr>
<td>类型约束</td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="red">✘</font></td>
<td style="text-align:left"><font color="green">✔</font></td>
<td style="text-align:left"><font color="red">✘</font></td>
</tr>
</tbody>
</table>
<p>Python 的命令行库种类繁多、各具特色。结合上面的总结，可以选择出符合使用场景的库，如果几个库都符合，那么就根据你更偏爱的风格来选择。这些库都很优秀，其背后的思想很是值得我们学习和扩展。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>argparse</tag>
        <tag>click</tag>
        <tag>docopt</tag>
        <tag>fire</tag>
      </tags>
  </entry>
  <entry>
    <title>一行命令自动戴上口罩</title>
    <url>/2020/01/31/%E4%B8%80%E8%A1%8C%E5%91%BD%E4%BB%A4%E8%87%AA%E5%8A%A8%E6%88%B4%E4%B8%8A%E5%8F%A3%E7%BD%A9/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>2019 年底开始蔓延的新型肺炎疫情牵动人心，作为个体，我们力所能及的就是尽量待在家中少出门。</p>
<p>看到一些朋友叫设计同学帮忙给自己的头像戴上口罩，作为技术人，心想一定还有更多人有这样的诉求，不如开发一个简单的程序来实现这个需求，也算是帮助设计姐姐减少工作量。</p>
<p>于是花了些时间，写了一个叫做 <a href="https://github.com/Prodesire/face-mask" title="face-mask" target="_blank" rel="noopener">face-mask</a> 的命令行工具，能够轻松的给图片中的人像戴上口罩，而且口罩的方向和大小都是适应人脸的哦~</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="安装-face-mask"><a href="#安装-face-mask" class="headerlink" title="安装 face-mask"></a>安装 <code>face-mask</code></h3><blockquote>
<p>确保 Python 版本在 3.6 及以上</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install face-mask</span><br></pre></td></tr></table></figure>
<h3 id="使用-face-mask"><a href="#使用-face-mask" class="headerlink" title="使用 face-mask"></a>使用 <code>face-mask</code></h3><p>直接指定图片路径即可为图片中的人像戴上口罩，并会生成一个新的图片（额外有 <code>-with-mask</code> 后缀）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">face-mask /path/to/face/picture</span><br></pre></td></tr></table></figure>
<p>通过指定 <code>--show</code> 选项，还可以使用默认图片查看器打开新生成的图片：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">face-mask /path/to/face/picture --show</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>给一个人戴上口罩<br><img src="/2020/01/31/一行命令自动戴上口罩/1.jpg"></p>
<p>给多个人戴上口罩<br><img src="/2020/01/31/一行命令自动戴上口罩/2.jpg"></p>
<p>给动漫人物戴上口罩<br><img src="/2020/01/31/一行命令自动戴上口罩/3.jpg"></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>要想实现上面的效果，我们应该怎么做？不妨这么想：</p>
<ul>
<li>首先是识别出人的鼻子(nose_bridge)和脸轮廓(chin)</li>
<li>通过脸轮廓确定出脸左点（chin_left_point）、脸底点（chin_bottom_point）和脸右点（chin_right_point）</li>
<li>由鼻子和脸底点确定口罩大小的高度、中心线</li>
<li>将口罩左右平均分为两个部分<ul>
<li>调整左口罩大小，宽度为脸左点到中心线的距离</li>
<li>调整右口罩大小，宽度为脸右点到中心线的距离</li>
<li>合并左右口罩为新口罩</li>
</ul>
</li>
<li>旋转新口罩，角度为中心线相对于 y 轴的旋转角</li>
<li>将新口罩放在原图适当位置</li>
</ul>
<p>关于<strong>人脸识别</strong>，可以使用 <a href="https://github.com/ageitgey/face_recognition" title="face_recognition" target="_blank" rel="noopener">face_recognition</a> 库进行识别。</p>
<p>关于<strong>图像处理</strong>，可以使用 <a href="https://pillow.readthedocs.io/" title="Pillow" target="_blank" rel="noopener">Pillow</a> 库进行处理。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>有了思路之后，实现就是件相对轻松的事情。不过对库的熟悉和图片的变换计算可能要花些时间。</p>
<p>详细的代码请阅读 <a href="https://github.com/Prodesire/face-mask" title="face-mask" target="_blank" rel="noopener">face-mask</a>。这里仅说明下最核心的步骤。</p>
<h4 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> face_recognition</span><br><span class="line"></span><br><span class="line">face_image_np = face_recognition.load_image_file(<span class="string">'/path/to/face/picture'</span>)</span><br><span class="line">face_landmarks = face_recognition.face_landmarks(face_image_np)</span><br></pre></td></tr></table></figure>
<p>借助 <code>face_recognition</code> 库可以轻松的识别出人像，最终得到的 <code>face_landmarks</code> 是一个列表，里面的每个 <code>face_landmark</code> 都表示一个人像数据。</p>
<p><code>face_landmark</code> 是一个字典，其中的键表示人像特征，值表示该特征的点的列表。比如：</p>
<ul>
<li>键 <code>nose_bridge</code> 表示鼻梁</li>
<li>键 <code>chin</code> 表示脸颊</li>
</ul>
<p>我们需要根据每个 <code>face_landmark</code>，给对应的头像戴上口罩。</p>
<h4 id="获得鼻子和脸颊的特征点"><a href="#获得鼻子和脸颊的特征点" class="headerlink" title="获得鼻子和脸颊的特征点"></a>获得鼻子和脸颊的特征点</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">nose_bridge = face_landmark[<span class="string">'nose_bridge'</span>]</span><br><span class="line">nose_point = nose_bridge[len(nose_bridge) * <span class="number">1</span> // <span class="number">4</span>]</span><br><span class="line">nose_v = np.array(nose_point)</span><br><span class="line"></span><br><span class="line">chin = face_landmark[<span class="string">'chin'</span>]</span><br><span class="line">chin_len = len(chin)</span><br><span class="line">chin_bottom_point = chin[chin_len // <span class="number">2</span>]</span><br><span class="line">chin_bottom_v = np.array(chin_bottom_point)</span><br><span class="line">chin_left_point = chin[chin_len // <span class="number">8</span>]</span><br><span class="line">chin_right_point = chin[chin_len * <span class="number">7</span> // <span class="number">8</span>]</span><br></pre></td></tr></table></figure>
<p>通过上述代码，我们获得了：</p>
<ul>
<li>表示上鼻梁的一个点 <code>nose_point</code></li>
<li>表示脸左点 <code>chin_left_point</code></li>
<li>表示脸右点 <code>chin_right_point</code></li>
<li>表示脸底点 <code>chin_bottom_point</code></li>
</ul>
<h4 id="拆分、缩放和合并口罩"><a href="#拆分、缩放和合并口罩" class="headerlink" title="拆分、缩放和合并口罩"></a>拆分、缩放和合并口罩</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">_face_img = Image.fromarray(face_image_np)</span><br><span class="line">_mask_img = Image.open(<span class="string">'/path/to/mask/picture'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># split mask and resize</span></span><br><span class="line">width = _mask_img.width</span><br><span class="line">height = _mask_img.height</span><br><span class="line">width_ratio = <span class="number">1.2</span></span><br><span class="line">new_height = int(np.linalg.norm(nose_v - chin_bottom_v))</span><br><span class="line"></span><br><span class="line"><span class="comment"># left</span></span><br><span class="line">mask_left_img = _mask_img.crop((<span class="number">0</span>, <span class="number">0</span>, width // <span class="number">2</span>, height))</span><br><span class="line">mask_left_width = get_distance_from_point_to_line(chin_left_point, nose_point, chin_bottom_point)</span><br><span class="line">mask_left_width = int(mask_left_width * width_ratio)</span><br><span class="line">mask_left_img = mask_left_img.resize((mask_left_width, new_height))</span><br><span class="line"></span><br><span class="line"><span class="comment"># right</span></span><br><span class="line">mask_right_img = _mask_img.crop((width // <span class="number">2</span>, <span class="number">0</span>, width, height))</span><br><span class="line">mask_right_width = get_distance_from_point_to_line(chin_right_point, nose_point, chin_bottom_point)</span><br><span class="line">mask_right_width = int(mask_right_width * width_ratio)</span><br><span class="line">mask_right_img = mask_right_img.resize((mask_right_width, new_height))</span><br><span class="line"></span><br><span class="line"><span class="comment"># merge mask</span></span><br><span class="line">size = (mask_left_img.width + mask_right_img.width, new_height)</span><br><span class="line">mask_img = Image.new(<span class="string">'RGBA'</span>, size)</span><br><span class="line">mask_img.paste(mask_left_img, (<span class="number">0</span>, <span class="number">0</span>), mask_left_img)</span><br><span class="line">mask_img.paste(mask_right_img, (mask_left_img.width, <span class="number">0</span>), mask_right_img)</span><br></pre></td></tr></table></figure>
<p>上述代码主要做了如下内容：</p>
<ul>
<li>将口罩左右平均分为两个部分</li>
<li>调整左口罩大小，宽度为脸左点到中心线的距离 * 宽度系数 1.2</li>
<li>调整右口罩大小，宽度为脸右点到中心线的距离 * 宽度系数 1.2</li>
<li>合并左右口罩为新口罩</li>
</ul>
<p><code>get_distance_from_point_to_line</code> 用来获取一个点到一条线的距离，具体实现可看源代码。</p>
<p><code>width_ratio</code> 是宽度系数，用来适当扩大口罩。原因我们是根据脸颊的宽度计算口罩的宽度，但口罩是待在耳朵上的，真实宽度应该要更宽。</p>
<h4 id="旋转口罩、并放到原图适当位置"><a href="#旋转口罩、并放到原图适当位置" class="headerlink" title="旋转口罩、并放到原图适当位置"></a>旋转口罩、并放到原图适当位置</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rotate mask</span></span><br><span class="line">angle = np.arctan2(chin_bottom_point[<span class="number">1</span>] - nose_point[<span class="number">1</span>], chin_bottom_point[<span class="number">0</span>] - nose_point[<span class="number">0</span>])</span><br><span class="line">rotated_mask_img = mask_img.rotate(angle, expand=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># calculate mask location</span></span><br><span class="line">center_x = (nose_point[<span class="number">0</span>] + chin_bottom_point[<span class="number">0</span>]) // <span class="number">2</span></span><br><span class="line">center_y = (nose_point[<span class="number">1</span>] + chin_bottom_point[<span class="number">1</span>]) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">offset = mask_img.width // <span class="number">2</span> - mask_left_img.width</span><br><span class="line">radian = angle * np.pi / <span class="number">180</span></span><br><span class="line">box_x = center_x + int(offset * np.cos(radian)) - rotated_mask_img.width // <span class="number">2</span></span><br><span class="line">box_y = center_y + int(offset * np.sin(radian)) - rotated_mask_img.height // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add mask</span></span><br><span class="line">_face_img.paste(mask_img, (box_x, box_y), mask_img)</span><br></pre></td></tr></table></figure>
<p>上述代码主要做了如下内容：</p>
<ul>
<li>旋转新口罩，角度为中心线相对于 y 轴的旋转角</li>
<li>计算口罩应该放置的坐标</li>
<li>将新口罩放在原图的计算出的坐标下</li>
</ul>
<p>最后就是将新图片保存到本地路径，代码不再展示。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们借助 <code>face_recognition</code> 库可以轻松的识别出人像，然后根据脸颊的宽度和鼻梁位置计算出口罩的大小、方向和位置，并最终生成出戴上口罩的图片。整个过程并不复杂，但在坐标计算上要格外小心，如此，我们便打造了一个短小精悍的“自动戴上口罩”程序！</p>
]]></content>
  </entry>
  <entry>
    <title>一文掌握 Python 中的 &quot;is&quot; 和 &quot;==&quot;</title>
    <url>/2020/01/29/%E4%B8%80%E6%96%87%E6%8E%8C%E6%8F%A1-Python-%E4%B8%AD%E7%9A%84-is-%E5%92%8C-==/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Python 的 “is” 和 “==” 想必大家都不陌生，我们在比较变量和字面量时常常用到它们，可是它们的区别在哪里？什么情况下该用 <code>is</code>？什么情况下该用 <code>==</code>？这成了不少人心中的困惑。</p>
<p>当我们判断一个变量是否为 <code>None</code> 时，通常会用 <code>is</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="keyword">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> <span class="keyword">None</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> <span class="keyword">None</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>而当我们判断一个变量是否为字面量（比如某个数值）时，通常会用 <code>==</code>:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == <span class="number">0</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == <span class="number">1</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>要想解决上面的疑惑，我们首先需要搞明白 <code>is</code> 和 <code>==</code> 是什么。</p>
<a id="more"></a>
<h2 id="“is”-和-“-”-是什么"><a href="#“is”-和-“-”-是什么" class="headerlink" title="“is” 和 “==” 是什么"></a>“is” 和 “==” 是什么</h2><p><code>is</code> 用来检查身份（identity）的同一性，即两个变量是否指向同一个对象。</p>
<p><code>==</code> 用来检查值的相等性（equality），即两个变量的值是否相等。</p>
<p>身份的同一性同时也意味值的相等性，既然两个都指向同一个对象，那值就肯定相等。但是反之则不是。</p>
<h3 id="eq-魔法方法"><a href="#eq-魔法方法" class="headerlink" title="__eq__ 魔法方法"></a>__eq__ 魔法方法</h3><p>既然 <code>==</code> 是用来检查值的相等性，那么两个对象的值比较究竟是怎么进行的？</p>
<p>对于基本类型的对象的值比较，我们很容易理解。比如列表对象 [1, 2, 3] 的值比较就是比较列表的长度和列表中每个元素的值。</p>
<p>但是对于自定义的对象，该如何进行值比较？这里就涉及到了 <code>__eq__(self, other)</code> 魔法方法，我们可以通过该方法来实现对象的 <code>==</code> 逻辑。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">... </span>  <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo == <span class="number">1</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo == <span class="keyword">None</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>foo <span class="keyword">is</span> <span class="keyword">None</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们定义了 <code>Foo</code> 类，并实现了 <code>__eq__(self, other)</code> 方法，它永远返回 <code>True</code>，也就意味着和任何对象做值比较（<code>==</code>）结果都是 <code>True</code>。而当它做同一性比较时，比如和 <code>None</code> 比较，由于不是同一个对象，所以返回 <code>False</code>。</p>
<h2 id="场景示例"><a href="#场景示例" class="headerlink" title="场景示例"></a>场景示例</h2><h3 id="示例一：指向同一个对象的变量比较"><a href="#示例一：指向同一个对象的变量比较" class="headerlink" title="示例一：指向同一个对象的变量比较"></a>示例一：指向同一个对象的变量比较</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a  <span class="comment"># b 指向 a，a 指向 [1, 2, 3]，所以 b 指向同一个 [1, 2, 3]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b == a</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中 <code>a</code> 和 <code>b</code> 均指向同一个列表对象 <code>[1, 2, 3]</code>，所以对它们使用 <code>is</code> 和 <code>==</code>，结果都是 <code>True</code>。</p>
<h3 id="示例二：指向不同对象（但值相同）的变量比较"><a href="#示例二：指向不同对象（但值相同）的变量比较" class="headerlink" title="示例二：指向不同对象（但值相同）的变量比较"></a>示例二：指向不同对象（但值相同）的变量比较</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a[:]  <span class="comment"># b 复制了一份 a 所指向的列表，产生新的 [1, 2, 3]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b == a</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<p>在上述示例中，由于 <code>b</code> 指向的是 <code>a</code> 的副本，也就是说 <code>a</code> 和 <code>b</code> 指向两个不同的对象，所以对它们使用 <code>is</code> 的结果是 <code>False</code>。但由于值相等，使用 <code>==</code> 的结果就是 <code>True</code>。</p>
<h3 id="示例三：指向字面量的变量比较"><a href="#示例三：指向字面量的变量比较" class="headerlink" title="示例三：指向字面量的变量比较"></a>示例三：指向字面量的变量比较</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">256</span>  <span class="comment"># 和 a 指向同一字面量 256</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b  <span class="comment"># 表明指向同一对象</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">257</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b  <span class="comment"># 表明指向不同对象</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>通常来说，两个变量指向字面量，它们的比较应该使用 <code>==</code>，而非 <code>is</code>，否则就可能有类似上述示例中的困惑。</p>
<p>在 Python 的交互解释器中，把可能频繁使用的整数对象规定在范围 <code>[-5, 256]</code> 之间，当它们创建好后就会被缓存下来。但凡是需要再用到它们时，就会从缓存中取，而不是重新创建对象。</p>
<ul>
<li>当 <code>a</code> 和 <code>b</code> 都指向同一个字面量 <code>256</code> 时，<code>a is b</code> 返回 <code>True</code>。这是因为声明 <code>b = 256</code> 时，<code>256</code> 整数对象是从缓存中取的，而非重新创建，所以 <code>a</code> 和 <code>b</code> 指向同一个整数对象。</li>
<li>当 <code>a</code> 和 <code>b</code> 都指向同一个字面量 <code>257</code> 时，<code>a is b</code> 返回 <code>False</code>。这是因为声明 <code>b = 257</code> 时，<code>257</code> 整数对象没被缓存，是重新创建的，所以 <code>a</code> 和 <code>b</code> 指向不同的整数对象。</li>
</ul>
<p>同理，如果字面量是字符串，结果也类似。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'python.org'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">'python.org'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">'pythonorg'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">'pythonorg'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a == b</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h2 id="Python-3-8-引入-is-比较字面量时报-SyntaxWarning"><a href="#Python-3-8-引入-is-比较字面量时报-SyntaxWarning" class="headerlink" title="Python 3.8 引入 is 比较字面量时报 SyntaxWarning"></a>Python 3.8 引入 <code>is</code> 比较字面量时报 SyntaxWarning</h2><p>鉴于使用 <code>is</code> 比较字面量其实是不正确的，在 Python 3.8 的 <a href="https://docs.python.org/3.8/whatsnew/3.8.html#changes-in-python-behavior" title="Python 3.8 release notes" target="_blank" rel="noopener">release notes</a> 中，引入如下内容：</p>
<blockquote>
<p>The compiler now produces a SyntaxWarning when identity checks (is and is not) are used with certain types of literals (e.g. strings, numbers). These can often work by accident in CPython, but are not guaranteed by the language spec. The warning advises users to use equality tests (== and !=) instead. (Contributed by Serhiy Storchaka in <a href="https://bugs.python.org/issue34850" title="bpo-34850" target="_blank" rel="noopener">bpo-34850</a>.)</p>
</blockquote>
<p>因此，当我们使用 <code>is</code> 去比较数字、字符串等字面量时，就会报 <code>SyntaxWarning</code>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">200</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x <span class="keyword">is</span> <span class="number">200</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">SyntaxWarning: "is" with a literal. Did you mean "=="?</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>说了这么多，其实我们只需要记住如下两点：</p>
<ul>
<li>当要比较值是否相等时，请用 <code>==</code>。</li>
<li>当要比较是否是同一个对象时，请用 <code>is</code>。</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 壹周刊 008</title>
    <url>/2020/01/26/Python-%E5%A3%B9%E5%91%A8%E5%88%8A-008/</url>
    <content><![CDATA[<h2 id="新鲜事儿"><a href="#新鲜事儿" class="headerlink" title="新鲜事儿"></a>新鲜事儿</h2><p>本周没有新鲜事儿。</p>
<h2 id="好文共赏"><a href="#好文共赏" class="headerlink" title="好文共赏"></a>好文共赏</h2><p><a href="https://dev.to/educative/software-developer-trends-of-2020-and-beyond-5fj6" target="_blank" rel="noopener">2020 年后的软件开发人员趋势</a></p>
<p><a href="https://medium.com/better-programming/python-progress-bars-with-tqdm-by-example-ce98dbbc9697" target="_blank" rel="noopener">Python 进度条 tqdm 示例</a></p>
<p>进度条是程序开发中一个不可获取的功能，网上关于 Python 进度条库 tqdm 的示例说的并不友好，本文将深入浅出地带你如何使用 tqdm 实现进度条功能。</p>
<p><a href="https://adamj.eu/tech/2020/01/21/why-does-python-3-8-syntaxwarning-for-is-literal/" target="_blank" rel="noopener">为什么 Python 3.8 给 “is” 打印 SyntaxWarning？</a></p>
<a id="more"></a>
<p><a href="https://arxiv.org/pdf/2001.02491.pdf" target="_blank" rel="noopener">对比 Python、Go 和 C++ 的 N 皇后问题</a></p>
<p>Python 当前是机器学习领域的主导语言，但经常因执行某些任务的速度慢而受到批评。在本文中，我们使用著名的 N 皇后难题作为基准，来说明一旦使用 Numba 编译器进行编译，它就可以在执行速度上与 C 和 Go 竞争，同时还可以非常快速地制作原型。</p>
<p><a href="https://medium.com/kolonial-no-product-tech/codemodding-python-unittest-asserts-to-python-asserts-dbf4d1da8c0" target="_blank" rel="noopener">使用 codemod 将 unittest 断言转换为 Python 断言</a></p>
<p>大型代码库需要持续维护，但是更改分布在多个文件中的代码既费时又麻烦。本文展示了如何通过 codemod 借助抽象语法树来重构 Python 代码——相比于基本的正则和搜索替换，控制粒度要更细。</p>
<p><a href="https://realpython.com/arcade-python-game-framework/" target="_blank" rel="noopener">Python 游戏框架指南</a></p>
<p>在本循序渐进的教程中，您将学习如何使用 arcade，一种现代的 Python 框架，制作具有引人入胜的图形和声音的游戏。 Arcade 是针对 Python 3.6 及更高版本而构建的面向对象的库，为您提供了一套现代的工具，可提供出色的 Python 游戏体验。</p>
<p><a href="https://nkanaev.github.io/posts/polyglot/" target="_blank" rel="noopener">编写多语言脚本</a></p>
<p>Python 和 Ruby 的语法有些相似，您能否想出一个在两种语言中均有效的程序？</p>
<p><a href="https://pbpython.com/effective-matplotlib.html" target="_blank" rel="noopener">高效使用 MatPlotlib</a></p>
<p>我已经花了一些时间来学习 Python 可视化的一些工具以及如何将其与 matplotlib 一起使用，我开始将 matplotlib 视为必不可少的工具。 这篇文章将展示我如何使用 matplotlib 并为用户入门提供一些建议。</p>
<p><a href="https://realpython.com/python-scipy-cluster-optimize/" target="_blank" rel="noopener">科学计算 Python：使用 SciPy 进行优化</a></p>
<p>了解 SciPy 生态系统及与 SciPy 库的区别。您将学习如何使用 Anaconda 或 pip 安装 SciPy，并查看其一些模块。 然后您将重点关注使用 SciPy 中的群集和优化功能的示例。</p>
<p><a href="http://hondu.co/blog/open-and-python" target="_blank" rel="noopener">open() 和 CPython 的意外结果</a></p>
<p>滥用 Python 的 open()， 以及 CPython 的 GC 和 UNIX 语言的互相作用，可能会导致意外结果。</p>
<p><a href="https://www.b-list.org/weblog/2020/jan/20/fun/" target="_blank" rel="noopener">找点 Python 的乐子</a></p>
<p>编写混乱的代码，除了可以获得乐趣，也是绝佳的学习体验。</p>
<p><a href="https://sourcery.ai/blog/five-refactoring-tips/" target="_blank" rel="noopener">改善代码的 5 个重构建议</a></p>
<p><a href="https://blog.ionelmc.ro/2020/01/20/is-there-anything-safe-in-python/" target="_blank" rel="noopener">编写安全的 repr()</a></p>
<h2 id="赞视频"><a href="#赞视频" class="headerlink" title="赞视频"></a>赞视频</h2><p><a href="https://realpython.com/courses/python-data-types/" target="_blank" rel="noopener">Python 中的基本数据类型</a></p>
<p>在本课程中，您将学习 Python 内置的基本数据类型，例如数字、字符串和布尔值，以及 Python 内置函数的概览。</p>
<h2 id="酷开源"><a href="#酷开源" class="headerlink" title="酷开源"></a>酷开源</h2><p><a href="https://pypistats.org/" target="_blank" rel="noopener">pypistats</a></p>
<p>PyPI 下载统计。</p>
<p><a href="https://github.com/getsentry/sentry" target="_blank" rel="noopener">Sentry</a></p>
<p>实时日志记录和聚合服务端。</p>
<p><a href="https://github.com/celery/celery" target="_blank" rel="noopener">celery</a></p>
<p>基于分布式消息的异步任务队列。</p>
<p><a href="https://github.com/saltstack/salt" target="_blank" rel="noopener">SaltStack</a></p>
<p>基础设施自动化和管理系统。</p>
<p><a href="https://github.com/paramiko/paramiko" target="_blank" rel="noopener">Paramiko</a></p>
<p>SSHv2 协议的 Python (2.6+, 3.3+) 实现，同时提供客户端和服务端功能。</p>
<p><a href="https://github.com/grantjenks/python-diskcache" target="_blank" rel="noopener">DiskCache</a></p>
<p>使用 SQLite 和文件作为后端缓存，比 memcached 和 redis 的查询都要快。</p>
<p><a href="https://github.com/tmux-python/tmuxp" target="_blank" rel="noopener">tmuxp</a></p>
<p>💻 基于 libtmux 的 tmux 会话管理器。</p>
<p><a href="https://github.com/fsistemas/sql2json" target="_blank" rel="noopener">sql2json</a></p>
<p>运行查询并将结果转换为 json 的 Python 工具。</p>
<p><a href="https://github.com/ionelmc/python-hunter/" target="_blank" rel="noopener">python-hunter</a></p>
<p>一个灵活的代码追踪工具。</p>
<p><a href="https://github.com/pschanely/CrossHair" target="_blank" rel="noopener">CrossHair</a></p>
<p>用于 Python 的静态分析工具，模糊了测试系统和类型系统之间的界限。</p>
<p><a href="https://github.com/lucashadfield/speck" target="_blank" rel="noopener">speck</a></p>
<p>将图像渲染为一组连续的（水平或垂直）像素线。</p>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>壹周刊</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>壹周刊</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：使用 fire 实现 git 命令</title>
    <url>/2020/01/12/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9A%E4%BD%BF%E7%94%A8-fire-%E5%AE%9E%E7%8E%B0-git-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在前面三篇介绍 <code>fire</code> 的文章中，我们全面了解了 <code>fire</code> 强大而不失简洁的能力。按照惯例，我们要像使用 <code>argparse</code>、<code>docopt</code> 和 <code>click</code> 一样使用 <code>fire</code> 来实现 git 命令。</p>
<p>本文的关注点并不在 <code>git</code> 的各种命令是如何实现的，而是怎么使用 <code>fire</code> 去打造一个实用命令行程序，代码结构是怎样的。因此，和 <code>git</code> 相关的操作，将会使用 <code>gitpython</code> 库来简单实现。</p>
<p>为了让没读过 <code>使用 xxx 实现 git 命令</code>（<code>xxx</code> 指 <code>argparse</code>、<code>docopt</code> 和 <code>click</code>） 的小伙伴也能读明白本文，我们仍会对 <code>git</code> 常用命令和 <code>gitpython</code> 做一个简单介绍。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<h2 id="二、git-常用命令"><a href="#二、git-常用命令" class="headerlink" title="二、git 常用命令"></a>二、git 常用命令</h2><p>当你写好一段代码或增删一些文件后，会用如下命令查看文件状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>确认文件状态后，会用如下命令将的一个或多个文件（夹）添加到暂存区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add [pathspec [pathspec ...]]</span><br></pre></td></tr></table></figure>
<p>然后使用如下命令提交信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"your commit message"</span></span><br></pre></td></tr></table></figure>
<p>最后使用如下命令将提交推送到远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>我们将使用 <code>fire</code> 和 <code>gitpython</code> 库来实现这 4 个子命令。</p>
<h2 id="三、关于-gitpython"><a href="#三、关于-gitpython" class="headerlink" title="三、关于 gitpython"></a>三、关于 gitpython</h2><p><a href="https://gitpython.readthedocs.io/en/stable/intro.html" target="_blank" rel="noopener">gitpython</a> 是一个和 <code>git</code> 仓库交互的 Python 第三方库。<br>我们将借用它的能力来实现真正的 <code>git</code> 逻辑。</p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install gitpython</span><br></pre></td></tr></table></figure>
<h2 id="四、思考"><a href="#四、思考" class="headerlink" title="四、思考"></a>四、思考</h2><p>在实现前，我们不妨先思考下会用到 <code>fire</code> 的哪些功能？整个程序的结构是怎样的？</p>
<p><strong>fire</strong></p>
<p><code>git</code> 的 4 个子命令的实现其实对应于四个函数，我们可以都放到一个类中，实现四个实例方法。<br>而对于 <code>git add</code> 命令，需要接受任意个参数，在实例方法中用 <code>*pathspecs</code> 参数来表达。<br>对于 <code>git commit</code> 命令，需要接受 <code>-m</code> 选项，在实例方法中用 <code>m</code> 参数来表达。</p>
<p><strong>程序结构</strong></p>
<p>程序结构上：</p>
<ul>
<li>实例化 <code>Git</code> 对象，供全局使用</li>
<li>在 <code>GitCli</code> 类中定义四个命令对应的实例方法 <code>status</code>、<code>add</code>、<code>commit</code>、<code>push</code></li>
</ul>
<p>则基本结构如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"><span class="keyword">from</span> git.cmd <span class="keyword">import</span> Git</span><br><span class="line"></span><br><span class="line">git = Git(os.getcwd())</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitCli</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">status</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        处理 status 命令</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, *pathspecs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        处理 add 命令</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">commit</span><span class="params">(self, m)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        处理 -m &lt;msg&gt; 命令</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        处理 push 命令</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    fire.Fire(GitCli())</span><br></pre></td></tr></table></figure>
<p>下面我们将一步步地实现我们的 <code>git</code> 程序。</p>
<h2 id="五、实现"><a href="#五、实现" class="headerlink" title="五、实现"></a>五、实现</h2><p>假定我们在 <a href="https://github.com/HelloGitHub-Team/Article/blob/master/contents/Python/cmdline/fire-git.py" target="_blank" rel="noopener">fire-git.py</a> 文件中实现我们的 <code>git</code> 程序。</p>
<h3 id="5-1-status-子命令"><a href="#5-1-status-子命令" class="headerlink" title="5.1 status 子命令"></a>5.1 status 子命令</h3><p><code>status</code> 子命令不接受任何参数和选项，因此 <code>status</code> 方法无需任何入参。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitCli</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">status</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        处理 status 命令</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cmd = [<span class="string">'git'</span>, <span class="string">'status'</span>]</span><br><span class="line">        output = git.execute(cmd)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<p>不难看出，我们最后调用了真正的 <code>git status</code> 来实现，并打印了输出。</p>
<h3 id="5-2-add-子命令"><a href="#5-2-add-子命令" class="headerlink" title="5.2 add 子命令"></a>5.2 add 子命令</h3><p><code>add</code> 子命令相对于 <code>status</code> 子命令，需要接受任意个 pathspec 参数，因此 <code>add</code> 方法需要增加 <code>*pathspecs</code> 入参。<br>fire 最终传入的是一个元组，我们需要将其转换成 list 以便后续处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitCli</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, *pathspecs)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        处理 add 命令</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cmd = [<span class="string">'git'</span>, <span class="string">'add'</span>] + list(pathspecs)</span><br><span class="line">        output = git.execute(cmd)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<p>当我们执行 <code>python3 fire-git.py add --help</code> 时，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO: Showing help with the command &apos;fire-git.py add -- --help&apos;.</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">    fire-git.py add - 处理 add 命令</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">    fire-git.py add [PATHSPECS]...</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">    处理 add 命令</span><br><span class="line"></span><br><span class="line">POSITIONAL ARGUMENTS</span><br><span class="line">    PATHSPECS</span><br></pre></td></tr></table></figure>
<h3 id="5-3-commit-子命令"><a href="#5-3-commit-子命令" class="headerlink" title="5.3 commit 子命令"></a>5.3 commit 子命令</h3><p><code>commit</code> 子命令相对于 <code>status</code> 子命令，需要接受 <code>-m</code> 选项，因此 <code>commit</code> 方法需要增加 <code>m</code> 入参。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitCli</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">commit</span><span class="params">(self, m)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        处理 -m &lt;msg&gt; 命令</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cmd = [<span class="string">'git'</span>, <span class="string">'commit'</span>, <span class="string">'-m'</span>, m]</span><br><span class="line">        output = git.execute(cmd)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<h3 id="5-4-push-子命令"><a href="#5-4-push-子命令" class="headerlink" title="5.4 push 子命令"></a>5.4 push 子命令</h3><p><code>push</code> 子命令同 <code>status</code> 子命令一样，不接受任何参数和选项，因此 <code>push</code> 方法无需任何入参。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GitCli</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        处理 push 命令</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        cmd = [<span class="string">'git'</span>, <span class="string">'push'</span>]</span><br><span class="line">        output = git.execute(cmd)</span><br><span class="line">        <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>
<p>至此，我们就实现了一个简单的 <code>git</code> 命令行，使用 <code>python fire-git.py status</code> 便可查询项目状态。</p>
<p>非常方便的是，每个命令函数的 <code>docstring</code> 都将作为这个命令的帮助信息，因此，当我们执行 <code>python3 fire-git.py --help</code> 会自动生成如下帮助内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO: Showing help with the command &apos;fire-git.py -- --help&apos;.</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">    fire-git.py</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">    fire-git.py COMMAND</span><br><span class="line"></span><br><span class="line">COMMANDS</span><br><span class="line">    COMMAND is one of the following:</span><br><span class="line"></span><br><span class="line">     add</span><br><span class="line">       处理 add 命令</span><br><span class="line"></span><br><span class="line">     commit</span><br><span class="line">       处理 -m &lt;msg&gt; 命令</span><br><span class="line"></span><br><span class="line">     push</span><br><span class="line">       处理 push 命令</span><br><span class="line"></span><br><span class="line">     status</span><br><span class="line">       处理 status 命令</span><br></pre></td></tr></table></figure>
<p>想看整个源码，请戳 <a href="https://github.com/HelloGitHub-Team/Article/blob/master/contents/Python/cmdline/fire-git.py" target="_blank" rel="noopener">fire-git.py</a> 。</p>
<h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><p>本文简单介绍了日常工作中常用的 <code>git</code> 命令，然后提出实现它的思路，最终一步步地使用 <code>fire</code> 和 <code>gitpython</code> 实现了 <code>git</code> 程序。</p>
<p>对比 <code>argparse</code>、<code>docopt</code> 和 <code>click</code> 的实现版本，你会发现使用 <code>fire</code> 来实现是最简单的：</p>
<ul>
<li>相较于 <code>argparse</code>，子解析器、参数类型什么的统统不需要关心</li>
<li>相较于 <code>docopt</code>，参数解析和命令调用处理也不需要关心</li>
<li>相较于 <code>click</code>，装饰器所定义的命令行参数信息也必须要关心</li>
</ul>
<p>无疑，<code>fire</code> 把能简化的都简化了，简直就是懒人福音。</p>
<p>关于 <code>fire</code> 的讲解将告一段落，回顾下 <code>fire</code> 的至简之道，你会深爱上它。这也体现出了 Python 之美。</p>
<p>现在，你已学会了四个特点各异的主流命令行解析库的使用了，再也不需要为命令行程序的实现而烦恼了。</p>
<p>什么，你为要使用哪一个库而发愁？在下一篇也是最后一篇文章中，我们将对这些库做一个横向对比，以对什么场景下使用什么样的命令行库了然于胸~</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>fire</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 壹周刊 007</title>
    <url>/2020/01/08/Python-%E5%A3%B9%E5%91%A8%E5%88%8A-007/</url>
    <content><![CDATA[<h2 id="新鲜事儿"><a href="#新鲜事儿" class="headerlink" title="新鲜事儿"></a>新鲜事儿</h2><p><a href="https://pythonclock.org/?2020" target="_blank" rel="noopener">Python 2 已退休</a></p>
<p><a href="https://www.python.org/dev/peps/pep-8101/" target="_blank" rel="noopener">老爹 Guido van Rossum 退出 Python 指导委员会</a></p>
<a id="more"></a>
<h2 id="好文共赏"><a href="#好文共赏" class="headerlink" title="好文共赏"></a>好文共赏</h2><p><a href="https://kunigami.blog/2019/12/26/python-type-hints/" target="_blank" rel="noopener">Python 类型注解</a></p>
<p>本文将全面介绍 mypy，通过许多示例演示了这种类型检查器的语法和功能。</p>
<p><a href="http://www.flake8rules.com/" target="_blank" rel="noopener">Flask8 规则</a></p>
<p>Flake8 中的所有规则的说明和示例。</p>
<p><a href="https://blog.nicco.io/2020/01/01/rust-in-python-made-easy" target="_blank" rel="noopener">在 Python 中使用 Rust 变得简单</a></p>
<p>对于需要性能提升的计算密集型任务，可以由 Rust 来实现逻辑，然后在 Python 中调用。本文将介绍如何实现这个过程。</p>
<p><a href="https://nicholasfarrow.com/Creating-a-Moon-Animation-Using-NASA-Images-and-Python/" target="_blank" rel="noopener">借助 NASA 图片和 Python 制作月亮视频</a></p>
<p>手把手教你如果通过 Python 和数张 NASA 的月亮图片制作月亮视频。</p>
<p><a href="https://martinheinz.dev/blog/13" target="_blank" rel="noopener">让 Python 程序闪电般迅速</a></p>
<p>讨厌 Python 的人总是说，他们不想使用它的原因之一是它很慢。 嗯，特定的程序（无论使用何种编程语言）是快还是慢，很大程度上取决于编写该程序的开发人员以及编写优化的快速的程序的技能和能力。 因此，让我们证明一些人是错误的，让我们看看如何改善 Python 程序的性能并使它们真正更快！</p>
<p><a href="https://iximiuz.com/en/posts/flask-gevent-tutorial/" target="_blank" rel="noopener">如何将 Flask 与 gevent 一起使用（uWSGI 和 Gunicorn 版本）</a></p>
<p>创建异步 Flask 应用程序，并在 Nginx 反向代理后面使用 uWSGI 或 Gunicorn 来运行它。</p>
<p><a href="https://medium.com/@wolfv/robot-development-with-jupyter-ddae16d4e688" target="_blank" rel="noopener">使用 Jupyter 开发机器人</a></p>
<p>这篇文章展示了 Jupyter 生态系统中可用的工具，在 Jupyter Notebooks 中构建高级可视化并使用 Voilá 转换为独立的 Web 应用程序，以及如何将这些应用程序部署到机器人云中。</p>
<p><a href="https://lucumr.pocoo.org/2020/1/1/async-pressure/" target="_blank" rel="noopener">我没有感受到 async 的压力</a></p>
<p>如今异步风靡一时，异步 Python、异步 Rust、Go、Node、.NET，选择您喜欢的生态系统，它有些异步操作。这种异步操作的工作原理在很大程度上取决于语言的生态系统和运行时，但总体而言，它具有一些不错的好处。这使事情变得非常简单：异步等待（await）可能需要一些时间才能完成的操作。它是如此简单，以至于创造了无数新的方法来“打击”人。我要讨论的是在系统超载之前您还没有意识到自己可能采坑的情况，也就是背压管理。在协议设计中，的一个相关术语叫做流量控制。</p>
<p><a href="https://orbifold.xyz/zen-of-python.html" target="_blank" rel="noopener">Python 之禅的思考</a></p>
<p><a href="https://realpython.com/python-timer/" target="_blank" rel="noopener">Python 计时器功能：监视代码的三种方法</a></p>
<p>了解如何使用 Python 计时器功能来监视程序的运行速度。您将使用类、上下文管理器和装饰器来测量程序的运行时间。 您将了解每种方法的优点以及在特定情况下可以使用的方法。</p>
<p><a href="https://lucumr.pocoo.org/2019/12/28/open-source-migrates/" target="_blank" rel="noopener">开源迁移的困扰</a></p>
<p>Flask 的创建者介绍了 Python 2 到 3 的迁移以及 Python 社区如何处理过渡。有趣的内容！</p>
<h2 id="赞视频"><a href="#赞视频" class="headerlink" title="赞视频"></a>赞视频</h2><p><a href="https://www.youtube.com/watch?v=7kn7NtlV6g0" target="_blank" rel="noopener">Python 老爹在牛津联盟的访谈</a></p>
<p><a href="https://www.youtube.com/watch?v=x58W9A2lnQc" target="_blank" rel="noopener">Numba 让 Python 快上 1000 倍!</a></p>
<p>在此视频中，我介绍了您需要了解的有关 Numba 的最低要求，Numba 是针对 Python 和 Numpy 子集的即时编译器。 该视频的前半部分做了基本介绍，并着重介绍了人们在使用 Numba 时常犯的一些错误。后半部分提出了一个现实世界中的模拟问题，在单线程和多线程情况下，使用 Numba 最多可加速 1000 倍。最后给出一个“阅读清单”作为结尾，以了解有关 Numba 的更多信息。</p>
<h2 id="酷开源"><a href="#酷开源" class="headerlink" title="酷开源"></a>酷开源</h2><p><a href="https://github.com/mirumee/saleor" target="_blank" rel="noopener">Saleor</a></p>
<p>使用 Python、GraphQL、Django 和 ReactJS 构建的模块化、高性能的电子商务网站。</p>
<p><a href="https://github.com/coleifer/peewee" target="_blank" rel="noopener">Peewee</a></p>
<p>一个小巧、富有表现力的 ORM —— 支持 PostgreSQL、MySQL 和 SQLite。</p>
<p><a href="https://github.com/python-poetry/poetry" target="_blank" rel="noopener">Poetry</a></p>
<p>让 Python 的依赖项管理和打包变得容易。</p>
<p><a href="https://github.com/sobolevn/django-split-settings" target="_blank" rel="noopener">django-split-settings</a></p>
<p>将 Django 设置分散到多个文件和目录中，能够轻松覆盖和修改设置。</p>
<p><a href="https://github.com/python-gino/gino" target="_blank" rel="noopener">GINO</a></p>
<p>GINO 递归定义为 GINO Is Not ORM，是一个基于 asyncio 和 SQLAlchemy core 的轻量级异步 Python ORM 框架，目前（2020 年初）仅支持 asyncpg 一种引擎。</p>
<p><a href="https://github.com/qutip/qutip" target="_blank" rel="noopener">QuTiP</a></p>
<p>Python 中的量子工具箱。</p>
<p><a href="https://github.com/obspy/obspy" target="_blank" rel="noopener">ObsPy</a></p>
<p>用于处理地震数据的 Python 框架。</p>
<p><a href="https://github.com/kornia/kornia" target="_blank" rel="noopener">Kornia</a></p>
<p>PyTorch 的开源可区分计算机视觉库。</p>
<p><a href="https://github.com/tiangolo/typer" target="_blank" rel="noopener">Typer</a></p>
<p>基于 Python 类型注解的 CLI 库，能够简单地创建 CLI 程序。</p>
<p><a href="https://github.com/knowsuchagency/klaxon" target="_blank" rel="noopener">klaxon</a></p>
<p>从终端或 Python 程序中发送 Mac OS 通知。</p>
<p><a href="https://github.com/kkroening/ffmpeg-python" target="_blank" rel="noopener">ffmpeg-python</a></p>
<p>FFmpeg 的 Python 绑定，支持复杂的过滤</p>
<p><a href="https://github.com/anmspro/Traffic-Signal-Violation-Detection-System" target="_blank" rel="noopener">Traffic-Signal-Violation-Detection-System</a></p>
<p>使用 YOLOv3 和 Tkinter 实现的基于计算机视觉的交通信号违规检测系统。</p>
<p><a href="https://github.com/PydPiper/pylightxl" target="_blank" rel="noopener">pylightxl</a></p>
<p>轻量级、零依赖、最简功能的 excel 读/写 Python 库。</p>
<p><a href="https://github.com/haroonawanofficial/XSS-Finder" target="_blank" rel="noopener">XSS Finder</a></p>
<p>大型、高级的跨站点脚本扫描程序。</p>
<p><a href="https://github.com/warner/magic-wormhole" target="_blank" rel="noopener">Magic Wormhole</a></p>
<p>安全地将内容从一台计算机转移到另一台计算机上。</p>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>壹周刊</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>壹周刊</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：深入 fire（二）</title>
    <url>/2020/01/05/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9A%E6%B7%B1%E5%85%A5-fire%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在上一篇文章中我们介绍了 <code>fire</code> 的子命令、嵌套命令和属性访问等内容，今天我们将继续深入了解 <code>fire</code> 的其他功能。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<h2 id="二、功能"><a href="#二、功能" class="headerlink" title="二、功能"></a>二、功能</h2><h3 id="2-1-最简命令实现"><a href="#2-1-最简命令实现" class="headerlink" title="2.1 最简命令实现"></a>2.1 最简命令实现</h3><p>在上一节中，我们介绍了只要定义一个函数就可以实现命令行程序。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">english</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hello, fire!'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chinese</span><span class="params">()</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'你好，fire！'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  fire.Fire()</span><br></pre></td></tr></table></figure>
<p>但这还不是最简单的实现方式，<code>fire</code> 甚至允许你通过定义变量的方式来实现命令行！<br>上面的例子可以写成下面这种形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"></span><br><span class="line">english = <span class="string">'Hello, fire!'</span></span><br><span class="line">chinese = <span class="string">'你好，fire！'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  fire.Fire()</span><br></pre></td></tr></table></figure>
<h3 id="2-2-链式调用"><a href="#2-2-链式调用" class="headerlink" title="2.2 链式调用"></a>2.2 链式调用</h3><p>在 <code>Fire CLI</code> 中，你可以通过链式调用不断地对上一个结果进行处理。</p>
<p>想做到这一点也很简单，就是在实例方法中返回 <code>self</code> 即可。</p>
<p>在下面的示例中，我们实现了一个简单的四则运算命令，可链式调用 <code>add</code>、<code>sub</code>、<code>mul</code> 和 <code>div</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.result = <span class="number">0</span></span><br><span class="line">    self.express = <span class="string">'0'</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'<span class="subst">&#123;self.express&#125;</span> = <span class="subst">&#123;self.result&#125;</span>'</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    self.result += x</span><br><span class="line">    self.express = <span class="string">f'<span class="subst">&#123;self.express&#125;</span>+<span class="subst">&#123;x&#125;</span>'</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    self.result -= x</span><br><span class="line">    self.express = <span class="string">f'<span class="subst">&#123;self.express&#125;</span>-<span class="subst">&#123;x&#125;</span>'</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">mul</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    self.result *= x</span><br><span class="line">    self.express = <span class="string">f'(<span class="subst">&#123;self.express&#125;</span>)*<span class="subst">&#123;x&#125;</span>'</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">div</span><span class="params">(self, x)</span>:</span></span><br><span class="line">    self.result /= x</span><br><span class="line">    self.express = <span class="string">f'(<span class="subst">&#123;self.express&#125;</span>)/<span class="subst">&#123;x&#125;</span>'</span></span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  fire.Fire(Calculator)</span><br></pre></td></tr></table></figure>
<p>上述代码中的 <code>add</code>、<code>sub</code>、<code>mul</code>、<code>div</code> 分别对应加、减、乘、除的逻辑，每个方法都接受 <code>x</code> 参数作为参与运算的数字，返回值均为 <code>self</code>，这样就可以无限次地链式调用。在命令行中链式调用结束后，会最终调用到 <code>__str__</code> 方法将结果打印出来。</p>
<p>其中，<code>__str__</code> 在 <code>fire</code> 中用来完成自定义序列化。如果不提供这个方法，在链式调用完成后将会打印帮助内容。</p>
<p>比如，我们可以这么调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python calculator.py add 1 sub 2 mul 3 div 4</span><br><span class="line">((+1-2)*3)/4 = -0.75</span><br><span class="line"></span><br><span class="line">$ python calculator.py add 1 sub 2 mul 3 div 4 add 4 sub 3 mul 2 div 1</span><br><span class="line">((((0+1-2)*3)/4+4-3)*2)/1 = 0.5</span><br></pre></td></tr></table></figure>
<h3 id="2-3-位置参数和选项参数"><a href="#2-3-位置参数和选项参数" class="headerlink" title="2.3 位置参数和选项参数"></a>2.3 位置参数和选项参数</h3><p>通过前面的介绍我们也都清楚了在 <code>fire</code> 中不必显式的定义位置参数或选项参数。</p>
<p>通过下面的例子，我们将细化两类参数的使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, stories=<span class="number">1</span>)</span>:</span></span><br><span class="line">    self.name = name</span><br><span class="line">    self.stories = stories</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'name: <span class="subst">&#123;self.name&#125;</span>, stories: <span class="subst">&#123;self.stories&#125;</span>'</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">climb_stairs</span><span class="params">(self, stairs_per_story=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> self.name</span><br><span class="line">    <span class="keyword">for</span> story <span class="keyword">in</span> range(self.stories):</span><br><span class="line">      <span class="keyword">for</span> stair <span class="keyword">in</span> range(<span class="number">1</span>, stairs_per_story):</span><br><span class="line">        <span class="keyword">yield</span> stair</span><br><span class="line">      <span class="keyword">yield</span> <span class="string">'Phew!'</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'Done!'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  fire.Fire(Building)</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数中定义的参数（如 <code>name</code> 和 <code>stories</code>）在命令行中仅为选项参数（如 <code>--name</code> 和 <code>--stories</code>）。我们可以这么调用：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python example.py --name=<span class="string">"Sherrerd Hall"</span> --stories=3</span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数中定义的参数可在命令中放于任意位置。比如下面两个调用都是可以的：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python example.py --name=<span class="string">"Sherrerd Hall"</span> climb-stairs --stairs-per-story 10</span><br><span class="line">$ python example.py climb-stairs --stairs-per-story 10 --name=<span class="string">"Sherrerd Hall"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>构造函数和普通方法中定义的默认参数（如 <code>stories</code>），在命令行中是可选的。我们可以这么调用：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python example.py --name=<span class="string">"Sherrerd Hall"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>普通方法中定义的参数（如 <code>stairs_per_story</code>）在命令行中即可以是位置参数，也可以是选项参数。我们可以这么调用：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 作为位置参数</span></span><br><span class="line">$ python example.py --name=<span class="string">"Sherrerd Hall"</span> climb_stairs 10</span><br><span class="line"><span class="comment"># 作为选项参数</span></span><br><span class="line">$ python example.py --name=<span class="string">"Sherrerd Hall"</span> climb_stairs --stairs_per_story=10</span><br></pre></td></tr></table></figure>
<ul>
<li>选项参数中的横杠（<code>-</code>）和下划线（<code>_</code>）是等价的。因此也可以这么调用：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 作为选项参数</span></span><br><span class="line">$ python example.py --name=<span class="string">"Sherrerd Hall"</span> climb_stairs --stairs-per-story=10</span><br></pre></td></tr></table></figure>
<p>此外，<code>fire</code> 还支持在函数中定义 <code>*args</code> 和 <code>**kwargs</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fargs</span><span class="params">(*args)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> str(args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fkwargs</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> str(kwargs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  fire.Fire()</span><br></pre></td></tr></table></figure>
<ul>
<li>函数中的 <code>*args</code> 在命令行中为位置参数。我们可以这么调用：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python example.py fargs a b c</span><br></pre></td></tr></table></figure>
<ul>
<li>函数中的 <code>**kwargs</code> 在命令行中为选项参数。我们可以这么调用：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python example.py fargs --a a1 --b b1 --c c1</span><br></pre></td></tr></table></figure>
<ul>
<li>通过分隔符 <code>-</code> 可显式告知分隔符后的为子命令，而非命令的参数。且看下面的示例：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 没有使用分隔符，upper 被作为位置参数</span></span><br><span class="line">$ python example.py fargs a b c upper</span><br><span class="line">(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'upper'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用了分隔符，upper 被作为子命令</span></span><br><span class="line">$ python example.py fargs a b c - upper</span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 <code>fire</code> 内置的 <code>--separator</code> 可以自定义分隔符，此选项参数需要跟在单独的 <code>--</code> 后面：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python example.py a b c X upper -- --separator=X</span><br><span class="line">(<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="2-4-参数类型"><a href="#2-4-参数类型" class="headerlink" title="2.4 参数类型"></a>2.4 参数类型</h3><p>在 <code>fire</code> 中，参数的类型由其值决定，通过下面的简单代码，我们可以看到给不同的值时，<code>fire</code>会解析为什么类型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fire</span><br><span class="line">fire.Fire(<span class="keyword">lambda</span> obj: type(obj).__name__)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python example.py 10</span><br><span class="line">int</span><br><span class="line">$ python example.py 10.0</span><br><span class="line"><span class="built_in">float</span></span><br><span class="line">$ python example.py hello</span><br><span class="line">str</span><br><span class="line">$ python example.py <span class="string">'(1,2)'</span></span><br><span class="line">tuple</span><br><span class="line">$ python example.py [1,2]</span><br><span class="line">list</span><br><span class="line">$ python example.py True</span><br><span class="line">bool</span><br><span class="line">$ python example.py &#123;name: David&#125;</span><br><span class="line">dict</span><br></pre></td></tr></table></figure>
<p>如果想传递字符串形式的数字，那就需要小心引号了，要么把引号引起来，要么转义引号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数字 10</span></span><br><span class="line">$ python example.py 10</span><br><span class="line">int</span><br><span class="line"><span class="comment"># 没有对引号处理，仍然是数字10</span></span><br><span class="line">$ python example.py <span class="string">"10"</span></span><br><span class="line">int</span><br><span class="line"><span class="comment"># 把引号引起来，所以是字符串“10”</span></span><br><span class="line">$ python example.py <span class="string">'"10"'</span></span><br><span class="line">str</span><br><span class="line"><span class="comment"># 另一种把引号引起来的形式</span></span><br><span class="line">$ python example.py <span class="string">"'10'"</span></span><br><span class="line">str</span><br><span class="line"><span class="comment"># 转义引号</span></span><br><span class="line">$ python example.py \<span class="string">"10\"</span></span><br><span class="line"><span class="string">str</span></span><br></pre></td></tr></table></figure>
<p>考虑下更复杂的场景，如果传递的是字典，在字典中有字符串，那么也是要小心引号的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐做法</span></span><br><span class="line">$ python example.py <span class="string">'&#123;"name": "David Bieber"&#125;'</span></span><br><span class="line">dict</span><br><span class="line"><span class="comment"># 也是可以的</span></span><br><span class="line">$ python example.py &#123;<span class="string">"name"</span>:<span class="string">'"David Bieber"'</span>&#125;</span><br><span class="line">dict</span><br><span class="line"><span class="comment"># 错误，会被解析为字符串</span></span><br><span class="line">$ python example.py &#123;<span class="string">"name"</span>:<span class="string">"David Bieber"</span>&#125;</span><br><span class="line">str</span><br><span class="line"><span class="comment"># 错误，不会作为单个参数（因为中间有空格），报错</span></span><br><span class="line">$ python example.py &#123;<span class="string">"name"</span>: <span class="string">"David Bieber"</span>&#125;</span><br><span class="line">&lt;error&gt;</span><br></pre></td></tr></table></figure>
<p>如果值为 <code>True</code> 或 <code>False</code> 将为视为布尔值，<code>fire</code> 还支持通过 <code>--name</code> 将 <code>name</code> 设为 <code>True</code>，或通过 <code>--noname</code> 将 <code>name</code> 设为 <code>False</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python example.py --obj=True</span><br><span class="line">bool</span><br><span class="line">$ python example.py --obj=False</span><br><span class="line">bool</span><br><span class="line">$ python example.py --obj</span><br><span class="line">bool</span><br><span class="line">$ python example.py --noobj</span><br><span class="line">bool</span><br></pre></td></tr></table></figure>
<h3 id="2-5-Fire-内置选项参数"><a href="#2-5-Fire-内置选项参数" class="headerlink" title="2.5 Fire 内置选项参数"></a>2.5 Fire 内置选项参数</h3><p>Fire 内置了一些选项参数，以帮助我们更容易地使用命令行程序。若想使用内置的选项功能，需要将选项参数跟在 <code>--</code> 后，在上文中，我们介绍了 <code>--separator</code> 参数，除了它，<code>fire</code> 还支持以下选项参数：</p>
<ul>
<li><code>command -- --help</code> 列出详细的帮助信息</li>
<li><code>command -- --interactive</code> 进入交互式模式</li>
<li><code>command -- --completion [shell]</code> 生成 CLI 程序的自动补全脚本，以支持自动补全</li>
<li><code>command -- --trace</code> 获取命令的 Fire 追踪以了解调用 Fire 后究竟发生了什么</li>
<li><code>command -- --verbose</code> 获取包含私有成员在内的详情</li>
</ul>
<h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p><code>fire</code> 让命令行程序的实现变得特别简单，本文着重介绍了它的链式调用、选项参数、位置参数、参数类型以及内置选项参数。<code>fire</code> 的概念并不多，真正践行了“把简单留给他人，把复杂留给自己”的理念。</p>
<p><code>fire</code> 的介绍就告一段落，它绝对会是你编写命令行程序的一大利器。在下一篇文章中，我们依然会通过实现一个简单的 <code>git</code> 程序来进行 <code>fire</code> 的实战。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>fire</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 壹周刊 006</title>
    <url>/2019/12/31/Python-%E5%A3%B9%E5%91%A8%E5%88%8A-006/</url>
    <content><![CDATA[<h2 id="新鲜事儿"><a href="#新鲜事儿" class="headerlink" title="新鲜事儿"></a>新鲜事儿</h2><p>本周没有新鲜事儿~</p>
<h2 id="好文共赏"><a href="#好文共赏" class="headerlink" title="好文共赏"></a>好文共赏</h2><p><a href="https://florimond.dev/blog/articles/2019/08/introduction-to-asgi-async-python-web/" target="_blank" rel="noopener">ASGI 简介：异步 Python Web 生态系统的出现</a></p>
<p>如果您认为 Python 已陷入数据科学领域，请再考虑一遍！有了 async 特性，Python Web 开发又回来了，这很令人兴奋。</p>
<a id="more"></a>
<p><a href="https://tryexceptpass.org/article/distributing-python-applications/" target="_blank" rel="noopener">2020 年发布 Python 应用程序的 12 种趋势替代方案</a></p>
<p>2019 年 Python 生态中最流行的主题之一是打包和分发。 随着一年的结束，我想总结一下我们目前可用于分发 Python 应用程序的方式，其中一些也适用于任何语言。</p>
<p><a href="https://realpython.com/numpy-scipy-pandas-correlation-python/" target="_blank" rel="noopener">通过 NumPy、SciPy 和 Pandas 玩转相关性</a></p>
<p>了解什么是相关性以及如何使用 Python 计算相关性。本文将介绍使用 SciPy、NumPy 和 Pandas 相关方法来计算三个不同的相关系数，还会介绍如何使用 Matplotlib 可视化数据、回归线和相关矩阵。</p>
<p><a href="https://gawron.sdsu.edu/compling/course_core/python_intro/intro_lecture_files/fastpython.html" target="_blank" rel="noopener">Python 性能技巧</a></p>
<p>各类提升 Python 程序性能的技巧。</p>
<p><a href="https://blog.miguelgrinberg.com/post/how-to-make-python-wait" target="_blank" rel="noopener">如何让 Python 等待</a></p>
<p>对于许多类型的应用程序，有时需要暂停程序的运行，直到发生某些外部情况为止。 我们需要找出一种让脚本等待的方法，这要想正确地做起来并不像听起来那样简单！在本文中，我将向您展示几种不同的等待方式。 我将在所有示例中使用 Python，这个概念也适用于所有编程语言。</p>
<p><a href="https://orbifold.xyz/pyhamcrest.html" target="_blank" rel="noopener">使用 PyHamcrest 进行精确的单元测试</a></p>
<p>Hamcrest 是一个 Python 框架，旨在使测试断言更易于编写和更加精确。</p>
<p><a href="https://chrisyeh96.github.io/2017/08/08/definitive-guide-python-imports.html" target="_blank" rel="noopener">Python import 语句权威指南</a></p>
<p>如何在 Python 2 和 3 中解决常见的导入问题。</p>
<p><a href="https://sausheong.github.io/posts/pi4-dev-ipadpro/" target="_blank" rel="noopener">将 Raspberry Pi 4 设置为 iPad Pro 的开发机器</a></p>
<p><a href="https://www.pluralsight.com/tech-blog/porting-flask-to-fastapi-for-ml-model-serving/" target="_blank" rel="noopener">为了 ML 模型服务，将 Flask 移植到 FastAPI</a></p>
<p>Flask 因其简单性而是一个非常流行的 Web 框架，用于在 Python 中构建 REST API，尤其是服务于机器学习模型。 在本文中，我们将学习如何迁移到更新的 FastAPI 框架，以利用类型检查和异步编程的优势。</p>
<p><a href="https://hatem-hassan.com/blog/fullstack-nlp-building-and-deploying-end-to-end-fake-news-classifier" target="_blank" rel="noopener">全栈 NLP：构建和部署端到端虚假新闻分类器</a></p>
<p>这是一个有关构建 NLP 文本分类 Web 应用程序并将其部署到生产环境的教程。</p>
<p><a href="https://towardsdatascience.com/the-video-search-engine-my-journey-into-computer-vision-9789824e76bb" target="_blank" rel="noopener">视频搜索引擎—我的计算机视觉之旅</a></p>
<p>制作视频很容易，但是谁会有时间观看所有视频？我想出一个视频搜索引擎，用来查找想要的瞬间，并提供了原型。</p>
<p><a href="https://dev.to/billm/how-does-a-simple-web-server-work-2mb5" target="_blank" rel="noopener">一个简单的 Web 服务是如何工作的</a></p>
<p><a href="https://dev.to/codemouse92/dead-simple-python-working-with-files-lmg" target="_blank" rel="noopener">非常简单的 Python：处理文件</a></p>
<p>关于文件处理，基本用法和坑都在这里。</p>
<h2 id="赞视频"><a href="#赞视频" class="headerlink" title="赞视频"></a>赞视频</h2><p><a href="https://realpython.com/courses/python-dictionary-iteration/" target="_blank" rel="noopener">Python 字典迭代：高级技巧</a></p>
<p>字典是 Python 中最重要和有用的数据结构，能帮助解决各类问题。本课程将带你深入了解如何迭代字典。</p>
<p><a href="https://www.youtube.com/watch?v=lbbNoCFSBV4" target="_blank" rel="noopener">使用 Python 在终端中绘制动画圣诞树</a></p>
<p>做了一个圣诞节特别的编程项目 —— 制作在终端上运行的动画圣诞树。 有时编程可能很有趣，就比如这个。</p>
<h2 id="酷开源"><a href="#酷开源" class="headerlink" title="酷开源"></a>酷开源</h2><p><a href="https://github.com/microsoft/nlp-recipes" target="_blank" rel="noopener">nlp-recipes</a></p>
<p>自然语言处理的最佳实践和示例。</p>
<p><a href="https://github.com/mardix/assembly" target="_blank" rel="noopener">assembly</a></p>
<p>基于 Flask 的 Pythonic OOP Web 框架。</p>
<p><a href="https://github.com/onelivesleft/PrettyErrors/" target="_blank" rel="noopener">PrettyErrors</a></p>
<p>让 Python 的异常输出变得更优雅。</p>
<p><a href="https://github.com/seandstewart/typical" target="_blank" rel="noopener">typical</a></p>
<p>快速、简单、正确的利用 Python 3 类型注解的数据校验库。</p>
<p><a href="https://github.com/wkentaro/labelme" target="_blank" rel="noopener">labelme</a></p>
<p>Python 的图像多边形注释（多边形、矩形、圆形、直线、点和图像级标记注释）。</p>
<p><a href="https://github.com/bridgecrewio/checkov" target="_blank" rel="noopener">Checkov</a></p>
<p>Checkov 是用于基础结构即代码的静态代码分析工具。它扫描使用 Terraform 设置的云基础架构，检测安全性和合规性错误配置。</p>
<p><a href="https://github.com/skamieniarz/newspie" target="_blank" rel="noopener">NewsPie</a></p>
<p>一个由 Flask 构建并由 News API 支持的简约新闻聚合器。</p>
<p><a href="https://github.com/joelibaceta/pix-to-xls" target="_blank" rel="noopener">pix-to-xls</a></p>
<p>一个可以将图像转换为 excel 彩色单元格的简单工具。</p>
<p><a href="https://github.com/s0md3v/Silver" target="_blank" rel="noopener">Silver</a></p>
<p>masscan 速度很快、nmap 可以提取软件指纹、而 vulners 是一个巨大的漏洞数据库。Silver 是一个允许完整使用这些程序能力的前端，它可以通过解析数据、生成并行进程、缓存漏洞数据来进行更快的扫描，且不止于此。</p>
<p><a href="https://github.com/marshmallow-code/apispec" target="_blank" rel="noopener">apispec</a></p>
<p>可插拔的 API 规范生成器，目前支持 OpenAPI 规范（又称 Swagger 规范）。</p>
<p><a href="https://github.com/pvcraven/arcade" target="_blank" rel="noopener">arcade</a></p>
<p>易于使用的用于创建 2D 街机游戏的 Python 库。</p>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>壹周刊</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>壹周刊</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：深入 fire（一）</title>
    <url>/2019/12/29/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9A%E6%B7%B1%E5%85%A5-fire%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在第一篇“初探 fire”的文章中，我们初步掌握了使用 <code>fire</code> 的简单步骤，了解了它 Pythonic 的用法。</p>
<p>今天我们将深入了解 <code>fire</code> 的子命令、嵌套命令和属性访问功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="二、功能"><a href="#二、功能" class="headerlink" title="二、功能"></a>二、功能</h2><h3 id="2-1-子命令"><a href="#2-1-子命令" class="headerlink" title="2.1 子命令"></a>2.1 子命令</h3><p>使用 <code>fire</code> 实现子命令有多种方式：</p>
<h4 id="2-1-1-定义若干函数，使用-fire-Fire"><a href="#2-1-1-定义若干函数，使用-fire-Fire" class="headerlink" title="2.1.1 定义若干函数，使用 fire.Fire()"></a>2.1.1 定义若干函数，使用 fire.Fire()</h4><p>实现子命令最简单的方式就是定义若干个函数，每个函数名隐式就是子命令名称，然后调用 <code>fire.Fire()</code> 变将当前模块所有的函数解析为对应的子命令的处理函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(x, y)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  fire.Fire()</span><br></pre></td></tr></table></figure>
<p>然后我们就可以在命令行中这么调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python example.py add 10 20</span><br><span class="line">30</span><br><span class="line">$ python example.py multiply 10 20</span><br><span class="line">200</span><br></pre></td></tr></table></figure>
<p>关于如何识别参数类型，比如上述 <code>add 10 20</code> 中 <code>10</code> 和 <code>20</code> 是作为数字而非字符串，我们会在下篇文章的参数解析章节中进行讲解。</p>
<h4 id="2-1-2-定义若干函数，使用-fire-Fire"><a href="#2-1-2-定义若干函数，使用-fire-Fire" class="headerlink" title="2.1.2 定义若干函数，使用 fire.Fire()"></a>2.1.2 定义若干函数，使用 fire.Fire(<dict>)</dict></h4><p>在 <code>2.1.1</code> 的版本中，会把所有函数都当做是子命令。有时我们可能只想把部分函数当做子命令，或者是希望子命令名称和函数名称不一样。这个时候我们就可以通过字典对象显式地告诉 <code>fire</code>。</p>
<p>字典对象的形式为 <code>{&#39;子命令名称&#39;: 函数}</code>，比如前面的示例中，我们希望最终的子命令为 <code>add</code> 和 <code>mul</code>，那么就可以这么写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fire.Fire(&#123;</span><br><span class="line">  <span class="string">'add'</span>: add,</span><br><span class="line">  <span class="string">'mul'</span>: multiply,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后我们就可以在命令行中这么调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python example.py add 10 20</span><br><span class="line">30</span><br><span class="line">$ python example.py mul 10 20</span><br><span class="line">200</span><br></pre></td></tr></table></figure>
<h4 id="2-1-3-定义类和方法，使用-fire-Fire"><a href="#2-1-3-定义类和方法，使用-fire-Fire" class="headerlink" title="2.1.3 定义类和方法，使用 fire.Fire()"></a>2.1.3 定义类和方法，使用 fire.Fire(<object>)</object></h4><p>定义类和方法的这种方式我们在上一篇文章中介绍过，它和定义函数的方式基本相同，只不过是用类的方式来组织。</p>
<p>然后将类实例化，并把实例化的对象多为 <code>fire.Fire</code> 的入参：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  calculator = Calculator()</span><br><span class="line">  fire.Fire(calculator)</span><br></pre></td></tr></table></figure>
<h4 id="2-1-4-定义类和方法，使用-fire-Fire"><a href="#2-1-4-定义类和方法，使用-fire-Fire" class="headerlink" title="2.1.4 定义类和方法，使用 fire.Fire()"></a>2.1.4 定义类和方法，使用 fire.Fire(<class>)</class></h4><p>和 <code>2.1.3</code> 中的唯一不同点是把类而非实例对象作为 <code>fire.Fire</code> 的入参：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fire.Fire(Calculator)</span><br></pre></td></tr></table></figure>
<p>传递类和实例对象的基本作用是一样的，但传递类还有一个额外的特性：如果构造函数中定义了参数，那么这些参数都会作为整个命令行程序的选项参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrokenCalculator</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, offset=<span class="number">1</span>)</span>:</span></span><br><span class="line">      self._offset = offset</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y + self._offset</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * y + self._offset</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  fire.Fire(BrokenCalculator)</span><br></pre></td></tr></table></figure>
<p>查看帮助命令有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python example.py --<span class="built_in">help</span></span><br><span class="line">INFO: Showing <span class="built_in">help</span> with the <span class="built_in">command</span> <span class="string">'example.py -- --help'</span>.</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">    example.py</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">    example.py &lt;flags&gt;</span><br><span class="line"></span><br><span class="line">FLAGS</span><br><span class="line">    --offset=OFFSET</span><br></pre></td></tr></table></figure>
<p>由此可见构造函数 <code>BrokenCalculator.__init__(self, offset=1)</code> 中的 <code>offset</code> 自动转换为了命令行中的全局选项参数 <code>--offset</code>，且默认值为 <code>1</code>。</p>
<p>我们可以在命令行中这么调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python example.py add 10 20</span><br><span class="line">31</span><br><span class="line">$ python example.py multiply 10 20</span><br><span class="line">201</span><br><span class="line">$ python example.py add 10 20 --offset=0</span><br><span class="line">30</span><br><span class="line">$ python example.py multiply 10 20 --offset=0</span><br><span class="line">200</span><br></pre></td></tr></table></figure>
<h3 id="2-2-命令组-嵌套命令"><a href="#2-2-命令组-嵌套命令" class="headerlink" title="2.2 命令组/嵌套命令"></a>2.2 命令组/嵌套命令</h3><p>想要实现嵌套命令，可将多个类组织起来，示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IngestionStage</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Ingesting! Nom nom nom...'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DigestionStage</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, volume=<span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">' '</span>.join([<span class="string">'Burp!'</span>] * volume)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">status</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Satiated.'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pipeline</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.ingestion = IngestionStage()</span><br><span class="line">    self.digestion = DigestionStage()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.ingestion.run()</span><br><span class="line">    self.digestion.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  fire.Fire(Pipeline)</span><br></pre></td></tr></table></figure>
<p>在上面的示例中：</p>
<ul>
<li><code>IngestionStage</code> 实现了子命令 <code>run</code></li>
<li><code>DigestionStage</code> 实现了子命令 <code>run</code> 和 <code>status</code></li>
<li><code>Pipeline</code> 的构造函数中将 <code>IngestionStage</code> 实例化为 <code>ingestion</code>，将 <code>DigestionStage</code> 实例化为 <code>digestion</code>，就将这两个放到一个命令组中，因而支持了：<ul>
<li><code>ingestion run</code></li>
<li><code>digestion run</code></li>
<li><code>digestion status</code></li>
</ul>
</li>
<li><code>Pipeline</code> 实现了子命令 <code>run</code></li>
</ul>
<p>因此整个命令行程序支持如下命令：</p>
<ul>
<li><code>run</code></li>
<li><code>ingestion run</code></li>
<li><code>digestion run</code></li>
<li><code>digestion status</code></li>
</ul>
<p>然后我们就可以在命令行中这么调用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python example.py run</span><br><span class="line">Ingesting! Nom nom nom...</span><br><span class="line">Burp!</span><br><span class="line">$ python example.py ingestion run</span><br><span class="line">Ingesting! Nom nom nom...</span><br><span class="line">$ python example.py digestion run</span><br><span class="line">Burp!</span><br><span class="line">$ python example.py digestion status</span><br><span class="line">Satiated.</span><br></pre></td></tr></table></figure>
<h3 id="2-3-属性访问"><a href="#2-3-属性访问" class="headerlink" title="2.3 属性访问"></a>2.3 属性访问</h3><p><code>属性访问</code> 是 <code>fire</code> 相对于其他命令行库来说一个比较独特的功能。所谓访问属性是获取预置的属性所对应的值。</p>
<p>举个例子，在命令行中指定 <code>--code</code> 来告知程序要查询的程序编码，然后希望通过 <code>zipcode</code> 属性返回邮编，通过 <code>city</code> 属性返回城市名。那么属性可实现为实例成员属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"></span><br><span class="line">cities = &#123;</span><br><span class="line">  <span class="string">'hz'</span>: (<span class="number">310000</span>, <span class="string">'杭州'</span>),</span><br><span class="line">  <span class="string">'bj'</span>: (<span class="number">100000</span>, <span class="string">'北京'</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">City</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, code)</span>:</span></span><br><span class="line">    info = cities.get(code)</span><br><span class="line">    self.zipcode = info[<span class="number">0</span>] <span class="keyword">if</span> info <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line">    self.city = info[<span class="number">1</span>] <span class="keyword">if</span> info <span class="keyword">else</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  fire.Fire(City)</span><br></pre></td></tr></table></figure>
<p>使用方式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python example.py --code bj zipcode</span><br><span class="line">100000</span><br><span class="line">$ python example.py --code hz city</span><br><span class="line">杭州</span><br></pre></td></tr></table></figure>
<h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>使用 <code>fire</code> 实现子命令和嵌套命令相对于其他命令行库来说都更加简单清晰，不仅如此，<code>fire</code> 还提供了属性访问这种较为独特的能力。</p>
<p>在下篇文章中，我们将进一步深入了解 <code>fire</code>，介绍其链式函数调用、自定义序列化、参数解析、fire 选项等更加高阶的功能。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>fire</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：初探 fire</title>
    <url>/2019/12/22/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9A%E5%88%9D%E6%8E%A2-fire/</url>
    <content><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>在本系列前面所有文章中，我们分别介绍了 <code>argparse</code>、<code>docopt</code> 和 <code>click</code> 的主要功能和用法。它们各具特色，都能出色地完成命令行任务。<code>argparse</code> 是面向过程的，需要先设置解析器，再定义参数，再解析命令行，最后实现业务逻辑。<code>docopt</code> 先用声明式的语法定义出参数，再过程式地解析命令行和实现业务逻辑。<code>click</code> 则是用装饰器的方式进一步简化显式的命令调用逻辑，但仍然不够面向对象。</p>
<p>而今天要介绍的 <a href="https://github.com/google/python-fire" target="_blank" rel="noopener">fire</a> 则是用一种面向广义对象的方式来玩转命令行，这种对象可以是类、函数、字典、列表等，它更加灵活，也更加简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="二、介绍"><a href="#二、介绍" class="headerlink" title="二、介绍"></a>二、介绍</h2><p><a href="https://github.com/google/python-fire" target="_blank" rel="noopener">fire</a> 可以根据任何 Python 对象自动生成命令行接口。它有如下特性：</p>
<ul>
<li>能以简单的方式生成 CLI</li>
<li>是一个开发和调试 Python 代码的实用工具</li>
<li>能将现存代码或别人的代码转换为 CLI</li>
<li>使得在 Bash 和 Python 间的转换变得更容易</li>
<li>通过预先为 REPL 设置所需的模块和变量，使得实用 REPL 更加容易</li>
</ul>
<p>通过如下命令可快速安装 <code>fire</code> 库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install fire</span><br></pre></td></tr></table></figure>
<h2 id="三、快速开始"><a href="#三、快速开始" class="headerlink" title="三、快速开始"></a>三、快速开始</h2><p>回忆下使用 <code>argparse</code>、<code>docopt</code> 和 <code>click</code> 实现命令行程序的步骤：</p>
<ul>
<li>对于 <code>argparse</code> 来说，要先设置解析器，再定义参数，再解析命令行，最后实现业务逻辑</li>
<li>对于 <code>docopt</code> 来说，要先定义定义接口描述，再解析命令行，最后实现业务逻辑</li>
<li>对于 <code>click</code> 来说，就是实现业务逻辑和通过装饰器的方式定义参数</li>
</ul>
<p>它们的实现步骤越来越简单，从四步简化到了两步。而今天的主角 <code>fire</code> 则是跟进一步，只需实现业务逻辑就够了。</p>
<p>这简直简单的不可思议，为什么这样做就够了？我们不妨考虑下 Python 中的函数，函数是不是可以对应一个命令行程序，而函数的参数可以对应命令行程序的参数和选项呢？再看看 Python 中的类，一个类是不是可以对应一个命令行程序，而类中的每个实例方法就可以对应子命令，实例方法中的参数就是对应子命令的参数和选项。</p>
<p>这么一想，理论上确实是可以实现的，我们不妨通过下面的示例来看看 <code>fire</code> 是如何让我们通过简单的方式实现命令行程序。</p>
<h3 id="3-1-使用函数"><a href="#3-1-使用函数" class="headerlink" title="3.1 使用函数"></a>3.1 使用函数</h3><p>来看这么一个例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name=<span class="string">"World"</span>)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'Hello &#123;name&#125;!'</span>.format(name=name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  fire.Fire(hello)</span><br></pre></td></tr></table></figure>
<p>在上述例子中定义一个 <code>hello</code> 函数，它接受 <code>name</code> 参数，并且有默认值 “World”。使用 <code>fire.Fire(hello)</code> 即可非常简单快速地实现命令功能，这个命令行就接受 <code>--name</code> 选项，不提供时使用默认值 “World”，提供时就按提供的值来。</p>
<p>可在命令行中执行下列命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python hello.py</span><br><span class="line">Hello World!</span><br><span class="line">$ python hello.py --name=Prodesire</span><br><span class="line">Hello Prodesire!</span><br><span class="line">$ python hello.py --<span class="built_in">help</span></span><br><span class="line">INFO: Showing <span class="built_in">help</span> with the <span class="built_in">command</span> <span class="string">'hello.py -- --help'</span>.</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">    hello.py</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">    hello.py &lt;flags&gt;</span><br><span class="line"></span><br><span class="line">FLAGS</span><br><span class="line">    --name=NAME</span><br></pre></td></tr></table></figure>
<h3 id="3-2-使用类"><a href="#3-2-使用类" class="headerlink" title="3.2 使用类"></a>3.2 使用类</h3><p>使用函数是最简单的方式，如果我们想以更有组织的方式来实现，比如使用类，<code>fire</code> 也是支持的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fire</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="string">"""A simple calculator class."""</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(self, number)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * number</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">triple</span><span class="params">(self, number)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">3</span> * number</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">  fire.Fire(Calculator)</span><br></pre></td></tr></table></figure>
<p>在上述例子中定义一个 <code>Calculator</code> 类，它有两个实例方法 <code>double</code> 和 <code>triple</code>，并且都接受 <code>number</code> 参数，没有默认值。使用 <code>fire.Fire(Calculator)</code> 即可非常简单快速地实现命令功能，这个命令行支持两个子命令 <code>double</code> 和 <code>triple</code>，位置参数 <code>NUMBER</code> 或选项参数 <code>--number</code></p>
<p>可在命令行中执行下列命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python calculator.py double 10</span><br><span class="line">20</span><br><span class="line">$ python calculator.py triple --number=15</span><br><span class="line">45</span><br><span class="line">$ python calculator.py double --<span class="built_in">help</span></span><br><span class="line">INFO: Showing <span class="built_in">help</span> with the <span class="built_in">command</span> <span class="string">'calculator.py double -- --help'</span>.</span><br><span class="line"></span><br><span class="line">NAME</span><br><span class="line">    calculator.py double</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">    calculator.py double NUMBER</span><br><span class="line"></span><br><span class="line">POSITIONAL ARGUMENTS</span><br><span class="line">    NUMBER</span><br><span class="line"></span><br><span class="line">NOTES</span><br><span class="line">    You can also use flags syntax <span class="keyword">for</span> POSITIONAL ARGUMENTS</span><br></pre></td></tr></table></figure>
<h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p><code>fire</code> 的使用方式非常简单，定一个 Python 对象，剩下的就交给 <code>fire</code> 来处理，可谓是非常的 Pythonic，这也是它会如此受欢迎的原因。</p>
<p>除了上面展示的内容，<code>fire</code> 还支持更多种类的 Python 对象，也拥有很多强大的功能，我们将在接下来几节中逐步走近它。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>fire</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 壹周刊 005</title>
    <url>/2019/12/18/Python-%E5%A3%B9%E5%91%A8%E5%88%8A-005/</url>
    <content><![CDATA[<h2 id="新鲜事儿"><a href="#新鲜事儿" class="headerlink" title="新鲜事儿"></a>新鲜事儿</h2><p><a href="https://pytorch.org/blog/openmined-and-pytorch-launch-fellowship-funding-for-privacy-preserving-ml/" target="_blank" rel="noopener">OpenMined 和 PyTorch 合作启动为保护隐私的 ML 社区提供研究金</a></p>
<p>PyTorch 团队已投资 25 万美元来支持 OpenMined 进一步发展和扩大隐私保护的 ML。你可以通过三种不同的机会参与该项目的开发。这些奖学金的每一项都进一步促进了我们的共同使命，即降低隐私保护机器学习的进入障碍，并创建一个更具隐私保护的世界。</p>
<a id="more"></a>
<h2 id="好文共赏"><a href="#好文共赏" class="headerlink" title="好文共赏"></a>好文共赏</h2><p><a href="https://dev.to/iammowgoud/fullstack-nlp-building-deploying-end-to-end-fake-news-classifier-56fb" target="_blank" rel="noopener">全栈 NLP：构建和部署端到端的虚假新闻分类器</a></p>
<p>这是一个构建 NLP 文本分类 Web 应用程序的 API + UI，并将其部署到生产环境的教程。</p>
<p><a href="https://martinheinz.dev/blog/1" target="_blank" rel="noopener">你从来没见过的 Python 技巧</a></p>
<p>有很多文章讨论 Python 的许多酷炫功能，例如变量解包、partial 函数、枚举可迭代对象，但 Python 还有很多要讨论的话题，因此在这里我将尝试展示一些我知道和使用但没在其他地方提过的功能。</p>
<p><a href="https://eng.uber.com/pplm/" target="_blank" rel="noopener">使用即插即用语言模型控制文本生成</a></p>
<p>Uber AI 的即插即用语言模型为 NLP 从业人员提供了将简单属性模型插入大型无条件语言模型的灵活性。</p>
<p><a href="https://nanonets.com/blog/ocr-with-tesseract/" target="_blank" rel="noopener">使用 Tesseract、OpenCV 和 Python 进行 OCR 的完整指南</a></p>
<p>有关在 Python 中使用 Tesseract 和 OpenCV 进行 OCR 的入门综合教程：包含预处理、深度学习 OCR、文本提取和限制。</p>
<p><a href="https://www.agiliq.com/blog/2019/11/writing-an-orm-for-redis/" target="_blank" rel="noopener">为 Redis 写一个 Python ORM</a></p>
<p>将实例存到 Redis 的一种优雅的方法。</p>
<p><a href="https://whalesalad.com/blog/doing-python-configuration-right" target="_blank" rel="noopener">正确地进行 Python 配置</a></p>
<p>让我们来讨论下如何配置 Python 应用程序，尤其是可能存在于多种环境中的各类情形——日常开发、预发、生产等。</p>
<h2 id="赞视频"><a href="#赞视频" class="headerlink" title="赞视频"></a>赞视频</h2><p><a href="https://www.youtube.com/watch?v=6ManltU_8iU&amp;feature=youtu.be" target="_blank" rel="noopener">初学者的 Django 3.0 完整教程</a></p>
<p><a href="https://www.youtube.com/watch?v=ek8GF76p5-s&amp;feature=youtu.be" target="_blank" rel="noopener">使用 Python 和 Pandas 处理 Excel 文件</a></p>
<p><a href="https://www.youtube.com/watch?v=dQxQsZ39XMU&amp;feature=youtu.be" target="_blank" rel="noopener">Python Lambda 表达式教程: what, how, when and why</a></p>
<p><a href="https://www.youtube.com/playlist?list=PLaeNpBNgqQWvxnFU4PYGLOJ82IvuePAyT" target="_blank" rel="noopener">North Bay Python 2019</a></p>
<h2 id="酷开源"><a href="#酷开源" class="headerlink" title="酷开源"></a>酷开源</h2><p><a href="https://wonderworks-software.github.io/PyFlow/" target="_blank" rel="noopener">PyFlow</a></p>
<p>Python 的可视化脚本框架</p>
<p><a href="https://github.com/getpelican/pelican" target="_blank" rel="noopener">Pelican</a></p>
<p>使用 Python 开发的，支持 Markdown 和 reST 的静态站点生成器。</p>
<p><a href="https://github.com/beetbox/beets" target="_blank" rel="noopener">beets</a></p>
<p>为音乐极客而生的媒体库管理系统。</p>
<p><a href="https://github.com/AtsushiSakai/PythonRobotics" target="_blank" rel="noopener">PythonRobotics</a></p>
<p>机器人算法的 Python 示例。</p>
<p><a href="https://github.com/ray-project/ray" target="_blank" rel="noopener">Ray</a></p>
<p>一个快速简单的用于构建和运行分布式应用程序的框架。</p>
<p><a href="https://github.com/web2py/pydal" target="_blank" rel="noopener">pyDAL</a></p>
<p>纯 Python 实现的数据库抽象层。</p>
<p><a href="https://github.com/kayak/pypika" target="_blank" rel="noopener">PyPika</a></p>
<p>一个 python SQL 查询构建器， 擅长各种 SQL 查询，尤其对数据分析特别有用。</p>
<p><a href="https://github.com/wemake-services/wemake-python-styleguide" target="_blank" rel="noopener">wemake-python-styleguide</a></p>
<p>有史以来最严格、最固执的 Python 检查器！</p>
<p><a href="https://github.com/AIDungeon/AIDungeon" target="_blank" rel="noopener">AI Dungeon 2</a></p>
<p>AI Dungeon 2 是完全由 AI 生成的文字冒险游戏，它使用 OpenAI 的最大 GPT-2 模型构建，是同类游戏中的第一个。它允许你进入游戏并对你所能想象的任何举动做出反应。</p>
<p><a href="https://github.com/python-mario/mario" target="_blank" rel="noopener">Mario: Shell pipes in Python</a></p>
<p>您是否想过直接在 Unix Shell 中使用 Python 函数？Mario 可以读写 csv、json 和 yaml；遍历树、甚至能执行 xpath 查询。另外，它还支持开箱即用的异步命令。你可以使用用简单的配置文件来构建自己的命令，并安装插件。</p>
<p><a href="https://github.com/M4cs/pixcryption" target="_blank" rel="noopener">Pixcryption</a></p>
<p>Pixcryption 的目标是通过图像提供一种新形式的信息隐匿/加密方式。它使用随机种子的 UUID 生成一个 user_key，该 user_key 与 RGB 完美值匹配以与 unicode 字符匹配。这些文件存储在 user_key.png 文件中，该文件用于加密和解密消息。</p>
<p><a href="https://github.com/thebjorn/pydeps" target="_blank" rel="noopener">pydeps</a></p>
<p>Python 模块依赖可视化。</p>
<p><a href="https://github.com/zh-plus/video-to-pose3D" target="_blank" rel="noopener">Video to Pose3D</a></p>
<p>一键将视频中人体运动转换为 3D 姿势。</p>
<p><a href="https://github.com/mjmikulski/horology" target="_blank" rel="noopener">Horology</a></p>
<p>用于 for 循环、上下文和函数的便捷时间测量库。</p>
<p><a href="https://github.com/pytorch/elastic" target="_blank" rel="noopener">PyTorch Elastic</a></p>
<p>一个能够以容错和弹性的方式执行分布式训练任务的框架。</p>
<p><a href="https://github.com/EmbarkStudios/blender-tools" target="_blank" rel="noopener">blender-tools</a></p>
<p>包含工作流工具，用于游戏开发的 Blender 插件。</p>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>壹周刊</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>壹周刊</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：使用 click 实现 git 命令</title>
    <url>/2019/12/14/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9A%E4%BD%BF%E7%94%A8-click-%E5%AE%9E%E7%8E%B0-git-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面五篇介绍 <code>click</code> 的文章中，我们全面了解了 <code>click</code> 的强大能力。按照惯例，我们要像使用 <code>argparse</code> 和 <code>docopt</code> 一样使用 <code>click</code> 来实现 git 命令。</p>
<p>本文的关注点并不在 <code>git</code> 的各种命令是如何实现的，而是怎么使用 <code>click</code> 去打造一个实用命令行程序，代码结构是怎样的。因此，和 <code>git</code> 相关的操作，将会使用 <code>gitpython</code> 库来简单实现。</p>
<p>为了让没读过 <code>使用 xxx 实现 git 命令</code>（<code>xxx</code> 指 <code>argparse</code> 和 <code>docopt</code>） 的小伙伴也能读明白本文，我们仍会对 <code>git</code> 常用命令和 <code>gitpython</code> 做一个简单介绍。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<h2 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h2><p>当你写好一段代码或增删一些文件后，会用如下命令查看文件状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>确认文件状态后，会用如下命令将的一个或多个文件（夹）添加到暂存区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add [pathspec [pathspec ...]]</span><br></pre></td></tr></table></figure>
<p>然后使用如下命令提交信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"your commit message"</span></span><br></pre></td></tr></table></figure>
<p>最后使用如下命令将提交推送到远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>我们将使用 <code>click</code> 和 <code>gitpython</code> 库来实现这 4 个子命令。</p>
<h2 id="关于-gitpython"><a href="#关于-gitpython" class="headerlink" title="关于 gitpython"></a>关于 gitpython</h2><p><a href="https://gitpython.readthedocs.io/en/stable/intro.html" target="_blank" rel="noopener">gitpython</a> 是一个和 <code>git</code> 仓库交互的 Python 第三方库。<br>我们将借用它的能力来实现真正的 <code>git</code> 逻辑。</p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install gitpython</span><br></pre></td></tr></table></figure>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在实现前，我们不妨先思考下会用到 <code>click</code> 的哪些功能？整个程序的结构是怎样的？</p>
<p><strong>click</strong></p>
<p><code>git</code> 的 4 个子命令的实现其实对应于四个函数，每个函数使用 <code>click</code> 的 <code>command</code> 来装饰。<br>而对于 <code>git add</code> 和 <code>git commit</code>，则分别需要表示参数的 <code>click.argument</code> 和表示选项的 <code>click.option</code> 来装饰。</p>
<p><strong>程序结构</strong></p>
<p>程序结构上：</p>
<ul>
<li>实例化 <code>Git</code> 对象，供全局使用</li>
<li>定义 <code>cli</code> 函数作为命令组，也就是整个命令程序的入口</li>
<li>定义四个命令对应的实现函数 <code>status</code>、<code>add</code>、<code>commit</code>、<code>push</code></li>
</ul>
<p>则基本结构如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> click</span><br><span class="line"><span class="keyword">from</span> git.cmd <span class="keyword">import</span> Git</span><br><span class="line"></span><br><span class="line">git = Git(os.getcwd())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@click.group()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    git 命令行</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@cli.command()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">status</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 status 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@cli.command()</span></span><br><span class="line"><span class="meta">@click.argument('pathspec', nargs=-1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(pathspec)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 add 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@cli.command()</span></span><br><span class="line"><span class="meta">@click.option('-m', 'msg')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">commit</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 -m &lt;msg&gt; 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@cli.command()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 push 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    cli()</span><br></pre></td></tr></table></figure>
<p>下面我们将一步步地实现我们的 <code>git</code> 程序。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>假定我们在 <a href="https://github.com/HelloGitHub-Team/Article/blob/master/contents/Python/cmdline/click-git.py" target="_blank" rel="noopener">click-git.py</a> 文件中实现我们的 <code>git</code> 程序。</p>
<h3 id="status-子命令"><a href="#status-子命令" class="headerlink" title="status 子命令"></a>status 子命令</h3><p><code>status</code> 子命令不接受任何参数和选项，因此其实现函数只需 <code>cli.command()</code> 装饰。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@cli.command()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">status</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 status 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cmd = [<span class="string">'git'</span>, <span class="string">'status'</span>]</span><br><span class="line">    output = git.execute(cmd)</span><br><span class="line">    click.echo(output)</span><br></pre></td></tr></table></figure>
<p>不难看出，我们最后调用了真正的 <code>git status</code> 来实现，并打印了输出。</p>
<h3 id="add-子命令"><a href="#add-子命令" class="headerlink" title="add 子命令"></a>add 子命令</h3><p><code>add</code> 子命令相对于 <code>status</code> 子命令，需要接受任意个 pathspec 参数，因此增加一个 <code>click.argument</code> 装饰器，并且在 <code>add</code> 函数中需要增加同名的 <code>pathspec</code> 入参。<br>经 <code>click</code> 处理后的 <code>pathspec</code> 其实是个元组，和列表相加前，需要先转换为列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@cli.command()</span></span><br><span class="line"><span class="meta">@click.argument('pathspec', nargs=-1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(pathspec)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 add 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cmd = [<span class="string">'git'</span>, <span class="string">'add'</span>] + list(pathspec)</span><br><span class="line">    output = git.execute(cmd)</span><br><span class="line">    click.echo(output)</span><br></pre></td></tr></table></figure>
<p>当我们执行 <code>python3 click-git.py add --help</code> 时，结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: click-git.py add [OPTIONS] [PATHSPEC]...</span><br><span class="line"></span><br><span class="line">  处理 add 命令</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --help  Show this message and exit.</span><br></pre></td></tr></table></figure>
<p>既然 <code>git add</code> 能接受任意多个 <code>pathspec</code>，那么 <code>add(pathspec)</code> 的参数其实改为复数形式更为合适，但我们又希望帮助信息中是单数形式，这就需要额外指定 <code>metavar</code>，则有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@cli.command()</span></span><br><span class="line"><span class="meta">@click.argument('pathspecs', nargs=-1, metavar='[PATHSPEC]...')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(pathspecs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 add 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cmd = [<span class="string">'git'</span>, <span class="string">'add'</span>] + list(pathspecs)</span><br><span class="line">    output = git.execute(cmd)</span><br><span class="line">    click.echo(output)</span><br></pre></td></tr></table></figure>
<h3 id="commit-子命令"><a href="#commit-子命令" class="headerlink" title="commit 子命令"></a>commit 子命令</h3><p><code>add</code> 子命令相对于 <code>status</code> 子命令，需要接受 <code>-m</code> 选项，因此增加一个 <code>click.option</code> 装饰器，指定选项名称 <code>msg</code>，并且在 <code>commit</code> 函数中增加同名入参。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@cli.command()</span></span><br><span class="line"><span class="meta">@click.option('-m', 'msg')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">commit</span><span class="params">(msg)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 -m &lt;msg&gt; 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cmd = [<span class="string">'git'</span>, <span class="string">'commit'</span>, <span class="string">'-m'</span>, msg]</span><br><span class="line">    output = git.execute(cmd)</span><br><span class="line">    click.echo(output)</span><br></pre></td></tr></table></figure>
<h3 id="push-子命令"><a href="#push-子命令" class="headerlink" title="push 子命令"></a>push 子命令</h3><p><code>push</code> 子命令同 <code>status</code> 子命令一样，不接受任何参数和选项，因此其实现函数只需 <code>cli.command()</code> 装饰。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@cli.command()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 push 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cmd = [<span class="string">'git'</span>, <span class="string">'push'</span>]</span><br><span class="line">    output = git.execute(cmd)</span><br><span class="line">    click.echo(output)</span><br></pre></td></tr></table></figure>
<p>至此，我们就实现了一个简单的 <code>git</code> 命令行，使用 <code>python click-git.py status</code> 便可查询项目状态。</p>
<p>非常方便的是，每个命令函数的 <code>docstring</code> 都将作为这个命令的帮助信息，因此，当我们执行 <code>python3 click-git.py --help</code> 会自动生成如下帮助内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: click-git.py [OPTIONS] COMMAND [ARGS]...</span><br><span class="line"></span><br><span class="line">  git 命令行</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --help  Show this message and exit.</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  add     处理 add 命令</span><br><span class="line">  commit  处理 -m &lt;msg&gt; 命令</span><br><span class="line">  push    处理 push 命令</span><br><span class="line">  status  处理 status 命令</span><br></pre></td></tr></table></figure>
<p>想看整个源码，请戳 <a href="https://github.com/HelloGitHub-Team/Article/blob/master/contents/Python/cmdline/click-git.py" target="_blank" rel="noopener">click-git.py</a> 。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文简单介绍了日常工作中常用的 <code>git</code> 命令，然后提出实现它的思路，最终一步步地使用 <code>click</code> 和 <code>gitpython</code> 实现了 <code>git</code> 程序。</p>
<p>对比 <code>argparse</code> 和 <code>click</code> 的实现版本，你会发现使用 <code>click</code> 来实现变得特定简单：</p>
<ul>
<li>相较于 <code>argparse</code>，子解析器、参数类型什么的统统不需要关心</li>
<li>相较于 <code>docopt</code>，参数解析和命令调用处理也不需要关心</li>
</ul>
<p>这无疑是 <code>click</code> 最大的优势了。</p>
<p>关于 <code>click</code> 的讲解将告一段落，回顾下 <code>click</code> 的至简之道，你会爱上它。</p>
<p>现在，你已学会了三个命令行解析库的使用了。但你以为这就够了吗？<code>click</code> 已经够简单了吧，够直接了吧？但它仍然不是最简单的。</p>
<p>在下篇文章中，将为大家介绍一个由谷歌出品的在 Python 界很火的命令行库 —— <code>fire</code>。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>click</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 壹周刊 004</title>
    <url>/2019/12/10/Python-%E5%A3%B9%E5%91%A8%E5%88%8A-004/</url>
    <content><![CDATA[<h2 id="新鲜事儿"><a href="#新鲜事儿" class="headerlink" title="新鲜事儿"></a>新鲜事儿</h2><p><a href="https://www.zdnet.com/article/two-malicious-python-libraries-removed-from-pypi/" target="_blank" rel="noopener">两个恶意 Python 库被发现窃取 SSH 和 GPG 密钥</a></p>
<p>通过相似字母来让假库和真库看起来一样，以误导使用者。安装库时务必小心检查。</p>
<a id="more"></a>
<p><a href="https://metaflow.org/" target="_blank" rel="noopener">Netflix 开源了用于数据科学项目管理的 Python 库 —— Metaflow</a></p>
<p>Metaflow 是 Netflix 机器学习基础架构的关键部件，主要用于加速数据科学工作流的构建和部署，Netflix 希望通过开源 Metaflow 简化机器学习项目从原型阶段到生产阶段的过程，进而提高数据科学家的工作效率。</p>
<p><a href="https://pyfound.blogspot.com/2019/12/moss-czi-support-pip.html" target="_blank" rel="noopener">Mozilla 和 Chan Zuckerberg Initiative 支持 pip</a></p>
<p>Python 软件基金会（Python Software Foundation）将获得 407,000 美元，以支持 2020 年的 pip 改进工作。这项基础性的变革性工作将使 Python 开发人员和用户专注于他们正在构建和使用的工具，而不是对依赖冲突进行故障排查。让我们期待一下吧~</p>
<h2 id="好文共赏"><a href="#好文共赏" class="headerlink" title="好文共赏"></a>好文共赏</h2><p><a href="https://blog.startifact.com/posts/framework-patterns.html" target="_blank" rel="noopener">框架模式</a></p>
<p>有很多方法可以配置框架，而每种方法都有其自身的权衡。 这篇文章描述了 N 种框架配置模式，提供了简短的示例和并权衡点。非常值得一看。</p>
<p><a href="https://ahmedbesbes.com/end-to-end-ml.html" target="_blank" rel="noopener">端到端机器学习：从数据收集到部署</a></p>
<p>文章列出完成构建和部署机器学习应用程序的必要步骤。 从数据收集到部署，将会是一段令人兴奋且有趣的旅程。</p>
<p><a href="https://strangemachines.io/articles/performant-python" target="_blank" rel="noopener">高性能 Python</a></p>
<p>简单几行代码，你也能写出高性能的 Python 程序。</p>
<p><a href="https://dev.to/duomly/a-few-useful-tips-on-how-to-practice-python-5a9" target="_blank" rel="noopener">有关如何练习 Python 的一些有用技巧</a></p>
<p>文章提出了诸如选择合适的环境、编写和改进代码、分析源码、成为社区一部分等等技巧来帮助你提升 Python 技能。</p>
<p><a href="https://dev.to/steelwolf180/developer-tools-frameworks-for-a-python-developer-5919" target="_blank" rel="noopener">适用于 Python 开发人员的开发人员工具和框架</a></p>
<p>文章列出的工具和框架可以说是 Python 开发人员必备的了。</p>
<p><a href="https://www.pyimagesearch.com/2019/12/02/opencv-vehicle-detection-tracking-and-speed-estimation/" target="_blank" rel="noopener">使用 OpenCV 进行车辆检测、追踪和速度估算</a></p>
<p>你将学习如何使用 OpenCV 和深度学习来检测视频流中的车辆，对其进行跟踪，并应用速度估算来检测行驶中的车辆的 MPH/KPH。</p>
<p><a href="https://www.dataquest.io/blog/excel-vs-python/" target="_blank" rel="noopener">Excel vs Python：如何进行常见的数据分析任务</a></p>
<p>Excel 和 Python 有什么区别？ 在本教程中，我们将通过比较如何在两个平台上执行基本的分析任务进行比较。</p>
<p><a href="https://binaroid.com/blog/django-centralised-logging-using-elasticsearch-logstash-kibana-elk-filebeat" target="_blank" rel="noopener">使用 Elasticsearch、Logstash、Kibana（ELK）+ Filebeat 实现 Django 的集中式日志记录</a></p>
<p>在本教程中，我们将学习如何将应用程序日志从 Django 应用程序推送到 Elasticsearch 存储，并能够在 Kibana Web 工具中以可读的方式显示它。本文的主要目的是使用 Elastic 提供的另一个工具（Filebeat ）在 Django 服务器和 ELK 栈（Elasticsearch、Kibana 和 Logstash）之间建立连接。 我们还将简要介绍所有前面的步骤，例如日志记录背后的原因，在 Django 中配置日志记录以及安装 ELK 栈。</p>
<p><a href="https://pbpython.com/windows-shortcut.html" target="_blank" rel="noopener">使用 Python 构建 Windows 快捷方式</a></p>
<p>作者花了太多时间试图在多台 Windows 计算机上正确设置快捷方式，以至于要自动化创建链接。 本文将讨论如何使用 Python 创建自定义 Windows 快捷方式来启动 conda 环境。</p>
<h2 id="赞视频"><a href="#赞视频" class="headerlink" title="赞视频"></a>赞视频</h2><p><a href="https://www.youtube.com/watch?v=5sEm7RcRF_g&amp;feature=youtu.be" target="_blank" rel="noopener">通过 gmaps 玩转谷歌地图</a></p>
<p>使用 jupyter 演示，手把手教你如何玩转谷歌地图</p>
<p><a href="https://www.youtube.com/watch?v=aPCZcv-5qfA" target="_blank" rel="noopener">量子计算机编程</a></p>
<p>使用 IBM 免费的基于云的量子机器和 Qiskit，对量子计算机编程进行实用的入门介绍。</p>
<p><a href="https://www.youtube.com/watch?v=_BBNVFirvTY" target="_blank" rel="noopener">Django 3.0 都有哪些新功能</a></p>
<p>Django 刚刚发布了新的主要版本 Django 3.0。 它对你有何影响？什么是 ASGI？ 让视频中的小哥哥告诉你</p>
<p><a href="https://www.youtube.com/watch?v=mE0oR9NQefw" target="_blank" rel="noopener">Python 字节码入门教程</a></p>
<p>这是一种很好的逐步深入 CPython（事实上的 Python 参考实现）内部的方法。 如果你想了解有关 Python 的更多信息，请花 10 分钟！</p>
<p><a href="https://www.youtube.com/playlist?list=PLQYPYhKQVTvetDJZFGY8RfYlPBLQmbt-T" target="_blank" rel="noopener">PyCon 瑞典 2019 视频</a></p>
<h2 id="酷开源"><a href="#酷开源" class="headerlink" title="酷开源"></a>酷开源</h2><p><a href="https://mardix.github.io/assembly/" target="_blank" rel="noopener">Assembly</a></p>
<p>一个基于 Flask 的 Pythonic 且面向对象的 Web 框架。</p>
<p><a href="https://github.com/enric1994/emoji_trends" target="_blank" rel="noopener">emoji_trends</a></p>
<p>Twitter 上的 emoji 是如何被使用的。</p>
<p><a href="https://github.com/adamcharnock/lightbus/" target="_blank" rel="noopener">lightbus</a></p>
<p>Python 3 的 RPC &amp; 事件框架。</p>
<p><a href="https://github.com/rapidsai/cusignal" target="_blank" rel="noopener">cuSignal </a></p>
<p>cuSignal 使用 CuPy（GPU 加速的 NumPy）和自定义的 Numba CUDA 内核来加速流行的 SciPy Signal 库。</p>
<p><a href="https://github.com/aroberge/friendly-traceback" target="_blank" rel="noopener">friendly-traceback</a></p>
<p>面向 Python 初学者：用更易于理解的东西（可以翻译成多种语言）代替标准回溯。</p>
<p><a href="https://github.com/TokenChingy/pytasking" target="_blank" rel="noopener">pytasking</a></p>
<p>一个简单的 Python 3.5+多任务库。</p>
<p><a href="https://github.com/OfirKP/Whatsapp-Net" target="_blank" rel="noopener">Whatsapp-Net</a></p>
<p>根据 WhatsApp 组数据生成网络连接图。</p>
<p><a href="https://github.com/RaRe-Technologies/gensim" target="_blank" rel="noopener">gensim</a></p>
<p>用于主题建模、文档索引和相似性检索的 Python 库。</p>
<p><a href="https://github.com/micropython/micropython" target="_blank" rel="noopener">micropython</a></p>
<p>适用于微控制器和受限系统的精简高效的 Python 实现 。</p>
<p><a href="https://github.com/facebook/prophet" target="_blank" rel="noopener">prophet</a></p>
<p>为具有多季节性、线性或非线性增长的时间序列数据生成高质量的预测。</p>
<p><a href="https://github.com/tqdm/tqdm" target="_blank" rel="noopener">tqdm</a></p>
<p>适用于 Python 和 CLI 的快速、可扩展的进度栏。</p>
<p><a href="https://github.com/jaraco/keyring" target="_blank" rel="noopener">keyring</a></p>
<p>提供了一种从 Python 访问系统密钥环服务的简便方法。</p>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>壹周刊</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>壹周刊</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：深入 click（四）</title>
    <url>/2019/12/09/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9A%E6%B7%B1%E5%85%A5-click%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面三篇文章中，我们介绍了 <code>click</code> 中的参数、选项和命令，本文将介绍 <code>click</code> 锦上添花的功能，以帮助我们更加轻松地打造一个更加强大的命令行程序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="增强功能"><a href="#增强功能" class="headerlink" title="增强功能"></a>增强功能</h2><h3 id="Bash-补全"><a href="#Bash-补全" class="headerlink" title="Bash 补全"></a>Bash 补全</h3><p>Bash 补全是 <code>click</code> 提供的一个非常便捷和强大的功能，这是它比 <code>argpase</code> 和 <code>docopt</code> 强大的一个表现。</p>
<p>在命令行程序正确安装后，Bash 补全才可以使用。而如何安装可以参考 <a href="https://click.palletsprojects.com/en/7.x/setuptools/#setuptools-integration" target="_blank" rel="noopener">setup 集成</a>。Click 目前仅支持 Bash 和 Zsh 的补全。</p>
<h4 id="补全能力"><a href="#补全能力" class="headerlink" title="补全能力"></a>补全能力</h4><p>通常来说，Bash 补全支持对子命令、选项、以及选项或参数值得补全。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ repo &lt;TAB&gt;&lt;TAB&gt;</span><br><span class="line">clone    commit   copy     delete   setuser</span><br><span class="line">$ repo clone -&lt;TAB&gt;&lt;TAB&gt;</span><br><span class="line">--deep     --help     --rev      --shallow  -r</span><br></pre></td></tr></table></figure>
<p>此外，<code>click</code> 还支持自定义补全，这在动态生成补全场景中很有用，使用 <code>autocompletion</code> 参数。<code>autocompletion</code> 需要指定为一个回调函数，并且返回字符串的列表。此函数接受三个参数：</p>
<ul>
<li><code>ctx</code> —— 当前的 click 上下文</li>
<li><code>args</code> 传入的参数列表</li>
<li><code>incomplete</code> 正在补全的词</li>
</ul>
<p>这里有一个根据环境变量动态生成补全的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_env_vars</span><span class="params">(ctx, args, incomplete)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [k <span class="keyword">for</span> k <span class="keyword">in</span> os.environ.keys() <span class="keyword">if</span> incomplete <span class="keyword">in</span> k]</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.argument("envvar", type=click.STRING, autocompletion=get_env_vars)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd1</span><span class="params">(envvar)</span>:</span></span><br><span class="line">    click.echo(<span class="string">'Environment variable: %s'</span> % envvar)</span><br><span class="line">    click.echo(<span class="string">'Value: %s'</span> % os.environ[envvar])</span><br></pre></td></tr></table></figure>
<p>在 <code>ZSH</code> 中，还支持补全帮助信息。只需将 <code>autocompletion</code> 回调函数中返回的字符串列表中的字符串改为二元元组，第一个元素是补全内容，第二个元素是帮助信息。</p>
<p>这里有一个颜色补全的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_colors</span><span class="params">(ctx, args, incomplete)</span>:</span></span><br><span class="line">    colors = [(<span class="string">'red'</span>, <span class="string">'help string for the color red'</span>),</span><br><span class="line">              (<span class="string">'blue'</span>, <span class="string">'help string for the color blue'</span>),</span><br><span class="line">              (<span class="string">'green'</span>, <span class="string">'help string for the color green'</span>)]</span><br><span class="line">    <span class="keyword">return</span> [c <span class="keyword">for</span> c <span class="keyword">in</span> colors <span class="keyword">if</span> incomplete <span class="keyword">in</span> c[<span class="number">0</span>]]</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.argument("color", type=click.STRING, autocompletion=get_colors)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd1</span><span class="params">(color)</span>:</span></span><br><span class="line">    click.echo(<span class="string">'Chosen color is %s'</span> % color)</span><br></pre></td></tr></table></figure>
<h4 id="激活补全"><a href="#激活补全" class="headerlink" title="激活补全"></a>激活补全</h4><p>要激活 Bash 的补全功能，就需要告诉它你的命令行程序有补全的能力。通常通过一个神奇的环境变量 <code>_&lt;PROG_NAME&gt;_COMPLETE</code> 来告知，其中 <code>&lt;PROG_NAME&gt;</code> 是大写下划线形式的程序名称。</p>
<p>比如有一个命令行程序叫做 <code>foo-bar</code>，那么对应的环境变量名称为 <code>_FOO_BAR_COMPLETE</code>，然后在 <code>.bashrc</code> 中使用 <code>source</code> 导出即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(_FOO_BAR_COMPLETE=source foo-bar)</span>"</span></span><br><span class="line">···</span><br><span class="line"></span><br><span class="line">或者在 `.zshrc` 中使用：</span><br><span class="line">```bash</span><br><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(_FOO_BAR_COMPLETE=source_zsh foo-bar)</span>"</span></span><br></pre></td></tr></table></figure>
<p>不过上面的方式总是在命令行程序启动时调用，这可能在有多个程序时减慢 shell 激活的速度。另一种方式是把命令放在文件中，就像这样：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 针对 Bash</span></span><br><span class="line">_FOO_BAR_COMPLETE=<span class="built_in">source</span> foo-bar &gt; foo-bar-complete.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 针对 ZSH</span></span><br><span class="line">_FOO_BAR_COMPLETE=source_zsh foo-bar &gt; foo-bar-complete.sh</span><br></pre></td></tr></table></figure>
<p>然后把脚本文件路径加到 <code>.bashrc</code> 或 <code>.zshrc</code> 中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">. /path/to/foo-bar-complete.sh</span><br></pre></td></tr></table></figure>
<h3 id="实用工具"><a href="#实用工具" class="headerlink" title="实用工具"></a>实用工具</h3><h4 id="打印到标准输出"><a href="#打印到标准输出" class="headerlink" title="打印到标准输出"></a>打印到标准输出</h4><p><a href="https://click.palletsprojects.com/en/7.x/api/#click.echo" target="_blank" rel="noopener">echo()</a> 函数可以说是最有用的实用工具了。它和 Python 的 <code>print</code> 类似，主要的区别在于它同时在 Python 2 和 3 中生效，能够智能地检测未配置正确的输出流，且几乎不会失败（除了 Python 3 中的<a href="https://click.palletsprojects.com/en/7.x/python3/#python3-limitations" target="_blank" rel="noopener">少数限制</a>。）</p>
<p><code>echo</code> 即支持 unicode，也支持二级制数据，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> click</span><br><span class="line"></span><br><span class="line">click.echo(<span class="string">'Hello World!'</span>)</span><br><span class="line"></span><br><span class="line">click.echo(<span class="string">b'\xe2\x98\x83'</span>, nl=<span class="keyword">False</span>) <span class="comment"># nl=False 表示不输出换行符</span></span><br></pre></td></tr></table></figure>
<h4 id="ANSI-颜色"><a href="#ANSI-颜色" class="headerlink" title="ANSI 颜色"></a>ANSI 颜色</h4><p>有些时候你可能希望输出是有颜色的，这尤其在输出错误信息时有用，而 <code>click</code> 在这方面支持的很好。</p>
<p>首先，你需要安装 <code>colorama</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install colorama</span><br></pre></td></tr></table></figure>
<p>然后，就可以使用 <a href="https://click.palletsprojects.com/en/7.x/api/#click.style" target="_blank" rel="noopener">style()</a> 函数来指定颜色：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> click</span><br><span class="line"></span><br><span class="line">click.echo(click.style(<span class="string">'Hello World!'</span>, fg=<span class="string">'green'</span>))</span><br><span class="line">click.echo(click.style(<span class="string">'Some more text'</span>, bg=<span class="string">'blue'</span>, fg=<span class="string">'white'</span>))</span><br><span class="line">click.echo(click.style(<span class="string">'ATTENTION'</span>, blink=<span class="keyword">True</span>, bold=<span class="keyword">True</span>))</span><br></pre></td></tr></table></figure>
<p><code>click</code> 还提供了更加简便的函数 <a href="https://click.palletsprojects.com/en/7.x/api/#click.secho" target="_blank" rel="noopener">secho</a>，它就是 <code>echo</code> 和 <code>style</code> 的组合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">click.secho(<span class="string">'Hello World!'</span>, fg=<span class="string">'green'</span>)</span><br><span class="line">click.secho(<span class="string">'Some more text'</span>, bg=<span class="string">'blue'</span>, fg=<span class="string">'white'</span>)</span><br><span class="line">click.secho(<span class="string">'ATTENTION'</span>, blink=<span class="keyword">True</span>, bold=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<h4 id="分页支持"><a href="#分页支持" class="headerlink" title="分页支持"></a>分页支持</h4><p>有些时候，命令行程序会输出长文本，但你希望能让用户盘也浏览。使用 <a href="https://click.palletsprojects.com/en/7.x/api/#click.echo_via_pager" target="_blank" rel="noopener">echo_via_pager()</a> 函数就可以轻松做到。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">less</span><span class="params">()</span>:</span></span><br><span class="line">    click.echo_via_pager(<span class="string">'\n'</span>.join(<span class="string">'Line %d'</span> % idx</span><br><span class="line">                                   <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">200</span>)))</span><br></pre></td></tr></table></figure>
<p>如果输出的文本特别大，处于性能的考虑，希望翻页时生成对应内容，那么就可以使用生成器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_generate_output</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(<span class="number">50000</span>):</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"Line %d\n"</span> % idx</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">less</span><span class="params">()</span>:</span></span><br><span class="line">    click.echo_via_pager(_generate_output())</span><br></pre></td></tr></table></figure>
<h4 id="清除屏幕"><a href="#清除屏幕" class="headerlink" title="清除屏幕"></a>清除屏幕</h4><p>使用 <a href="https://click.palletsprojects.com/en/7.x/api/#click.clear" target="_blank" rel="noopener">clear()</a> 可以轻松清除屏幕内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> click</span><br><span class="line">click.clear()</span><br></pre></td></tr></table></figure>
<h4 id="从终端获取字符"><a href="#从终端获取字符" class="headerlink" title="从终端获取字符"></a>从终端获取字符</h4><p>通常情况下，使用内建函数 <code>input</code> 或 <code>raw_input</code> 获得的输入是用户输出一段字符然后回车得到的。但在有些场景下，你可能想在用户输入单个字符时就能获取到并且做一定的处理，这个时候 <a href="https://click.palletsprojects.com/en/7.x/api/#click.getchar" target="_blank" rel="noopener">getchar()</a> 就派上了用场。</p>
<p>比如，根据输入的 <code>y</code> 或 <code>n</code> 做特定处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> click</span><br><span class="line"></span><br><span class="line">click.echo(<span class="string">'Continue? [yn] '</span>, nl=<span class="keyword">False</span>)</span><br><span class="line">c = click.getchar()</span><br><span class="line">click.echo()</span><br><span class="line"><span class="keyword">if</span> c == <span class="string">'y'</span>:</span><br><span class="line">    click.echo(<span class="string">'We will go on'</span>)</span><br><span class="line"><span class="keyword">elif</span> c == <span class="string">'n'</span>:</span><br><span class="line">    click.echo(<span class="string">'Abort!'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    click.echo(<span class="string">'Invalid input :('</span>)</span><br></pre></td></tr></table></figure>
<h4 id="等待按键"><a href="#等待按键" class="headerlink" title="等待按键"></a>等待按键</h4><p>在 Windows 的 cmd 中我们经常看到当执行完一个命令后，提示按下任意键退出。通过使用 <a href="https://click.palletsprojects.com/en/7.x/api/#click.pause" target="_blank" rel="noopener">pause()</a> 可以实现暂停直至用户按下任意键：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> click</span><br><span class="line">click.pause()</span><br></pre></td></tr></table></figure>
<h4 id="启动编辑器"><a href="#启动编辑器" class="headerlink" title="启动编辑器"></a>启动编辑器</h4><p>通过 <a href="https://click.palletsprojects.com/en/7.x/api/#click.edit" target="_blank" rel="noopener">edit()</a> 可以自动启动编辑器。这在需要用户输入多行内容时十分有用。</p>
<p>在下面的示例中，会启动默认的文本编辑器，并在里面输入一段话：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> click</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_commit_message</span><span class="params">()</span>:</span></span><br><span class="line">    MARKER = <span class="string">'# Everything below is ignored\n'</span></span><br><span class="line">    message = click.edit(<span class="string">'\n\n'</span> + MARKER)</span><br><span class="line">    <span class="keyword">if</span> message <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> message.split(MARKER, <span class="number">1</span>)[<span class="number">0</span>].rstrip(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<p><code>edit()</code> 函数还支持打开特定文件，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> click</span><br><span class="line">click.edit(filename=<span class="string">'/etc/passwd'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="启动应用程序"><a href="#启动应用程序" class="headerlink" title="启动应用程序"></a>启动应用程序</h4><p>通过 <a href="https://click.palletsprojects.com/en/7.x/api/#click.launch" target="_blank" rel="noopener">launch</a> 可以打开 URL 或文件类型所关联的默认应用程序。如果设置 <code>locate=True</code>，则可以启动文件管理器并自动选中特定文件。</p>
<p>示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开浏览器，访问 URL</span></span><br><span class="line">click.launch(<span class="string">"https://click.palletsprojects.com/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用默认应用程序打开 txt 文件</span></span><br><span class="line">click.launch(<span class="string">"/my/downloaded/file.txt"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件管理器，并自动选中 file.txt</span></span><br><span class="line">click.launch(<span class="string">"/my/downloaded/file.txt"</span>, locate=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure>
<h4 id="显示进度条"><a href="#显示进度条" class="headerlink" title="显示进度条"></a>显示进度条</h4><p><code>click</code> 内置了 <a href="https://click.palletsprojects.com/en/7.x/api/#click.progressbar" target="_blank" rel="noopener">progressbar()</a> 函数来方便地显示进度条。</p>
<p>它的用法也很简单，假定你有一个要处理的可迭代对象，处理完每一项就要输出一下进度，那么就有两种用法。</p>
<p>用法一：使用 <code>progressbar</code> 构造出 <code>bar</code> 对象，迭代 <code>bar</code> 对象来自动告知进度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> click</span><br><span class="line"></span><br><span class="line">all_the_users_to_process = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify_the_user</span><span class="params">(user)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> click.progressbar(all_the_users_to_process) <span class="keyword">as</span> bar:</span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> bar:</span><br><span class="line">        modify_the_user(user)</span><br></pre></td></tr></table></figure>
<p>用法二：使用 <code>progressbar</code> 构造出 <code>bar</code> 对象，迭代原始可迭代对象，并不断向 <code>bar</code> 更新进度：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> click</span><br><span class="line"></span><br><span class="line">all_the_users_to_process = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">modify_the_user</span><span class="params">(user)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> click.progressbar(all_the_users_to_process) <span class="keyword">as</span> bar:</span><br><span class="line">    <span class="keyword">for</span> user <span class="keyword">in</span> enumerate(all_the_users_to_process):</span><br><span class="line">        modify_the_user(user)</span><br><span class="line">        bar.update(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="更多实用工具"><a href="#更多实用工具" class="headerlink" title="更多实用工具"></a>更多实用工具</h4><ul>
<li><a href="https://click.palletsprojects.com/en/7.x/utils/#printing-filenames" target="_blank" rel="noopener">打印文件名</a></li>
<li><a href="https://click.palletsprojects.com/en/7.x/utils/#standard-streams" target="_blank" rel="noopener">标准流</a></li>
<li><a href="https://click.palletsprojects.com/en/7.x/utils/#intelligent-file-opening" target="_blank" rel="noopener">智能打开文件</a></li>
<li><a href="https://click.palletsprojects.com/en/7.x/utils/#finding-application-folders" target="_blank" rel="noopener">查找应用程序文件夹</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>click</code> 提供了非常多的增强型功能，本文着重介绍了它的 Bash 补全和十多个实用工具，这会让你在实现命令行的过程中如虎添翼。此外，<code>click</code> 还提供了诸如命令别名、参数修改、标准化令牌、调用其他命令、回调顺序等诸多<a href="https://click.palletsprojects.com/en/7.x/advanced/" target="_blank" rel="noopener">高级模式</a> 以应对更加复杂或特定的场景，我们就不再深入介绍。</p>
<p><code>click</code> 的介绍就告一段落，它将会是你编写命令行程序的一大利器。在下一篇文章中，我们依然会通过实现一个简单的 <code>git</code> 程序来进行 <code>click</code> 的实战。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>click</tag>
      </tags>
  </entry>
  <entry>
    <title>为终端设置代理</title>
    <url>/2019/12/08/%E4%B8%BA%E7%BB%88%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>有时候通过终端访问 github 等国外网站的速度感人，需要为终端设置代理来提高速度，然而不同平台上的命令我老忘记，遂记录已备忘。</p>
<p>下文我们假设代理地址是 <code>127.0.0.1:1080</code>。</p>
<a id="more"></a>
<h2 id="Linux-Unix"><a href="#Linux-Unix" class="headerlink" title="Linux/Unix"></a>Linux/Unix</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置代理</span><br><span class="line">set http_proxy=http://127.0.0.1:1080</span><br><span class="line">set https_proxy=http://127.0.0.1:1080</span><br><span class="line"></span><br><span class="line"># 查看代理</span><br><span class="line">echo $http_proxy</span><br><span class="line">echo $https_proxy</span><br><span class="line"></span><br><span class="line"># 取消代理</span><br><span class="line">set http_proxy=</span><br><span class="line">set https_proxy=</span><br></pre></td></tr></table></figure>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 设置代理</span><br><span class="line">netsh winhttp set proxy 127.0.0.1:1080</span><br><span class="line"></span><br><span class="line"># 查看代理</span><br><span class="line">netsh winhttp show proxy</span><br><span class="line"></span><br><span class="line"># 取消代理</span><br><span class="line">netsh winhttp reset proxy</span><br></pre></td></tr></table></figure>
<h2 id="写个脚本工具"><a href="#写个脚本工具" class="headerlink" title="写个脚本工具"></a>写个脚本工具</h2><p>对于使用多个平台的我来说，用到再去翻找命令还是有些麻烦，所以不如写个脚本工具来跨平台使用。</p>
<p>项目地址： <a href="https://github.com/Prodesire/terminal-proxy" target="_blank" rel="noopener">https://github.com/Prodesire/terminal-proxy</a> 。</p>
<p>不论是什么平台，用法都非常简单：</p>
<p>首先是安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install terminal-proxy</span><br></pre></td></tr></table></figure>
<p>然后配置一遍代理地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxy config 127.0.0.1:1080</span><br></pre></td></tr></table></figure>
<p>然后就可以愉快地在命令行中开启关闭代理了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 开启代理</span><br><span class="line">proxy on</span><br><span class="line"></span><br><span class="line"># 查看代理</span><br><span class="line">proxy show</span><br><span class="line"></span><br><span class="line"># 关闭代理</span><br><span class="line">proxy off</span><br></pre></td></tr></table></figure>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>]]></content>
  </entry>
  <entry>
    <title>Python 壹周刊 003</title>
    <url>/2019/12/03/Python-%E5%A3%B9%E5%91%A8%E5%88%8A-003/</url>
    <content><![CDATA[<h2 id="新鲜事儿"><a href="#新鲜事儿" class="headerlink" title="新鲜事儿"></a>新鲜事儿</h2><p><a href="https://docs.python.org/3.9/whatsnew/3.9.html" target="_blank" rel="noopener">Python 3.9a1 都有哪些新内容</a></p>
<p>Python 3.9a1 发布了，快看看有哪些内容。后续将会专门写篇文章详细介绍。</p>
<a id="more"></a>
<h2 id="好文共赏"><a href="#好文共赏" class="headerlink" title="好文共赏"></a>好文共赏</h2><p><a href="https://nedbatchelder.com/text/unipain.html" target="_blank" rel="noopener">实用的 Unicode</a></p>
<p>2012 年的关于 Unicode 的老文章，但仍非常值得阅读。相信不少同学在 Python 2 上关于字符编码问题踩了不少坑。这篇文章带你透过现象看本质。</p>
<p><a href="https://blog.dropbox.com/topics/work-culture/-the-mind-at-work--guido-van-rossum-on-how-python-makes-thinking" target="_blank" rel="noopener">工作思路：Guido van Rossum 谈 Python 如何使代码思考变得更轻松</a></p>
<p>本周早些时候推荐的文章。</p>
<p><a href="https://dev.to/duomly/10-reasons-why-learning-python-is-still-a-great-idea-5abh" target="_blank" rel="noopener">为什么学习 Python 仍然是个好主意的十个理由</a></p>
<p>学习 Python 永远都不会晚。</p>
<p><a href="https://dev.to/coderasha/let-me-introduce-you-reverse-python-1eef" target="_blank" rel="noopener">Reverse Python 介绍</a></p>
<p>这是一个科学技术研究平台，对此感兴趣的同学可以了解下。</p>
<p><a href="https://ahmedbesbes.com/end-to-end-ml.html" target="_blank" rel="noopener">使用 Python 从零开始将机器学习应用程序构建和部署到 AWS：端到端教程</a></p>
<p>关于机器学习全栈技术从零开始的教程，涉及到使用 selenium 和 scrapy 进行爬虫，使用 pandas 进行数据处理，使用 pytorch 进行模型训练，使用 Dash、Falsk 和 PostgreSQL 搭建服务端以及使用 Docker 容器化，并最终部署到 AWS 上。</p>
<p><a href="https://www.techbeamers.com/top-python-libraries-data-science/" target="_blank" rel="noopener">用于数据科学项目的 Top 25 Python 库</a></p>
<p>涉及到数据收集、清洗、可视化、模型化、音频、媒体处理、数据库和 Web 等内容。</p>
<p><a href="https://bhoey.com/blog/extracting-raw-photo-exif-data-with-python/" target="_blank" rel="noopener">使用 Python 提取原始照片的 EXIF 数据</a></p>
<p><a href="https://orbifold.xyz/raising-exceptions.html" target="_blank" rel="noopener">在 Python 中更好地抛出异常</a></p>
<p>我们可能在不经意间误用异常，来看看正确使用姿势。</p>
<p><a href="https://sobolevn.me/2019/10/testing-django-migrations" target="_blank" rel="noopener">测试 Django 的数据迁移</a></p>
<p><a href="https://changelog.complete.org/archives/10053-the-incredible-disaster-of-python-3" target="_blank" rel="noopener">Python 3 中 byte/str 分离带来的问题</a></p>
<p>某些情境下，一些 IO 相关库不能正确处理字符问题，来看看此文章避免采坑。</p>
<p><a href="https://realpython.com/invalid-syntax-python/" target="_blank" rel="noopener">Python 中非法的语法：SyntaxError 的常见原因</a></p>
<p>提供了 Python 中非法语法的常见示例，并了解如何解决该问题。</p>
<p><a href="https://medium.com/blueberryx/learn-to-work-with-next-gen-neurotech-data-fnirs-with-this-easy-tutorial-7ce9272ee9fb" target="_blank" rel="noopener">使用 Python 检测人脑中的“思维强度”</a></p>
<p>如何开始使用 fNIRS 感测数据，尤其是氧化血红蛋白“ HbO2 / HbO”数据，分析来自传感器的数据流。</p>
<p><a href="https://plumberjack.blogspot.com/2019/11/a-qt-gui-for-logging.html" target="_blank" rel="noopener">Qt GUI 如何打日志</a></p>
<p><a href="https://alexandrugris.github.io/maths/2017/04/30/symbolic-maths-python.html" target="_blank" rel="noopener">Python 中的符号数学</a></p>
<p>执行符号计算的能力是任何面向数学的软件包的关键组成部分。，文章介绍了如何使用 sympy 来实现符号计算。</p>
<h2 id="赞视频"><a href="#赞视频" class="headerlink" title="赞视频"></a>赞视频</h2><p><a href="https://realpython.com/courses/python-keyerror/" target="_blank" rel="noopener">Python KeyError 异常及处理</a></p>
<p>KeyError 意味着什么？什么时候抛出这个异常？如何处理它？这个视频教程给你答案。</p>
<h2 id="酷开源"><a href="#酷开源" class="headerlink" title="酷开源"></a>酷开源</h2><p><a href="https://github.com/ycm-core/YouCompleteMe" target="_blank" rel="noopener">YouCompleteMe</a></p>
<p>vim 的代码补全引擎。</p>
<p><a href="https://github.com/quantopian/pyfolio" target="_blank" rel="noopener">pyfolio</a></p>
<p>Python 的投资组合和风险分析库。</p>
<p><a href="https://github.com/spotify/luigi" target="_blank" rel="noopener">luigi</a></p>
<p>用来帮助构建批处理作业复杂管道的 Python 库。</p>
<p><a href="https://github.com/pyca/cryptography" target="_blank" rel="noopener">cryptography</a></p>
<p>一个旨在向 Python 开发人员公开密码基元和用法的软件包。</p>
<p><a href="https://github.com/nltk/nltk" target="_blank" rel="noopener">nltk</a></p>
<p>NLTK（自然语言工具包）是一套支持自然语言处理研究和开发的开源 Python 模块、数据集和教程。</p>
<p><a href="https://github.com/maxhumber/gazpacho" target="_blank" rel="noopener">gazpacho</a></p>
<p>Web 爬虫库。</p>
<p><a href="https://github.com/pallets/werkzeug" target="_blank" rel="noopener">werkzeug</a></p>
<p>一个全面的 WSGI Web 应用程序库。Flask 就是基于此库编写的。</p>
<p><a href="https://github.com/dw/mitogen" target="_blank" rel="noopener">Mitogen</a></p>
<p>用于编写分布式自复制程序的 Python 库。</p>
<p><a href="https://github.com/greenbone/autohooks" target="_blank" rel="noopener">autohooks</a></p>
<p>使用 Python 编写 git hook。</p>
<p><a href="https://mg.pov.lt/objgraph/" target="_blank" rel="noopener">objgraph</a></p>
<p>objgraph 帮助直观地浏览 Python 对象图的模块。</p>
<p><a href="https://github.com/fogleman/Minecraft" target="_blank" rel="noopener">Minecraft</a></p>
<p>用 Python 和 Pyglet 编写的 Minecraft 简单 demo。</p>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>壹周刊</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>壹周刊</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 壹周刊 002</title>
    <url>/2019/11/26/Python-%E5%A3%B9%E5%91%A8%E5%88%8A-002/</url>
    <content><![CDATA[<h2 id="新鲜事儿"><a href="#新鲜事儿" class="headerlink" title="新鲜事儿"></a>新鲜事儿</h2><p><a href="https://www.sourcetrail.com/blog/open_source/" target="_blank" rel="noopener">交互式源码浏览器 Sourcetrail 开源了</a></p>
<p>要阅读源码的你可能会感到痛苦，没有一个好用的工具可以让你对代码有一个全局观，并能看到当前代码的上下游依赖关系，Sourcetrai 能很好的满足你的需求。现在，它开源了，几天内就收获了数千 Star。</p>
<a id="more"></a>
<p><a href="https://pycon.blogspot.com/2019/11/registration-for-pycon-us-2020-is-open.html" target="_blank" rel="noopener">PyCon US 2020 的报名注册现已开启</a></p>
<p>早鸟票：公司 $550、个人 $350、学生 \$100。仅售 800 张。</p>
<p>普通票：公司 $700、个人 $400、学生 \$125。</p>
<p>说实话，对中国人民来说太贵了。</p>
<p><a href="https://pyfound.blogspot.com/2019/11/python-software-foundation-fellow.html" target="_blank" rel="noopener">2019 Q3 Python 软件基金会成员</a></p>
<p>有兴趣的小伙伴可以去申请亚洲的 PSF 成员，不是很难。</p>
<h2 id="好文共赏"><a href="#好文共赏" class="headerlink" title="好文共赏"></a>好文共赏</h2><p><a href="https://www.twilio.com/blog/build-a-whatsapp-chatbot-with-python-flask-and-twilio" target="_blank" rel="noopener">使用 Python、Flask 和 Twilio 构建 WhatsApp 聊天机器人</a></p>
<p>简单的实践教程，一步步教你如何构建 WhatsApp 聊天机器人。</p>
<p><a href="https://dev.to/nityeshaga/advance-your-python-skills-by-building-a-whatsapp-chat-analyser-a-guided-project-6p9" target="_blank" rel="noopener">通过构建 WatsApp 聊天分析器来提升你的 Python 技巧</a></p>
<p>本教程涉及到文件处理、字符串操作、模块、函数、pip 和正则表达式，综合实践的不二之选。</p>
<p><a href="https://dev.to/taeluralexis/100daysofpython-day-1-hello-world-data-types-strings-2cnk" target="_blank" rel="noopener">#Python 的 100 天之第 1 天：Hello World、数据类型&amp;字符串</a></p>
<p>非常易懂的入门系列，跟着学一定没错。</p>
<p><a href="https://realpython.com/pandas-groupby/" target="_blank" rel="noopener">Pandas GroupBy：使用 Python 进行数据分组的教程</a></p>
<p>Pandas 进阶教程，了解 groupby 的设计、使用的绝佳教程。</p>
<p><a href="https://pythonspeed.com/articles/pandas-load-less-data" target="_blank" rel="noopener">通过载入更少的数据来减少 Pandas 的内存使用量</a></p>
<p>高效使用 Pandas 的居家必备之技巧。</p>
<p><a href="https://dev.to/educative/top-5-concurrency-interview-questions-for-software-engineers-1ng0" target="_blank" rel="noopener">给软件工程师的 Top 5 并发面试题</a></p>
<p>5 类典型的并发问题，快来学习掌握吧~</p>
<p><a href="https://www.scrapingbee.com/blog/web-scraping-101-with-python" target="_blank" rel="noopener">Python 网络爬虫 101</a></p>
<p>依次介绍使用 socket、urllib3、requests、Scrapy 和 selenium 进行网络爬虫的步骤，并进行横向对比，入门爬虫的好教程。</p>
<p><a href="https://www.pyimagesearch.com/2019/11/18/fire-and-smoke-detection-with-keras-and-deep-learning/" target="_blank" rel="noopener">使用 Keras 和深度学习进行烟、火检测</a></p>
<p>本教程中你讲学习如何使用计算机视觉、OpenCV 和 Keras 深度学习库来检测烟、火。</p>
<p><a href="https://tryexceptpass.org/article/secure-asynchronous-apis-using-ssh/" target="_blank" rel="noopener">使用 SSH 实现非常规的安全和异步的 RESTFul API</a></p>
<p>如何使用 Korv 和 AsyncSSH 在 Python 中构建通过 SSH 会话侦听 TCP socket 的安全的异步的 API。</p>
<p><a href="https://towardsdatascience.com/the-ultimate-beginners-guide-to-numpy-f5a2f99aef54" target="_blank" rel="noopener">NumPy 终极入门指南</a></p>
<p>所有要开始 NumPy 的知识点都在这。</p>
<p><a href="https://www.dataquest.io/blog/python-list-tutorial/" target="_blank" rel="noopener">Python 列表教程：列表、循环还有更多</a></p>
<p>了解如何使用和掌握列表，分析应用商店数据，了解如何使用循环自动执行重复性任务。</p>
<p><a href="https://wiedi.frubar.net/blog/2019/11/18/django-performance/" target="_blank" rel="noopener">使用 DTrace 和 cProfile 分析 Django</a></p>
<p>官方文档有一章关于性能和优化，并提供了不错的建议。本文在此基础上进行构建，并展示作者过去用于减少页面加载时间的工具和方法。</p>
<p><a href="https://opensource.com/article/19/11/awk-to-python" target="_blank" rel="noopener">如何将 awk 脚本移植到 Python 中</a></p>
<p>将 awk 脚本移植到 Python 更多的是代码风格，而不是翻译。</p>
<p><a href="https://blog.floydhub.com/knowledge-distillation/" target="_blank" rel="noopener">从神经网络中提炼知识，构建更小、更快的模型</a></p>
<p>本文讨论了 GPT-2 和 BERT 模型，以及利用知识提炼来创建参数更少的高精度模型。</p>
<p><a href="https://www.fullstackpython.com/blog/python-basic-data-types-booleans.html" target="_blank" rel="noopener">Python 3 中基本的数据类型：布尔</a></p>
<p>了解如何在 Python 3 代码中使用布尔值（True 和 False）。</p>
<p><a href="https://nezhar.com/blog/django-rest-framework-permissions-in-depth/" target="_blank" rel="noopener">Django REST 框架之权限</a></p>
<p><a href="https://towardsdatascience.com/how-to-detect-mean-tweets-with-machine-learning-deaa9dc6a8a8" target="_blank" rel="noopener">如何通过机器学习检测负面推文</a></p>
<h2 id="赞视频"><a href="#赞视频" class="headerlink" title="赞视频"></a>赞视频</h2><p><a href="https://www.youtube.com/watch?reload=9&amp;v=7EifKIFk60U&amp;feature=youtu.be" target="_blank" rel="noopener">2004-2019 年间最受欢迎的编程语言</a>（youtube）</p>
<p>Python 的崛起之路正如周杰伦的《蜗牛》那样：“我要一步一步往上爬”。</p>
<p><a href="https://www.youtube.com/watch?v=z0gguhEmWiY" target="_blank" rel="noopener">Python 教程：创建和解压压缩文件</a>（youtube）</p>
<p><a href="https://www.youtube.com/watch?v=YXPyB4XeYLA" target="_blank" rel="noopener">Tkinter 课程：使用 Python 创建图形化用户界面</a>（youtube）</p>
<p>面向初学者的 Tkinter 教程。</p>
<h2 id="酷开源"><a href="#酷开源" class="headerlink" title="酷开源"></a>酷开源</h2><p><a href="https://github.com/aws/aws-cli" target="_blank" rel="noopener">aws-cli</a></p>
<p>亚马逊 Web 服务的通用命令行程序。</p>
<p><a href="https://github.com/pyqtgraph/pyqtgraph" target="_blank" rel="noopener">PyQtGraph</a></p>
<p>交互式和实时 2D/3D/图像绘图和科学/工程小部件。</p>
<p><a href="https://github.com/numba/numba" target="_blank" rel="noopener">Numba</a></p>
<p>使用 LLVM 的 Python JIT 编译器。</p>
<p><a href="https://github.com/urllib3/urllib3" target="_blank" rel="noopener">urllib3</a></p>
<p>Python HTTP 库，具有线程安全连接池、文件传输支持、使用友好等特性。</p>
<p><a href="https://github.com/mercadona/rele" target="_blank" rel="noopener">rele</a></p>
<p>轻松使用谷歌 PubSub。</p>
<p><a href="https://github.com/soimort/you-get" target="_blank" rel="noopener">you-get</a></p>
<p>下载网络媒体内容（视频、音频、图像）的命令行工具。</p>
<p><a href="https://github.com/scrapy/scrapy" target="_blank" rel="noopener">Scrapy</a></p>
<p>快速、高层次的网络爬虫框架。</p>
<p><a href="https://github.com/urwid/urwid" target="_blank" rel="noopener">urwid</a></p>
<p>用于创建终端 GUI 应用程序的库，对小部件、事件、丰富颜色等具有强大的支持。</p>
<p><a href="https://pythonweekly.us2.list-manage.com/track/click?u=e2e180baf855ac797ef407fc7&amp;id=1584d3b675&amp;e=de9f27bcc4" target="_blank" rel="noopener">Quay</a></p>
<p>生成、存储和分发应用程序和容器。</p>
<p><a href="https://pythonweekly.us2.list-manage.com/track/click?u=e2e180baf855ac797ef407fc7&amp;id=088c5acad7&amp;e=de9f27bcc4" target="_blank" rel="noopener">Deepdrive</a></p>
<p>用于自动驾驶汽车的端到端仿真。</p>
<p><a href="https://pythonweekly.us2.list-manage.com/track/click?u=e2e180baf855ac797ef407fc7&amp;id=fe80e116b4&amp;e=de9f27bcc4" target="_blank" rel="noopener">great_expectations</a></p>
<p>“远大期望”是分析、验证和记录数据的工具，用于保持质量并改善团队之间的沟通。</p>
<p><a href="https://pythonweekly.us2.list-manage.com/track/click?u=e2e180baf855ac797ef407fc7&amp;id=1db8bed78f&amp;e=de9f27bcc4" target="_blank" rel="noopener">meshio</a></p>
<p>有多种网格格式可用于表示非结构化网格。meshio 可以读取和写入多种格式，并在它们之间平滑转换。</p>
<p><a href="https://pythonweekly.us2.list-manage.com/track/click?u=e2e180baf855ac797ef407fc7&amp;id=63af8fd32f&amp;e=de9f27bcc4" target="_blank" rel="noopener">Clusterman</a></p>
<p>群集管理员（群集管理器）是 Mesos 和 Kubernetes 群集的自动伸缩引擎。它观测指标，并可启动或终止计算以满足工作负载的需求，类似于官方的 Kubernetes 群集自动伸缩器。</p>
<p><a href="https://pythonweekly.us2.list-manage.com/track/click?u=e2e180baf855ac797ef407fc7&amp;id=5497bff04a&amp;e=de9f27bcc4" target="_blank" rel="noopener">jwt_tool</a></p>
<p>用于测试、调整和破解 JSON Web 令牌的工具包。</p>
<p><a href="https://pythonweekly.us2.list-manage.com/track/click?u=e2e180baf855ac797ef407fc7&amp;id=91c57cdfa6&amp;e=de9f27bcc4" target="_blank" rel="noopener">mail-sanitizer</a></p>
<p>用于清理电子邮件的命令行工具。</p>
<p><a href="https://pythonweekly.us2.list-manage.com/track/click?u=e2e180baf855ac797ef407fc7&amp;id=39578b0b2d&amp;e=de9f27bcc4" target="_blank" rel="noopener">OpenNRE</a></p>
<p>用于神经关系提取 （NRE） 的开源包。</p>
<p><a href="https://pythonweekly.us2.list-manage.com/track/click?u=e2e180baf855ac797ef407fc7&amp;id=37313e05d9&amp;e=de9f27bcc4" target="_blank" rel="noopener">ytmdl</a></p>
<p>通过 itunes 上所有的标签从 youtube 上获得 mp3 格式歌曲的简单脚本。</p>
<p><a href="https://pythonweekly.us2.list-manage.com/track/click?u=e2e180baf855ac797ef407fc7&amp;id=aa6f7bd759&amp;e=de9f27bcc4" target="_blank" rel="noopener">ADTK</a></p>
<p>用于时间序列中无监督异常检测的 Python 工具包。</p>
<p><a href="https://pythonweekly.us2.list-manage.com/track/click?u=e2e180baf855ac797ef407fc7&amp;id=8796c379e6&amp;e=de9f27bcc4" target="_blank" rel="noopener">kaolin</a></p>
<p>用于加速 3D 深度学习研究的 Pytorch 库。</p>
<p><a href="https://pythonweekly.us2.list-manage.com/track/click?u=e2e180baf855ac797ef407fc7&amp;id=7531a9e429&amp;e=de9f27bcc4" target="_blank" rel="noopener">rsh</a></p>
<p>rsh 是一种纯粹用 Python 编写的工具，可轻松为 Linux 和 Windows 生成反向 shell 命令。</p>
<p><a href="https://pythonweekly.us2.list-manage.com/track/click?u=e2e180baf855ac797ef407fc7&amp;id=829eb14ca6&amp;e=de9f27bcc4" target="_blank" rel="noopener">flask-dashboard-modular-admin</a></p>
<p>Flask Web 矿建中开源的管理仪表盘。</p>
<p><a href="https://pythonweekly.us2.list-manage.com/track/click?u=e2e180baf855ac797ef407fc7&amp;id=567f9cfa43&amp;e=de9f27bcc4" target="_blank" rel="noopener">Pandera</a></p>
<p>Pandas 的统计数据验证工具包。</p>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>壹周刊</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>壹周刊</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：深入 click（三）</title>
    <url>/2019/11/25/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9A%E6%B7%B1%E5%85%A5-click%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上两篇文章中，我们介绍了 <code>click</code> 中的”参数“和“选项”，本文将继续深入了解 <code>click</code>，着重讲解它的“命令”和”组“。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<h2 id="命令和组"><a href="#命令和组" class="headerlink" title="命令和组"></a>命令和组</h2><p><code>Click</code> 中非常重要的特性就是任意嵌套命令行工具的概念，通过 <a href="https://click.palletsprojects.com/en/7.x/api/#click.Command" target="_blank" rel="noopener">Command</a> 和 <a href="https://click.palletsprojects.com/en/7.x/api/#click.Group" target="_blank" rel="noopener">Group</a> （实际上是 <a href="https://click.palletsprojects.com/en/7.x/api/#click.MultiCommand" target="_blank" rel="noopener">MultiCommand</a>）来实现。</p>
<p>所谓命令组就是若干个命令（或叫子命令）的集合，也成为多命令。</p>
<h3 id="回调调用"><a href="#回调调用" class="headerlink" title="回调调用"></a>回调调用</h3><p>对于一个普通的命令来说，回调发生在命令被执行的时候。如果这个程序的实现中只有命令，那么回调总是会被触发，就像我们在上一篇文章中举出的所有示例一样。不过像 <code>--help</code> 这类选项则会阻止进入回调。</p>
<p>对于组和多个子命令来说，情况略有不同。回调通常发生在子命令被执行的时候：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.group()</span></span><br><span class="line"><span class="meta">@click.option('--debug/--no-debug', default=False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">(debug)</span>:</span></span><br><span class="line">    click.echo(<span class="string">'Debug mode is %s'</span> % (<span class="string">'on'</span> <span class="keyword">if</span> debug <span class="keyword">else</span> <span class="string">'off'</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">@cli.command()  # @cli, not @click!</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sync</span><span class="params">()</span>:</span></span><br><span class="line">    click.echo(<span class="string">'Syncing'</span>)</span><br></pre></td></tr></table></figure>
<p>执行效果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: tool.py [OPTIONS] COMMAND [ARGS]...</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --debug / --no-debug</span><br><span class="line">  --<span class="built_in">help</span>                Show this message and <span class="built_in">exit</span>.</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  sync</span><br><span class="line"></span><br><span class="line">$ tool.py --debug sync</span><br><span class="line">Debug mode is on</span><br><span class="line">Syncing</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们将函数 <code>cli</code> 定义为一个组，把函数 <code>sync</code> 定义为这个组内的子命令。当我们调用 <code>tool.py --debug sync</code> 命令时，会依次触发 <code>cli</code> 和 <code>sync</code> 的处理逻辑（也就是命令的回调）。</p>
<h3 id="嵌套处理和上下文"><a href="#嵌套处理和上下文" class="headerlink" title="嵌套处理和上下文"></a>嵌套处理和上下文</h3><p>从上面的例子可以看到，命令组 <code>cli</code> 接收的参数和子命令 <code>sync</code> 彼此独立。但是有时我们希望在子命令中能获取到命令组的参数，这就可以用 <a href="https://click.palletsprojects.com/en/7.x/api/#click.Context" target="_blank" rel="noopener">Context</a> 来实现。</p>
<p>每当命令被调用时，<code>click</code> 会创建新的上下文，并链接到父上下文。通常，我们是看不到上下文信息的。但我们可以通过 <a href="https://click.palletsprojects.com/en/7.x/api/#click.pass_context" target="_blank" rel="noopener">pass_context</a> 装饰器来显式让 <code>click</code> 传递上下文，此变量会作为第一个参数进行传递。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.group()</span></span><br><span class="line"><span class="meta">@click.option('--debug/--no-debug', default=False)</span></span><br><span class="line"><span class="meta">@click.pass_context</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">(ctx, debug)</span>:</span></span><br><span class="line">    <span class="comment"># 确保 ctx.obj 存在并且是个 dict。 (以防 `cli()` 指定 obj 为其他类型</span></span><br><span class="line">    ctx.ensure_object(dict)</span><br><span class="line"></span><br><span class="line">    ctx.obj[<span class="string">'DEBUG'</span>] = debug</span><br><span class="line"></span><br><span class="line"><span class="meta">@cli.command()</span></span><br><span class="line"><span class="meta">@click.pass_context</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sync</span><span class="params">(ctx)</span>:</span></span><br><span class="line">    click.echo(<span class="string">'Debug is %s'</span> % (ctx.obj[<span class="string">'DEBUG'</span>] <span class="keyword">and</span> <span class="string">'on'</span> <span class="keyword">or</span> <span class="string">'off'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    cli(obj=&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>在上面的示例中：</p>
<ul>
<li>通过为命令组 <code>cli</code> 和子命令 <code>sync</code> 指定装饰器 <code>click.pass_context</code>，两个函数的第一个参数都是 <code>ctx</code> 上下文</li>
<li>在命令组 <code>cli</code> 中，给上下文的 <code>obj</code> 变量（字典）赋值</li>
<li>在子命令 <code>sync</code> 中通过 <code>ctx.obj[&#39;DEBUG&#39;]</code> 获得上一步的参数</li>
<li>通过这种方式完成了从命令组到子命令的参数传递</li>
</ul>
<h3 id="不使用命令来调用命令组"><a href="#不使用命令来调用命令组" class="headerlink" title="不使用命令来调用命令组"></a>不使用命令来调用命令组</h3><p>默认情况下，调用子命令的时候才会调用命令组。而有时你可能想直接调用命令组，通过指定 <code>click.group</code> 的 <code>invoke_without_command=True</code> 来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.group(invoke_without_command=True)</span></span><br><span class="line"><span class="meta">@click.pass_context</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">(ctx)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> ctx.invoked_subcommand <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        click.echo(<span class="string">'I was invoked without subcommand'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        click.echo(<span class="string">'I am about to invoke %s'</span> % ctx.invoked_subcommand)</span><br><span class="line"></span><br><span class="line"><span class="meta">@cli.command()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sync</span><span class="params">()</span>:</span></span><br><span class="line">    click.echo(<span class="string">'The subcommand'</span>)</span><br></pre></td></tr></table></figure>
<p>调用命令有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tool</span><br><span class="line">I was invoked without subcommand</span><br><span class="line">$ tool sync</span><br><span class="line">I am about to invoke sync</span><br><span class="line">The subcommand</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过 <code>ctx.invoked_subcommand</code> 来判断是否由子命令触发，针对两种情况打印日志。</p>
<h3 id="自定义命令组-多命令"><a href="#自定义命令组-多命令" class="headerlink" title="自定义命令组/多命令"></a>自定义命令组/多命令</h3><p>除了使用 <a href="https://click.palletsprojects.com/en/7.x/api/#click.group" target="_blank" rel="noopener">click.group</a> 来定义命令组外，你还可以自定义命令组（也就是多命令），这样你就可以延迟加载子命令，这会很有用。</p>
<p>自定义多命令需要实现 <code>list_commands</code> 和 <code>get_command</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> click</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">plugin_folder = os.path.join(os.path.dirname(__file__), <span class="string">'commands'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCLI</span><span class="params">(click.MultiCommand)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">list_commands</span><span class="params">(self, ctx)</span>:</span></span><br><span class="line">        rv = []  <span class="comment"># 命令名称列表</span></span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(plugin_folder):</span><br><span class="line">            <span class="keyword">if</span> filename.endswith(<span class="string">'.py'</span>):</span><br><span class="line">                rv.append(filename[:<span class="number">-3</span>])</span><br><span class="line">        rv.sort()</span><br><span class="line">        <span class="keyword">return</span> rv</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_command</span><span class="params">(self, ctx, name)</span>:</span></span><br><span class="line">        ns = &#123;&#125;</span><br><span class="line">        fn = os.path.join(plugin_folder, name + <span class="string">'.py'</span>)  <span class="comment"># 命令对应的 Python 文件</span></span><br><span class="line">        <span class="keyword">with</span> open(fn) <span class="keyword">as</span> f:</span><br><span class="line">            code = compile(f.read(), fn, <span class="string">'exec'</span>)</span><br><span class="line">            eval(code, ns, ns)</span><br><span class="line">        <span class="keyword">return</span> ns[<span class="string">'cli'</span>]</span><br><span class="line"></span><br><span class="line">cli = MyCLI(help=<span class="string">'This tool\'s subcommands are loaded from a '</span></span><br><span class="line">            <span class="string">'plugin folder dynamically.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价方式是通过 click.command 装饰器，指定 cls=MyCLI</span></span><br><span class="line"><span class="comment"># @click.command(cls=MyCLI)</span></span><br><span class="line"><span class="comment"># def cli():</span></span><br><span class="line"><span class="comment">#     pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    cli()</span><br></pre></td></tr></table></figure>
<h3 id="合并命令组-多命令"><a href="#合并命令组-多命令" class="headerlink" title="合并命令组/多命令"></a>合并命令组/多命令</h3><p>当有多个命令组，每个命令组中有一些命令，你想把所有的命令合并在一个集合中时，<code>click.CommandCollection</code> 就派上了用场：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@click.group()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@cli1.command()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Command on cli1"""</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@click.group()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@cli2.command()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cmd2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Command on cli2"""</span></span><br><span class="line"></span><br><span class="line">cli = click.CommandCollection(sources=[cli1, cli2])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    cli()</span><br></pre></td></tr></table></figure>
<p>调用命令有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cli --<span class="built_in">help</span></span><br><span class="line">Usage: cli [OPTIONS] COMMAND [ARGS]...</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --<span class="built_in">help</span>  Show this message and <span class="built_in">exit</span>.</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  cmd1  Command on cli1</span><br><span class="line">  cmd2  Command on cli2</span><br></pre></td></tr></table></figure>
<p>从上面的示例可以看出，<code>cmd1</code> 和 <code>cmd2</code> 分别属于 <code>cli1</code> 和 <code>cli2</code>，通过 <code>click.CommandCollection</code> 可以将这些子命令合并在一起，将其能力提供个同一个命令程序。</p>
<p>Tips：如果多个命令组中定义了同样的子命令，那么取第一个命令组中的子命令。</p>
<h3 id="链式命令组-多命令"><a href="#链式命令组-多命令" class="headerlink" title="链式命令组/多命令"></a>链式命令组/多命令</h3><p>有时单级子命令可能满足不了你的需求，你甚至希望能有多级子命令。典型地，<code>setuptools</code> 包中就支持多级/链式子命令： <code>setup.py sdist bdist_wheel upload</code>。在 click 3.0 之后，实现链式命令组变得非常简单，只需在 <code>click.group</code> 中指定 <code>chain=True</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.group(chain=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@cli.command('sdist')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sdist</span><span class="params">()</span>:</span></span><br><span class="line">    click.echo(<span class="string">'sdist called'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@cli.command('bdist_wheel')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bdist_wheel</span><span class="params">()</span>:</span></span><br><span class="line">    click.echo(<span class="string">'bdist_wheel called'</span>)</span><br></pre></td></tr></table></figure>
<p>调用命令则有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ setup.py sdist bdist_wheel</span><br><span class="line">sdist called</span><br><span class="line">bdist_wheel called</span><br></pre></td></tr></table></figure>
<h3 id="命令组-多命令管道"><a href="#命令组-多命令管道" class="headerlink" title="命令组/多命令管道"></a>命令组/多命令管道</h3><p>链式命令组中一个常见的场景就是实现管道，这样在上一个命令处理好后，可将结果传给下一个命令处理。</p>
<p>实现命令组管道的要点是让每个命令返回一个处理函数，然后编写一个总的管道调度函数（并由 <code>MultiCommand.resultcallback()</code> 装饰）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.group(chain=True, invoke_without_command=True)</span></span><br><span class="line"><span class="meta">@click.option('-i', '--input', type=click.File('r'))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">(input)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@cli.resultcallback()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process_pipeline</span><span class="params">(processors, input)</span>:</span></span><br><span class="line">    iterator = (x.rstrip(<span class="string">'\r\n'</span>) <span class="keyword">for</span> x <span class="keyword">in</span> input)</span><br><span class="line">    <span class="keyword">for</span> processor <span class="keyword">in</span> processors:</span><br><span class="line">        iterator = processor(iterator)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> iterator:</span><br><span class="line">        click.echo(item)</span><br><span class="line"></span><br><span class="line"><span class="meta">@cli.command('uppercase')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_uppercase</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processor</span><span class="params">(iterator)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> iterator:</span><br><span class="line">            <span class="keyword">yield</span> line.upper()</span><br><span class="line">    <span class="keyword">return</span> processor</span><br><span class="line"></span><br><span class="line"><span class="meta">@cli.command('lowercase')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_lowercase</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processor</span><span class="params">(iterator)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> iterator:</span><br><span class="line">            <span class="keyword">yield</span> line.lower()</span><br><span class="line">    <span class="keyword">return</span> processor</span><br><span class="line"></span><br><span class="line"><span class="meta">@cli.command('strip')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_strip</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">processor</span><span class="params">(iterator)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> iterator:</span><br><span class="line">            <span class="keyword">yield</span> line.strip()</span><br><span class="line">    <span class="keyword">return</span> processor</span><br></pre></td></tr></table></figure>
<p>在上面的示例中：</p>
<ul>
<li>将 <code>cli</code> 定义为了链式命令组，并且指定 invoke_without_command=True，也就意味着可以不传子命令来触发命令组</li>
<li>定义了三个命令处理函数，分别对应 <code>uppercase</code>、<code>lowercase</code> 和 <code>strip</code> 命令</li>
<li>在管道调度函数 <code>process_pipeline</code> 中，将输入 <code>input</code> 变成生成器，然后调用处理函数（实际输入几个命令，就有几个处理函数）进行处理</li>
</ul>
<h3 id="覆盖默认值"><a href="#覆盖默认值" class="headerlink" title="覆盖默认值"></a>覆盖默认值</h3><p>默认情况下，参数的默认值是从通过装饰器参数 <code>default</code> 定义。我们还可以通过 <code>Context.default_map</code> 上下文字典来覆盖默认值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.group()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@cli.command()</span></span><br><span class="line"><span class="meta">@click.option('--port', default=8000)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runserver</span><span class="params">(port)</span>:</span></span><br><span class="line">    click.echo(<span class="string">'Serving on http://127.0.0.1:%d/'</span> % port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    cli(default_map=&#123;</span><br><span class="line">        <span class="string">'runserver'</span>: &#123;</span><br><span class="line">            <span class="string">'port'</span>: <span class="number">5000</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，通过在 <code>cli</code> 中指定 <code>default_map</code> 变可覆盖命令（一级键）的选项（二级键）默认值（二级键的值）。</p>
<p>我们还可以在 <code>click.group</code> 中指定 <code>context_settings</code> 来达到同样的目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">CONTEXT_SETTINGS = dict(</span><br><span class="line">    default_map=&#123;<span class="string">'runserver'</span>: &#123;<span class="string">'port'</span>: <span class="number">5000</span>&#125;&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.group(context_settings=CONTEXT_SETTINGS)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@cli.command()</span></span><br><span class="line"><span class="meta">@click.option('--port', default=8000)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runserver</span><span class="params">(port)</span>:</span></span><br><span class="line">    click.echo(<span class="string">'Serving on http://127.0.0.1:%d/'</span> % port)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    cli()</span><br></pre></td></tr></table></figure>
<p>调用命令则有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cli runserver</span><br><span class="line">Serving on http://127.0.0.1:5000/</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文首先介绍了命令的回调调用、上下文，再进一步介绍命令组的自定义、合并、链接、管道等功能，了解到了 <code>click</code> 的强大。而命令组中更加高阶的能力（<a href="https://click.palletsprojects.com/en/7.x/commands/#command-return-values" target="_blank" rel="noopener">如命令返回值</a>）则可看官方文档进一步了解。</p>
<p>我们通过介绍 <code>click</code> 的参数、选项和命令已经能够完全实现命令行程序的所有功能。而 <code>click</code> 还为我们提供了许多锦上添花的功能，比如实用工具、参数自动补全等，我们将在下节详细介绍。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>click</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 壹周刊 001</title>
    <url>/2019/11/19/Python-%E5%A3%B9%E5%91%A8%E5%88%8A-001/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本周开始，每周将会为大家带来“壹周刊”系列，内容主要来自 Awesome Python Newsletter、Python Weekly、PyCoder’s Weekly 和 Planet Python 等。</p>
<p>关于周刊中提到的文章，如果大家对里面的知识点感兴趣，欢迎提出来，我们也可能专门写篇文章进行深度解读。</p>
<p>好了，废话不多说，看正文~</p>
<a id="more"></a>
<h2 id="新鲜事儿"><a href="#新鲜事儿" class="headerlink" title="新鲜事儿"></a>新鲜事儿</h2><p><a href="https://octoverse.github.com/" target="_blank" rel="noopener">八度宇宙的状态</a></p>
<p>说的这么玄乎，其实是 GitHub 过去一年的统计报告，从开发人员、地域、社区、项目等方面进行汇总，值得一看~</p>
<p>划重点：Python 超越 Java，成为 GitHub 第二受欢迎的语言！</p>
<p><a href="http://pyfound.blogspot.com/2019/11/seeking-developers-for-paid-contract.html" target="_blank" rel="noopener">Python 基金会包管理工作组将获得 40 万美元赠款，用于改善 pip 的依赖项解析程序</a></p>
<p>PSF 将支持研发下一代 pip 依赖解析器，正在招募人选，你是不是那个命中注定的人呢？</p>
<h2 id="好文共赏"><a href="#好文共赏" class="headerlink" title="好文共赏"></a>好文共赏</h2><p><a href="https://dev.to/django_stars/development-of-apis-with-django-rest-framework-499o" target="_blank" rel="noopener">使用 Django REST 框架开发 API</a></p>
<p><a href="https://dev.to/singh1114/how-to-write-cleaner-functions-j4m" target="_blank" rel="noopener">如何编写整洁的函数</a></p>
<p><a href="https://articles.life4web.ru/python/contracts/" target="_blank" rel="noopener">合约驱动开发</a></p>
<p><a href="https://medium.com/python4you/5-scraping-tips-1827f27197b5" target="_blank" rel="noopener">5 个爬虫技巧</a></p>
<p><a href="https://realpython.com/courses/thinking-recursively-python/" target="_blank" rel="noopener">Python 中的递归思想</a></p>
<p><a href="https://realpython.com/list-comprehension-python/" target="_blank" rel="noopener">什么时候使用列表推导</a></p>
<p><a href="https://asthasr.github.io/posts/parsing-in-python/" target="_blank" rel="noopener">Python 中的“解析”</a></p>
<p><a href="https://blog.ganssle.io/articles/2019/11/utcnow.html" target="_blank" rel="noopener">停止使用 utcnow 和 utcfromtimestamp</a></p>
<p><a href="https://www.marsja.se/how-to-handle-coroutines-with-asyncio-in-python/" target="_blank" rel="noopener">如何在 Python 中使用 asyncio 处理协程</a></p>
<h2 id="赞视频"><a href="#赞视频" class="headerlink" title="赞视频"></a>赞视频</h2><p><a href="https://www.youtube.com/watch?v=eyKwPyOqMg4" target="_blank" rel="noopener">了解卷积神经网络：制作一个手写数字计算器</a> （来自 youtube）</p>
<p><a href="https://www.youtube.com/watch?v=MgBgMyYROTE" target="_blank" rel="noopener">使用 Jupter 学习 Python 性能分析：了解代码资源占用量</a> （来自 youtube）</p>
<p>酷开源<br><a href>annoy</a></p>
<p>Annoy（<a href="http://en.wikipedia.org/wiki/Nearest_neighbor_search#Approximate_nearest_neighbor" target="_blank" rel="noopener">Approximate Nearest Neighbors</a> Oh Yeah，近似最近邻居 Oh Yeah）是一个带有 Python 绑定的 C ++库，用于搜索空间中接近给定查询点的点。它还会创建大型的基于文件的只读数据结构，这些数据结构被映射到内存中，以便许多进程可以共享相同的数据。</p>
<p><a href="https://github.com/awesto/django-shop" target="_blank" rel="noopener">django-shop</a></p>
<p>基于 django 的商店系统。</p>
<p><a href="https://github.com/WallarooLabs/wallaroo" target="_blank" rel="noopener">wallaroo</a></p>
<p>快速的分布式流处理框架。</p>
<p><a href="https://github.com/python-trio/trio" target="_blank" rel="noopener">trio</a></p>
<p>友好的用于异步并发和 I/O 的 Python 库。</p>
<p><a href="https://github.com/scikit-image/scikit-image" target="_blank" rel="noopener">scikit-image</a></p>
<p>用于（科学）图像处理的 Python 库。</p>
<p><a href="https://github.com/joke2k/faker" target="_blank" rel="noopener">faker</a></p>
<p>用于生成假数据的 Python 库。</p>
<p><a href="https://github.com/lk-geimfari/mimesis" target="_blank" rel="noopener">mimesis</a></p>
<p>Mimesis 是一种快速且极其易于使用的 Python 软件包，可以生成各种目的、多种语言的假数据。</p>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>壹周刊</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>壹周刊</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：深入 click（二）</title>
    <url>/2019/11/17/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9A%E6%B7%B1%E5%85%A5-click%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇文章中，我们介绍了 <code>click</code> 中的“参数”，本文将继续深入了解 <code>click</code>，着重讲解它的“选项”。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>通过 <code>click.option</code> 可以给命令增加选项，并通过配置函数的参数来配置不同功能的选项。</p>
<h3 id="给选项命名"><a href="#给选项命名" class="headerlink" title="给选项命名"></a>给选项命名</h3><p><code>click.option</code> 中的命令规则可参考<a href="https://click.palletsprojects.com/en/7.x/parameters/#parameter-names" target="_blank" rel="noopener">参数名称</a>。它接受的前两个参数为长、短选项（顺序随意），其中：</p>
<ul>
<li>长选项以 “–” 开头，比如 “–string-to-echo”</li>
<li>短选项以 “-” 开头，比如 “-s”</li>
</ul>
<p>第三个参数为选项参数的名称，如果不指定，将会使用长选项的下划线形式名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('-s', '--string-to-echo')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(string_to_echo)</span>:</span></span><br><span class="line">    click.echo(string_to_echo)</span><br></pre></td></tr></table></figure>
<p>显示指定为 string</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('-s', '--string-to-echo', 'string')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span><span class="params">(string)</span>:</span></span><br><span class="line">    click.echo(string)</span><br></pre></td></tr></table></figure>
<h3 id="基本值选项"><a href="#基本值选项" class="headerlink" title="基本值选项"></a>基本值选项</h3><p>值选项是非常常用的选项，它接受一个值。如果在命令行中提供了值选项，则需要提供对应的值；反之则使用默认值。若没在 <code>click.option</code> 中指定默认值，则默认值为 <code>None</code>，且该选项的类型为 <a href="https://click.palletsprojects.com/en/7.x/api/#click.STRING" target="_blank" rel="noopener">STRING</a>；反之，则选项类型为默认值的类型。</p>
<p>比如，提供默认值为 1，则选项类型为 <a href="https://click.palletsprojects.com/en/7.x/api/#click.INT" target="_blank" rel="noopener">INT</a>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--n', default=1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dots</span><span class="params">(n)</span>:</span></span><br><span class="line">    click.echo(<span class="string">'.'</span> * n)</span><br></pre></td></tr></table></figure>
<p>如果要求选项为必填，则可指定 <code>click.option</code> 的 <code>required=True</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--n', required=True, type=int)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dots</span><span class="params">(n)</span>:</span></span><br><span class="line">    click.echo(<span class="string">'.'</span> * n)</span><br></pre></td></tr></table></figure>
<p>如果选项名称和 Python 中的关键字冲突，则可以显式的指定选项名称。比如将 <code>--from</code> 的名称设置为 <code>from_</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--from', '-f', 'from_')</span></span><br><span class="line"><span class="meta">@click.option('--to', '-t')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reserved_param_name</span><span class="params">(from_, to)</span>:</span></span><br><span class="line">    click.echo(<span class="string">f'from <span class="subst">&#123;from_&#125;</span> to <span class="subst">&#123;to&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<p>如果要在帮助中显式默认值，则可指定 <code>click.option</code> 的 <code>show_default=True</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--n', default=1, show_default=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dots</span><span class="params">(n)</span>:</span></span><br><span class="line">    click.echo(<span class="string">'.'</span> * n)</span><br></pre></td></tr></table></figure>
<p>在命令行中调用则有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dots --<span class="built_in">help</span></span><br><span class="line">Usage: dots [OPTIONS]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --n INTEGER  [default: 1]</span><br><span class="line">  --<span class="built_in">help</span>       Show this message and <span class="built_in">exit</span>.</span><br></pre></td></tr></table></figure>
<h3 id="多值选项"><a href="#多值选项" class="headerlink" title="多值选项"></a>多值选项</h3><p>有时，我们会希望命令行中一个选项能接收多个值，通过指定 <code>click.option</code> 中的 <code>nargs</code> 参数（必须是大于等于 0）。这样，接收的多值选项就会变成一个元组。</p>
<p>比如，在下面的示例中，当通过 <code>--pos</code> 指定多个值时，<code>pos</code> 变量就是一个元组，里面的每个元素是一个 <code>float</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--pos', nargs=2, type=float)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findme</span><span class="params">(pos)</span>:</span></span><br><span class="line">    click.echo(pos)</span><br></pre></td></tr></table></figure>
<p>在命令行中调用则有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ findme --pos 2.0 3.0</span><br><span class="line">(1.0, 2.0)</span><br></pre></td></tr></table></figure>
<p>有时，通过同一选项指定的多个值得类型可能不同，这个时候可以指定 <code>click.option</code> 中的 <code>type=(类型1, 类型2, ...)</code> 来实现。而由于元组的长度同时表示了值的数量，所以就无须指定 <code>nargs</code> 参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--item', type=(str, int))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">putitem</span><span class="params">(item)</span>:</span></span><br><span class="line">    click.echo(<span class="string">'name=%s id=%d'</span> % item)</span><br></pre></td></tr></table></figure>
<p>在命令行中调用则有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ putitem --item peter 1338</span><br><span class="line">name=peter id=1338</span><br></pre></td></tr></table></figure>
<h3 id="多选项"><a href="#多选项" class="headerlink" title="多选项"></a>多选项</h3><p>不同于多值选项是通过一个选项指定多个值，多选项则是使用多个相同选项分别指定值，通过 <code>click.option</code> 中的 <code>multiple=True</code> 来实现。</p>
<p>当我们定义如下多选项：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--message', '-m', multiple=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">commit</span><span class="params">(message)</span>:</span></span><br><span class="line">    click.echo(<span class="string">'\n'</span>.join(message))</span><br></pre></td></tr></table></figure>
<p>便可以指定任意数量个选项来指定值，获取到的 <code>message</code> 是一个元组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ commit -m foo -m bar --message baz</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure>
<h3 id="计值选项"><a href="#计值选项" class="headerlink" title="计值选项"></a>计值选项</h3><p>有时我们可能需要获得选项的数量，那么可以指定 <code>click.option</code> 中的 <code>count=True</code> 来实现。</p>
<p>最常见的使用场景就是指定多个 <code>--verbose</code> 或 <code>-v</code> 选项来表示输出内容的详细程度。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('-v', '--verbose', count=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(verbose)</span>:</span></span><br><span class="line">    click.echo(<span class="string">f'Verbosity: <span class="subst">&#123;verbose&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<p>在命令行中调用则有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">log</span> -vvv</span><br><span class="line">Verbosity: 3</span><br></pre></td></tr></table></figure>
<p>通过上面的例子，<code>verbose</code> 就是数字，表示 <code>-v</code> 选项的数量，由此可以进一步使用该值来控制日志的详细程度。</p>
<h3 id="布尔选项"><a href="#布尔选项" class="headerlink" title="布尔选项"></a>布尔选项</h3><p>布尔选项用来表示真或假，它有多种实现方式：</p>
<ul>
<li>通过 <code>click.option</code> 的 <code>is_flag=True</code> 参数来实现：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--shout', is_flag=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(shout)</span>:</span></span><br><span class="line">    rv = sys.platform</span><br><span class="line">    <span class="keyword">if</span> shout:</span><br><span class="line">        rv = rv.upper() + <span class="string">'!!!!111'</span></span><br><span class="line">    click.echo(rv)</span><br></pre></td></tr></table></figure>
<p>在命令行中调用则有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ info --shout</span><br><span class="line">LINUX!!!!111</span><br></pre></td></tr></table></figure>
<ul>
<li>通过在 <code>click.option</code> 的选项定义中使用 <code>/</code> 分隔表示真假两个选项来实现：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--shout/--no-shout', default=False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(shout)</span>:</span></span><br><span class="line">    rv = sys.platform</span><br><span class="line">    <span class="keyword">if</span> shout:</span><br><span class="line">        rv = rv.upper() + <span class="string">'!!!!111'</span></span><br><span class="line">    click.echo(rv)</span><br></pre></td></tr></table></figure>
<p>在命令行中调用则有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ info --shout</span><br><span class="line">LINUX!!!!111</span><br><span class="line">$ info --no-shout</span><br><span class="line">linux</span><br></pre></td></tr></table></figure>
<p>在 Windows 中，一个选项可以以 <code>/</code> 开头，这样就会真假选项的分隔符冲突了，这个时候可以使用 <code>;</code> 进行分隔：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('/debug;/no-debug')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log</span><span class="params">(debug)</span>:</span></span><br><span class="line">    click.echo(<span class="string">f'debug=<span class="subst">&#123;debug&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    log()</span><br></pre></td></tr></table></figure>
<p>在 cmd 中调用则有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">log</span> /debug</span><br><span class="line">debug=True</span><br></pre></td></tr></table></figure>
<h3 id="特性切换选项"><a href="#特性切换选项" class="headerlink" title="特性切换选项"></a>特性切换选项</h3><p>所谓特性切换就是切换同一个操作对象的不同特性，比如指定 <code>--upper</code> 就让输出大写，指定 <code>--lower</code> 就让输出小写。这么来看，布尔值其实是特性切换的一个特例。</p>
<p>要实现特性切换选项，需要让多个选项都有相同的参数名称，并且定义它们的标记值 <code>flag_value</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--upper', 'transformation', flag_value='upper',</span></span><br><span class="line">              default=<span class="keyword">True</span>)</span><br><span class="line"><span class="meta">@click.option('--lower', 'transformation', flag_value='lower')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(transformation)</span>:</span></span><br><span class="line">    click.echo(getattr(sys.platform, transformation)())</span><br></pre></td></tr></table></figure>
<p>在命令行中调用则有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ info --upper</span><br><span class="line">LINUX</span><br><span class="line">$ info --lower</span><br><span class="line">linux</span><br><span class="line">$ info</span><br><span class="line">LINUX</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>--upper</code> 和 <code>--lower</code> 都有相同的参数值 <code>transformation</code>：</p>
<ul>
<li>当指定 <code>--upper</code> 时，<code>transformation</code> 就是 <code>--upper</code> 选项的标记值 <code>upper</code></li>
<li>当指定 <code>--lower</code> 时，<code>transformation</code> 就是 <code>--lower</code> 选项的标记值 <code>lower</code></li>
</ul>
<p>进而就可以做进一步的业务逻辑处理。</p>
<h3 id="选择项选项"><a href="#选择项选项" class="headerlink" title="选择项选项"></a>选择项选项</h3><p><code>选择项选项</code> 和 上篇文章中介绍的 <code>选择项参数</code> 类似，只不过是限定选项内容，依旧是通过 <code>type=click.Choice</code> 实现。此外，<code>case_sensitive=False</code> 还可以忽略选项内容的大小写。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--hash-type',</span></span><br><span class="line">              type=click.Choice([<span class="string">'MD5'</span>, <span class="string">'SHA1'</span>], case_sensitive=<span class="keyword">False</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">digest</span><span class="params">(hash_type)</span>:</span></span><br><span class="line">    click.echo(hash_type)</span><br></pre></td></tr></table></figure>
<p>在命令行中调用则有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ digest --<span class="built_in">hash</span>-type=MD5</span><br><span class="line">MD5</span><br><span class="line"></span><br><span class="line">$ digest --<span class="built_in">hash</span>-type=md5</span><br><span class="line">MD5</span><br><span class="line"></span><br><span class="line">$ digest --<span class="built_in">hash</span>-type=foo</span><br><span class="line">Usage: digest [OPTIONS]</span><br><span class="line">Try <span class="string">"digest --help"</span> <span class="keyword">for</span> <span class="built_in">help</span>.</span><br><span class="line"></span><br><span class="line">Error: Invalid value <span class="keyword">for</span> <span class="string">"--hash-type"</span>: invalid choice: foo. (choose from MD5, SHA1)</span><br><span class="line"></span><br><span class="line">$ digest --<span class="built_in">help</span></span><br><span class="line">Usage: digest [OPTIONS]</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --<span class="built_in">hash</span>-type [MD5|SHA1]</span><br><span class="line">  --<span class="built_in">help</span>                  Show this message and <span class="built_in">exit</span>.</span><br></pre></td></tr></table></figure>
<h3 id="提示选项"><a href="#提示选项" class="headerlink" title="提示选项"></a>提示选项</h3><p>顾名思义，当提供了选项却没有提供对应的值时，会提示用户输入值。这种交互式的方式会让命令行变得更加友好。通过指定 <code>click.option</code> 中的 <code>prompt</code> 可以实现。</p>
<ul>
<li>当 <code>prompt=True</code> 时，提示内容为选项的参数名称</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--name', prompt=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    click.echo(<span class="string">f'Hello <span class="subst">&#123;name&#125;</span>!'</span>)</span><br></pre></td></tr></table></figure>
<p>在命令行调用则有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hello --name=John</span><br><span class="line">Hello John!</span><br><span class="line">$ hello</span><br><span class="line">Name: John</span><br><span class="line">Hello John!</span><br></pre></td></tr></table></figure>
<ul>
<li>当 <code>prompt=&#39;Your name please&#39;</code> 时，提示内容为指定内容</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--name', prompt='Your name please')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    click.echo(<span class="string">f'Hello <span class="subst">&#123;name&#125;</span>!'</span>)</span><br></pre></td></tr></table></figure>
<p>在命令行中调用则有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hello</span><br><span class="line">Your name please: John</span><br><span class="line">Hello John!</span><br></pre></td></tr></table></figure>
<p>基于提示选项，我们还可以指定 <code>hide_input=True</code> 来隐藏输入，<code>confirmation_prompt=True</code> 来让用户进行二次输入，这非常适合输入密码的场景。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--password', prompt=True, hide_input=True,</span></span><br><span class="line">              confirmation_prompt=<span class="keyword">True</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(password)</span>:</span></span><br><span class="line">    click.echo(<span class="string">f'Encrypting password to <span class="subst">&#123;password.encode(<span class="string">"rot13"</span>)&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<p>当然，也可以直接使用 <code>click.password_option</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.password_option()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">encrypt</span><span class="params">(password)</span>:</span></span><br><span class="line">    click.echo(<span class="string">f'Encrypting password to <span class="subst">&#123;password.encode(<span class="string">"rot13"</span>)&#125;</span>'</span>)</span><br></pre></td></tr></table></figure>
<p>我们还可以给提示选项设置默认值，通过 <code>default</code> 参数进行设置，如果被设置为函数，则可以实现动态默认值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--username', prompt=True,</span></span><br><span class="line">              default=<span class="keyword">lambda</span>: os.environ.get(<span class="string">'USER'</span>, <span class="string">''</span>))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(username)</span>:</span></span><br><span class="line">    print(<span class="string">"Hello,"</span>, username)</span><br></pre></td></tr></table></figure>
<p>详情请阅读 <a href="https://click.palletsprojects.com/en/7.x/options/#dynamic-defaults-for-prompts" target="_blank" rel="noopener">Dynamic Defaults for Prompts</a>。</p>
<h3 id="范围选项"><a href="#范围选项" class="headerlink" title="范围选项"></a>范围选项</h3><p>如果希望选项的值在某个范围内，就可以使用范围选项，通过指定 <code>type=click.IntRange</code> 来实现。它有两种模式：</p>
<ul>
<li>默认模式（非强制模式），如果值不在区间范围内将会引发一个错误。如 <code>type=click.IntRange(0, 10)</code> 表示范围是 [0, 10]，超过该范围报错</li>
<li>强制模式，如果值不在区间范围内，将会强制选取一个区间临近值。如 <code>click.IntRange(0, None, clamp=True)</code> 表示范围是 [0, +∞)，小于 0 则取 0，大于 20 则取 20。其中 <code>None</code> 表示没有限制</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--count', type=click.IntRange(0, None, clamp=True))</span></span><br><span class="line"><span class="meta">@click.option('--digit', type=click.IntRange(0, 10))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repeat</span><span class="params">(count, digit)</span>:</span></span><br><span class="line">    click.echo(str(digit) * count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    repeat()</span><br></pre></td></tr></table></figure>
<p>在命令行中调用则有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ repeat --count=1000 --digit=5</span><br><span class="line">55555555555555555555</span><br><span class="line">$ repeat --count=1000 --digit=12</span><br><span class="line">Usage: repeat [OPTIONS]</span><br><span class="line"></span><br><span class="line">Error: Invalid value <span class="keyword">for</span> <span class="string">"--digit"</span>: 12 is not <span class="keyword">in</span> the valid range of 0 to 10.</span><br></pre></td></tr></table></figure>
<h3 id="回调和优先"><a href="#回调和优先" class="headerlink" title="回调和优先"></a>回调和优先</h3><p><strong>回调</strong><br>通过 <code>click.option</code> 中的 <code>callback</code> 可以指定选项的回调，它会在该选项被解析后调用。回调函数的签名如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(ctx, param, value)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li>ctx 是命令的上下文 <a href="https://click.palletsprojects.com/en/7.x/api/#click.Context" target="_blank" rel="noopener">click.Context</a></li>
<li>param 为选项变量 <a href="https://click.palletsprojects.com/en/7.x/api/#click.Option" target="_blank" rel="noopener">click.Option</a></li>
<li>value 为选项的值</li>
</ul>
<p>使用回调函数可以完成额外的参数校验逻辑。比如，通过 –rolls 的选项来指定摇骰子的方式，内容为“{N}d{M}”，表示 M 面的骰子摇 N 次，N 和 M 都是数字。在真正的处理 rolls 前，我们需要通过回调函数来校验它的格式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate_rolls</span><span class="params">(ctx, param, value)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        rolls, dice = map(int, value.split(<span class="string">'d'</span>, <span class="number">2</span>))</span><br><span class="line">        <span class="keyword">return</span> (dice, rolls)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">raise</span> click.BadParameter(<span class="string">'rolls need to be in format NdM'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--rolls', callback=validate_rolls, default='1d6')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">roll</span><span class="params">(rolls)</span>:</span></span><br><span class="line">    click.echo(<span class="string">'Rolling a %d-sided dice %d time(s)'</span> % rolls)</span><br></pre></td></tr></table></figure>
<p>这样，当我们输入错误格式时，变会校验不通过：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roll --rolls=42</span><br><span class="line">Usage: roll [OPTIONS]</span><br><span class="line"></span><br><span class="line">Error: Invalid value <span class="keyword">for</span> <span class="string">"--rolls"</span>: rolls need to be <span class="keyword">in</span> format NdM</span><br></pre></td></tr></table></figure>
<p>输入正确格式时，则正常输出信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ roll --rolls=2d12</span><br><span class="line">Rolling a 12-sided dice 2 time(s)</span><br></pre></td></tr></table></figure>
<p><strong>优先</strong><br>通过 <code>click.option</code> 中的 <code>is_eager</code> 可以让该选项成为优先选项，这意味着它会先于所有选项处理。</p>
<p>利用回调和优先选项，我们就可以很好地实现 <code>--version</code> 选项。不论命令行中写了多少选项和参数，只要包含了 <code>--version</code>，我们就希望它打印版本就退出，而不执行其他选项的逻辑，那么就需要让它成为优先选项，并且在回调函数中打印版本。</p>
<p>此外，在 <code>click</code> 中每个选项都对应到命令处理函数的同名参数，如果不想把该选项传递到处理函数中，则需要指定 <code>expose_value=True</code>，于是有：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_version</span><span class="params">(ctx, param, value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> value <span class="keyword">or</span> ctx.resilient_parsing:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    click.echo(<span class="string">'Version 1.0'</span>)</span><br><span class="line">    ctx.exit()</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--version', is_flag=True, callback=print_version,</span></span><br><span class="line">              expose_value=<span class="keyword">False</span>, is_eager=<span class="keyword">True</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    click.echo(<span class="string">'Hello World!'</span>)</span><br></pre></td></tr></table></figure>
<p>当然 <code>click</code> 提供了便捷的 <code>click.version_option</code> 来实现 <code>--version</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.version_option(version='0.1.0')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="Yes-选项"><a href="#Yes-选项" class="headerlink" title="Yes 选项"></a>Yes 选项</h3><p>基于前面的学习，我们可以实现 Yes 选项，也就是对于某些操作，不提供 <code>--yes</code> 则进行二次确认，提供了则直接操作：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">abort_if_false</span><span class="params">(ctx, param, value)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> value:</span><br><span class="line">        ctx.abort()</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--yes', is_flag=True, callback=abort_if_false,</span></span><br><span class="line">              expose_value=<span class="keyword">False</span>,</span><br><span class="line">              prompt=<span class="string">'Are you sure you want to drop the db?'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropdb</span><span class="params">()</span>:</span></span><br><span class="line">    click.echo(<span class="string">'Dropped all tables!'</span>)</span><br></pre></td></tr></table></figure>
<p>当然 <code>click</code> 提供了便捷的 <code>click.confirmation_option</code> 来实现 Yes 选项：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.confirmation_option(prompt='Are you sure you want to drop the db?')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dropdb</span><span class="params">()</span>:</span></span><br><span class="line">    click.echo(<span class="string">'Dropped all tables!'</span>)</span><br></pre></td></tr></table></figure>
<p>在命令行中调用则有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ dropdb</span><br><span class="line">Are you sure you want to drop the db? [y/N]: n</span><br><span class="line">Aborted!</span><br><span class="line">$ dropdb --yes</span><br><span class="line">Dropped all tables!</span><br></pre></td></tr></table></figure>
<h3 id="其他增强功能"><a href="#其他增强功能" class="headerlink" title="其他增强功能"></a>其他增强功能</h3><p><code>click</code> 支持从环境中读取选项的值，这是 <code>argparse</code> 所不支持的，可参阅官方文档的 <a href="https://click.palletsprojects.com/en/7.x/options/#values-from-environment-variables" target="_blank" rel="noopener">Values from Environment Variables</a> 和 <a href="https://click.palletsprojects.com/en/7.x/options/#multiple-values-from-environment-values" target="_blank" rel="noopener">Multiple Values from Environment Values</a>。</p>
<p><code>click</code> 支持指定选项前缀，你可以不使用 <code>-</code> 作为选项前缀，还可使用 <code>+</code> 或 <code>/</code>，当然在一般情况下并不建议这么做。详情参阅官方文档的 <a href="https://click.palletsprojects.com/en/7.x/options/#other-prefix-characters" target="_blank" rel="noopener">Other Prefix Characters</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以看出，<code>click</code> 对命令行选项的支持非常丰富和强大，除了支持 <code>argarse</code> 所支持的所有选项类型外，还提供了诸如 <code>计值选项</code>、<code>特性切换选项</code>、<code>提示选项</code> 等更丰富的选项类型。此外，还提供了从环境中读变量等方便易用的增强功能。简直就是开发命令行程序的利器。</p>
<p>在下篇文章中，我们着重介绍下 <code>click</code> 的命令和组，这可是实现它的重要特性（任意嵌套命令）的方式。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>click</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：深入 click（一）</title>
    <url>/2019/11/11/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9A%E6%B7%B1%E5%85%A5-click%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇文章中，我们初步掌握了 <code>click</code> 的简单用法，并了解到它与 <code>argparse</code> 和 <code>docopt</code> 的不同。接下来，将深入介绍 <code>click</code> 的各类用法，以让你能轻松打造复杂的命令行程序。</p>
<p>在概念上， <code>click</code> 把命令行分为 3 个组成：参数、选项和命令。</p>
<ul>
<li><code>参数</code> 就是跟在命令后的除选项外的内容，比如 <code>git add a.txt</code> 中的 <code>a.txt</code> 就是表示文件路径的参数</li>
<li><code>选项</code> 就是以 <code>-</code> 或 <code>--</code> 开头的参数，比如 <code>-f</code>、<code>--file</code></li>
<li><code>命令</code> 就是命令行的初衷了，比如 <code>git</code> 就是命令，而 <code>git add</code> 中的 <code>add</code> 则是 <code>git</code> 的子命令</li>
</ul>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h3><p><code>基本参数</code> 就是通过位置里指定参数值。</p>
<p>比如，我们可以指定两个位置参数 <code>x</code> 和 <code>y</code> ，先添加的 <code>x</code> 位于第一个位置，后加入的 <code>y</code> 位于第二个位置。那么在命令行中输入 <code>1 2</code>的时候，分别对应到的就是 <code>x</code> 和 <code>y</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.argument('x')</span></span><br><span class="line"><span class="meta">@click.argument('y')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    print(x, y)</span><br></pre></td></tr></table></figure>
<h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p><code>参数类型</code> 就是将参数值作为什么类型去解析，默认情况下是字符串类型。我们可以通过 <code>type</code> 入参来指定参数类型。</p>
<p><code>click</code> 支持的参数类型多种多样：</p>
<ul>
<li><code>str</code> / <code>click.STRING</code> 表示字符串类型，这也是默认类型</li>
<li><code>int</code> / <code>click.INT</code> 表示整型</li>
<li><code>float</code> / <code>click.FLOAT</code> 表示浮点型</li>
<li><code>bool</code> / <code>click.BOOL</code> 表示布尔型。很棒之处在于，它会识别表示真/假的字符。对于 <code>1</code>、<code>yes</code>、<code>y</code> 和 <code>true</code> 会转化为 <code>True</code>；<code>0</code>、<code>no</code>、<code>n</code> 和 <code>false</code> 会转化为 <code>False</code></li>
<li><code>click.UUID</code> 表示 UUID，会自动将参数转换为 <code>uuid.UUID</code> 对象</li>
<li><code>click.FILE</code> 表示文件，会自动将参数转换为文件对象，并在命令行结束时自动关闭文件</li>
<li><code>click.PATH</code> 表示路径</li>
<li><code>click.Choice</code> 表示选择选项</li>
<li><code>click.IntRange</code> 表示范围选项</li>
</ul>
<p>同 <code>argparse</code> 一样，<code>click</code> 也支持自定义类型，需要编写 <code>click.ParamType</code> 的子类，并重载 <code>convert</code> 方法。</p>
<p>官网提供了一个例子，实现了一个整数类型，除了普通整数之外，还接受十六进制和八进制数字， 并将它们转换为常规整数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BasedIntParamType</span><span class="params">(click.ParamType)</span>:</span></span><br><span class="line">    name = <span class="string">"integer"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">convert</span><span class="params">(self, value, param, ctx)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> value[:<span class="number">2</span>].lower() == <span class="string">"0x"</span>:</span><br><span class="line">                <span class="keyword">return</span> int(value[<span class="number">2</span>:], <span class="number">16</span>)</span><br><span class="line">            <span class="keyword">elif</span> value[:<span class="number">1</span>] == <span class="string">"0"</span>:</span><br><span class="line">                <span class="keyword">return</span> int(value, <span class="number">8</span>)</span><br><span class="line">            <span class="keyword">return</span> int(value, <span class="number">10</span>)</span><br><span class="line">        <span class="keyword">except</span> TypeError:</span><br><span class="line">            self.fail(</span><br><span class="line">                <span class="string">"expected string for int() conversion, got "</span></span><br><span class="line">                <span class="string">f"<span class="subst">&#123;value!r&#125;</span> of type <span class="subst">&#123;type(value).__name__&#125;</span>"</span>,</span><br><span class="line">                param,</span><br><span class="line">                ctx,</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">except</span> ValueError:</span><br><span class="line">            self.fail(<span class="string">f"<span class="subst">&#123;value!r&#125;</span> is not a valid integer"</span>, param, ctx)</span><br><span class="line"></span><br><span class="line">BASED_INT = BasedIntParamType()</span><br></pre></td></tr></table></figure>
<h3 id="文件参数"><a href="#文件参数" class="headerlink" title="文件参数"></a>文件参数</h3><p>在基本参数的基础上，通过指定参数类型，我们就能构建出各类参数。</p>
<p><code>文件参数</code> 是非常常用的一类参数，通过 <code>type=click.File</code> 指定，它能正确处理所有 Python 版本的 unicode 和 字节，使得处理文件十分方便。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.argument('input', type=click.File('rb'))  # 指定文件为二进制读</span></span><br><span class="line"><span class="meta">@click.argument('output', type=click.File('wb'))  # 指定文件为二进制写</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inout</span><span class="params">(input, output)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        chunk = input.read(<span class="number">1024</span>)  <span class="comment"># 此时 input 为文件对象，每次读入 1024 字节</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> chunk:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        output.write(chunk)  <span class="comment"># 此时 output 为文件对象，写入上步读入的内容</span></span><br></pre></td></tr></table></figure>
<h3 id="文件路径参数"><a href="#文件路径参数" class="headerlink" title="文件路径参数"></a>文件路径参数</h3><p><code>文件路径参数</code> 用来处理文件路径，可以对路径做是否存在等检查，通过 <code>type=click.Path</code> 指定。不论文件名是 unicode 还是字节类型，获取到的参数类型都是 unicode 类型。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.argument('filename', type=click.Path(exists=True))  # 要求给定路径存在，否则报错</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(filename)</span>:</span></span><br><span class="line">    click.echo(click.format_filename(filename))</span><br></pre></td></tr></table></figure>
<p>如果文件名是以 <code>-</code> 开头，会被误认为是命令行选项，这个时候需要在参数前加上 <code>--</code> 和空格，比如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python hello.py -- -foo.txt</span><br><span class="line">-foo.txt</span><br></pre></td></tr></table></figure>
<h3 id="选择项参数"><a href="#选择项参数" class="headerlink" title="选择项参数"></a>选择项参数</h3><p><code>选择项参数</code> 用来限定参数内容，通过 <code>type=click.Choice</code> 指定。</p>
<p>比如，指定文件读取方式限制为 <code>read-only</code> 和 <code>read-write</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.argument('mode', type=click.Choice(['read-only', 'read-write']))</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(mode)</span>:</span></span><br><span class="line">    click.echo(mode)</span><br></pre></td></tr></table></figure>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p><code>可变参数</code> 用来定义一个参数可以有多个值，且能通过 <code>nargs</code> 来定义值的个数，取得的参数的变量类型为元组。</p>
<p>若 <code>nargs=N</code>，<code>N</code>为一个数字，则要求该参数提供 N 个值。若 <code>N</code> 为 <code>-1</code> 则接受提供无数量限制的参数，如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.argument('foo', nargs=-1)</span></span><br><span class="line"><span class="meta">@click.argument('bar', nargs=1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(foo, bar)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>如果要实现 <code>argparse</code> 中要求参数数量为 1 个或多个的功能，则指定 <code>nargs=-1</code> 且 <code>required=True</code> 即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.argument('foo', nargs=-1, required=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(foo, bar)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="从环境变量读取参数"><a href="#从环境变量读取参数" class="headerlink" title="从环境变量读取参数"></a>从环境变量读取参数</h3><p>通过在 <code>click.argument</code> 中指定 <code>envvar</code>，则可读取指定名称的环境变量作为参数值，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.argument('filename', envvar='FILENAME')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(filename)</span>:</span></span><br><span class="line">    print(filename)</span><br></pre></td></tr></table></figure>
<p>执行如下命令查看效果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ FILENAME=hello.txt python3 hello.py</span><br><span class="line">hello.txt</span><br></pre></td></tr></table></figure>
<p>而在 <code>argparse</code> 中，则需要自己从环境变量中读取。</p>
<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>本文讲解了 <code>click</code> 中基本参数的用法，在此基础上介绍了各种类型的参数，最后说明了从环境变量中获取参数值的写法。</p>
<p>在下一篇文章中，我们来继续深入了解 <code>click</code> 的功能，看看它都支持什么样的“选项”。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>click</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：初探 click</title>
    <url>/2019/11/04/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9A%E5%88%9D%E6%8E%A2-click/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本系列前面几篇文章中，我们分别介绍了 <code>argparse</code> 和 <code>docopt</code> 的主要功能和用法。它们各具特色，都能出色地完成命令行任务。<code>argparse</code> 是面向过程的，需要先设置解析器，再定义参数，再解析命令行，最后实现业务逻辑。而 <code>docopt</code> 先用声明式的语法定义出参数，再过程式地解析命令行和实现业务逻辑。在一些人看来，这些方式都不够优雅。</p>
<p>而今天要介绍的 <a href="https://click.palletsprojects.com/" target="_blank" rel="noopener">click</a> 则是用一种你很熟知的方式来玩转命令行。命令行程序本质上是定义参数和处理参数，而处理参数的逻辑一定是与所定义的参数有关联的。那可不可以用函数和装饰器来实现处理参数逻辑与定义参数的关联呢？而 <code>click</code> 正好就是以这种方式来使用的。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://click.palletsprojects.com/" target="_blank" rel="noopener">click</a> 是一个以尽可能少的代码、以组合的方式创建优美的命令行程序的 Python 包。它有很高的可配置性，同时也能开箱即用。</p>
<p>它旨在让编写命令行工具的过程既快速又有趣，还能防止由于无法实现预期的 CLI API 所产生挫败感。它有如下三个特点：</p>
<ul>
<li>任意嵌套命令</li>
<li>自动生成帮助</li>
<li>支持运行时延迟加载子命令</li>
</ul>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h3><p>首先定义业务逻辑，是不是感觉到有些难以置信呢？</p>
<p>不论是 <code>argparse</code> 还是 <code>docopt</code>，业务逻辑都是被放在最后一步，但 <code>click</code> 却是放在第一步。细想想 <code>click</code> 的这种方式才更符合人的思维吧？不论用什么命令行框架，我们最终关心的就是实现业务逻辑，其他的能省则省。</p>
<p>我们以官方示例为例，来介绍 <code>click</code> 的用法和哲学。假设命令行程序的输入是 <code>name</code> 和 <code>count</code>，功能是打印指定次数的名字。</p>
<p>那么在 <code>hello.py</code> 中，很容易写出如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(count, name)</span>:</span></span><br><span class="line">    <span class="string">"""Simple program that greets NAME for a total of COUNT times."""</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(count):</span><br><span class="line">        click.echo(<span class="string">'Hello %s!'</span> % name)</span><br></pre></td></tr></table></figure>
<p>这段代码的逻辑很简单，就是循环 <code>count</code> 次，使用 <code>click.echo</code> 打印 <code>name</code>。其中，<code>click.echo</code> 和 <code>print</code> 的作用相似，但功能更加强大，能处理好 Unicode 和 二进制数据的情况。</p>
<h3 id="定义参数"><a href="#定义参数" class="headerlink" title="定义参数"></a>定义参数</h3><p>很显然，我们需要针对 <code>count</code> 和 <code>name</code> 来定义它们所对应的参数信息。</p>
<ul>
<li><code>count</code> 对应为命令行选项 <code>--count</code>，类型为数字，我们希望在不提供参数时，其默认值是 1</li>
<li><code>name</code> 对应为命令行选项 <code>--name</code>，类型为字符串，我们希望在不提供参数时，能给人提示</li>
</ul>
<p>使用 <code>click</code>，就可以写成下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> click <span class="keyword">import</span> click</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--count', default=1, help='Number of greetings.')</span></span><br><span class="line"><span class="meta">@click.option('--name', prompt='Your name',</span></span><br><span class="line">              help=<span class="string">'The person to greet.'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(count, name)</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>在上面的示例中：</p>
<ul>
<li>使用装饰器的方式，即定义了参数，又将之与处理逻辑绑定，这真是优雅。和 <code>argparse</code>、<code>docopt</code> 比起来，就少了一步绑定过程</li>
<li>使用 <code>click.command</code> 表示 <code>hello</code> 是对命令的处理</li>
<li>使用 <code>click.option</code> 来定义参数选项<ul>
<li>对于 <code>--count</code> 来说，使用 <code>default</code> 来指定默认值。而由于默认值是数字，进而暗示 <code>--count</code> 选项的类型为数字</li>
<li>对于 <code>--name</code> 来说，使用 <code>prompt</code> 来指定未输入该选项时的提示语</li>
<li>使用 <code>help</code> 来指定帮助信息</li>
</ul>
</li>
</ul>
<p>不论是装饰器的方式、还是各种默认行为，<code>click</code> 都是像它的介绍所说的那样，让人尽可能少地编写代码，让整个过程变得快速而有趣。</p>
<h3 id="代码梳理"><a href="#代码梳理" class="headerlink" title="代码梳理"></a>代码梳理</h3><p>使用 <code>click</code> 的方式非常简单，我们将上文的代码汇总下，以有一个更清晰的认识：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hello.py</span></span><br><span class="line"><span class="keyword">import</span> click</span><br><span class="line"></span><br><span class="line"><span class="meta">@click.command()</span></span><br><span class="line"><span class="meta">@click.option('--count', default=1, help='Number of greetings.')</span></span><br><span class="line"><span class="meta">@click.option('--name', prompt='Your name',</span></span><br><span class="line">              help=<span class="string">'The person to greet.'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(count, name)</span>:</span></span><br><span class="line">    <span class="string">"""Simple program that greets NAME for a total of COUNT times."""</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(count):</span><br><span class="line">        click.echo(<span class="string">'Hello %s!'</span> % name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    hello()</span><br></pre></td></tr></table></figure>
<p>若我们指定次数和名字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 hello.py --count 2 --name Eric</span><br><span class="line">Hello Eric!</span><br><span class="line">Hello Eric!</span><br></pre></td></tr></table></figure>
<p>若我们什么都不指定，则会提示输入名字，并默认输出一次：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 hello.py</span><br><span class="line">Your name: Eric</span><br><span class="line">Hello Eric!</span><br></pre></td></tr></table></figure>
<p>我们还可以通过 <code>--help</code> 参数查看自动生成的帮助信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: hello.py [OPTIONS]</span><br><span class="line"></span><br><span class="line">  Simple program that greets NAME <span class="keyword">for</span> a total of COUNT <span class="built_in">times</span>.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --count INTEGER  Number of greetings.</span><br><span class="line">  --name TEXT      The person to greet.</span><br><span class="line">  --<span class="built_in">help</span>           Show this message and <span class="built_in">exit</span>.</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>click</code> 的思路非常简单，定义处理函数，通过它的装饰器来定义参数。使用装饰器的绝妙之处就在于把定义和绑定这两个步骤合为一个步骤，使得整个过程变得如丝般顺滑。</p>
<p><code>click</code> 除了以 <code>Pythonic</code> 的方式让命令行程序的实现变得更加优雅和好用外，还提供了比 <code>argparse</code> 和 <code>docopt</code> 都要强大的功能。在接下来几节中，我们将会逐步揭开它的面纱。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>click</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：使用 docopt 实现 git 命令</title>
    <url>/2019/10/30/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9A%E4%BD%BF%E7%94%A8-docopt-%E5%AE%9E%E7%8E%B0-git-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>本文首发于 <a href="https://mp.weixin.qq.com/s/iKNpKRB3CgmX9tNyXF-I4g" target="_blank" rel="noopener">HelloGitHub</a> 公众号。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面两篇介绍 <code>docopt</code> 的文章中，我们全面了解了 <code>docopt</code> 的能力。按照惯例，我们要像使用 <code>argparse</code> 一样使用 <code>docopt</code> 来实现 git 命令。</p>
<p>为了让没读过 <code>使用 argparse 实现 git 命令</code> 的小伙伴也能读明白本文，我们仍会对 git 常用命令和 gitpython 做一个简单介绍。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<h2 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h2><p>当你写好一段代码或增删一些文件后，会用如下命令查看文件状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>确认文件状态后，会用如下命令将的一个或多个文件（夹）添加到暂存区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add [pathspec [pathspec ...]]</span><br></pre></td></tr></table></figure>
<p>然后使用如下命令提交信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"your commit message"</span></span><br></pre></td></tr></table></figure>
<p>最后使用如下命令将提交推送到远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>我们将使用 <code>docopt</code> 和 <code>gitpython</code> 库来实现这 4 个子命令。</p>
<h2 id="关于-gitpython"><a href="#关于-gitpython" class="headerlink" title="关于 gitpython"></a>关于 gitpython</h2><p><a href="https://gitpython.readthedocs.io/en/stable/intro.html" target="_blank" rel="noopener">gitpython</a> 是一个和 <code>git</code> 仓库交互的 Python 第三方库。<br>我们将借用它的能力来实现真正的 <code>git</code> 逻辑。</p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install gitpython</span><br></pre></td></tr></table></figure>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在实现前，我们不妨先思考下会用到 <code>docopt</code> 的哪些功能？整个程序的结构是怎样的？</p>
<p><strong>docopt</strong></p>
<p>不同于使用 <code>argparse</code> 时需要考虑嵌套解析器、各类参数等问题，在使用 <code>docopt</code> 只需将我们要实现的 git 命令用接口描述先定义清楚即可。</p>
<p><strong>程序结构</strong></p>
<p>程序结构上，除了开头处定义接口描述外，其余和使用 <code>argparse</code> 实现 git 命令的结构是一样的：</p>
<ul>
<li>命令行程序需要一个 <code>cli</code> 函数来作为统一的入口，它负责构建解析器，并解析命令行参数</li>
<li>我们还需要四个 <code>handle_xxx</code> 函数响应对应的子命令</li>
</ul>
<p>则基本结构如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> docopt</span><br><span class="line"><span class="keyword">from</span> git.cmd <span class="keyword">import</span> Git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    git 命名程序入口</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_status</span><span class="params">(git)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 status 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_add</span><span class="params">(git, pathspec)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 add 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_commit</span><span class="params">(git, msg)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 -m &lt;msg&gt; 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_push</span><span class="params">(git)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 push 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    cli()</span><br></pre></td></tr></table></figure>
<p>下面我们将一步步地实现我们的 <code>git</code> 程序。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>假定我们在 <a href="https://github.com/HelloGitHub-Team/Article/blob/master/contents/Python/cmdline/docopt-git.py" target="_blank" rel="noopener">docopt-git.py</a> 文件中实现我们的 <code>git</code> 程序。</p>
<h3 id="定义接口描述"><a href="#定义接口描述" class="headerlink" title="定义接口描述"></a>定义接口描述</h3><p>根据我们的要求，可以很容易的定义出接口描述：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    git status</span><br><span class="line">    git add [&lt;pathspec&gt;...]</span><br><span class="line">    git commit -m msg</span><br><span class="line">    git push</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -h --<span class="built_in">help</span>         Show <span class="built_in">help</span>.</span><br><span class="line">  -m --message msg  Commit with message.</span><br></pre></td></tr></table></figure>
<p>进而就可以在 <code>cli()</code> 中解析命令行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    git 命名程序入口</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    args = docopt(__doc__)</span><br><span class="line">    git = Git(os.getcwd())</span><br></pre></td></tr></table></figure>
<h3 id="status-子命令"><a href="#status-子命令" class="headerlink" title="status 子命令"></a>status 子命令</h3><p>如果 <code>args[&#39;status&#39;]</code> 为 <code>True</code>，说明输入了 status 子命令，那么就调用 <code>handle_status</code> 函数进行处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'status'</span>]:</span><br><span class="line">        handle_status(git)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_status</span><span class="params">(git)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 status 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cmd = [<span class="string">'git'</span>, <span class="string">'status'</span>]</span><br><span class="line">    output = git.execute(cmd)</span><br><span class="line">    print(output)</span><br></pre></td></tr></table></figure>
<p>不难看出，我们最后调用了真正的 <code>git status</code> 来实现，并打印了输出。</p>
<h3 id="add-子命令"><a href="#add-子命令" class="headerlink" title="add 子命令"></a>add 子命令</h3><p>如果 <code>args[&#39;add&#39;]</code> 为 <code>True</code>，说明输入了 add 子命令，那么就调用 <code>handle_add</code> 函数进行处理，需要传入 <code>args[&#39;&lt;pathspec&gt;&#39;]</code> 表示添加的路径。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">elif</span> args[<span class="string">'add'</span>]:</span><br><span class="line">        handle_add(git, args[<span class="string">'&lt;pathspec&gt;'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_add</span><span class="params">(git, pathspec)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 add 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cmd = [<span class="string">'git'</span>, <span class="string">'add'</span>] + pathspec</span><br><span class="line">    output = git.execute(cmd)</span><br><span class="line">    print(output)</span><br></pre></td></tr></table></figure>
<h3 id="commit-子命令"><a href="#commit-子命令" class="headerlink" title="commit 子命令"></a>commit 子命令</h3><p>如果 <code>args[&#39;commit&#39;]</code> 为 <code>True</code>，说明输入了 commit 子命令，那么就调用 <code>handle_commit</code> 函数进行处理，需要传入 <code>args[&#39;--message&#39;]</code> 表示提交的信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">elif</span> args[<span class="string">'commit'</span>]:</span><br><span class="line">        handle_commit(git, args[<span class="string">'--message'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_commit</span><span class="params">(git, msg)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 -m &lt;msg&gt; 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cmd = [<span class="string">'git'</span>, <span class="string">'commit'</span>, <span class="string">'-m'</span>, msg]</span><br><span class="line">    output = git.execute(cmd)</span><br><span class="line">    print(output)</span><br></pre></td></tr></table></figure>
<h3 id="push-子命令"><a href="#push-子命令" class="headerlink" title="push 子命令"></a>push 子命令</h3><p>如果 <code>args[&#39;push&#39;]</code> 为 <code>True</code>，说明输入了 commit 子命令，那么就调用 <code>handle_push</code> 函数进行处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">elif</span> args[<span class="string">'push'</span>]:</span><br><span class="line">        handle_push(git)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_push</span><span class="params">(git)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 push 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cmd = [<span class="string">'git'</span>, <span class="string">'push'</span>]</span><br><span class="line">    output = git.execute(cmd)</span><br><span class="line">    print(output)</span><br></pre></td></tr></table></figure>
<p>至此，我们就实现了一个简单的 <code>git</code> 命令行，使用 <code>python docopt-git.py status</code> 便可查询项目状态。</p>
<p>想看整个源码，请戳 <a href="https://github.com/HelloGitHub-Team/Article/blob/master/contents/Python/cmdline/docopt-git.py" target="_blank" rel="noopener">docopt-git.py</a> 。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文简单介绍了日常工作中常用的 <code>git</code> 命令，然后提出实现它的思路，最终一步步地使用 <code>docopt</code> 和 <code>gitpython</code> 实现了 <code>git</code> 程序。</p>
<p>对比 <code>argparse</code> 的实现版本，你会发现使用 <code>docopt</code> 来实现变得非常简单，子解析器、参数类型什么的统统不需要关心！这可以说是 <code>docopt</code> 最大的优势了。</p>
<p>关于 <code>docopt</code> 的讲解将告一段落，回顾下 <code>docopt</code> 的三步曲，加上今天的内容，感觉它的使用方式还是比 <code>argparse</code> 简单不少的。</p>
<p>现在，你已学会了两个命令行解析库的使用了。但你以为这就够了吗？</p>
<p>但人类的智慧是多么璀璨呀，有些人并不喜欢这两个库的使用方式，于是他们有开辟了一个全新的思路。</p>
<p>在下篇文章中，将为大家介绍一个在 Python 界十分流行的命令行库 —— <code>click</code>。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>argparse</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Airflow 探究</title>
    <url>/2019/10/23/Airflow-%E6%8E%A2%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Airflow 是一个以<strong>编程</strong>方式进行<strong>编写、调度和监控工作流</strong>的平台。<br>一旦工作流通过代码来定义，它们会变得更加易于维护、版本化、可测试，以及可协作。<br>使用 Airflow 以<strong>有向无环图 (DAGs)</strong>的形式编写任务的工作流。Airflow 调度器在满足指定的依赖项的同时，在一组 worker 上执行任务。丰富的命令行实用程序使得通过 DAG 执行复杂的任务变得容易。而通过丰富的界面，用户可以轻松地可视化生产中运行的流水线、监视进度，并在需要时排除故障。</p>
<a id="more"></a>
<h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ul>
<li>动态性：Airflow 流水线（pipeline）配置为代码（Python），并允许动态生成，进而允许编写动态实例化流水线的代码</li>
<li>可扩展性：能轻松定义自己的操作器（opertators）、执行器，并可扩展库，以使其符合适合当前环境的抽象级别</li>
<li>优雅性：Airflow 流水线精简而清晰。Airflow 的核心使用强大的 Jinja 模板引擎对配置脚本进行参数化</li>
<li>可伸缩性：Airflow 具有模块化体系结构，并使用消息队列来协调任意数量的 worker。</li>
</ul>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>Airflow 由以下组件组成：</p>
<ul>
<li>配置文件：配置诸如“Web 服务器在哪里运行”、“使用何种 Executor”、“配置相关 RabbitMQ/Redis”、DAGs 位置等</li>
<li>元数据库（MySQL 或 Postgre）:存放 DAGs、DAG run、任务、变量等内容</li>
<li>DAGs（Directed Acyclic Graphs，有向无环图）：用来定义工作流，包含任务定义及依赖信息。其中的任务就是用户实际要去执行的内容</li>
<li>调度器：负责触发每个 DAG 的 DAG 实例和工作实例，也负责调用 Executor（可以是 Local、Celery 或 Sequential）</li>
<li>Broker（Redis 或 RabbitMQ）：对 Celery Executor 来说，broker 是必须的，用来在 executor 和 worker 之间传递消息</li>
<li>Worker 节点：实际执行任务和返回任务结果的工作进程</li>
<li>Web 服务器：提供 Airflow 的界面，用户可以访问它来查看 DAGs、状态、重新运行、创建变量、配置连接等</li>
</ul>
<h3 id="更多内容"><a href="#更多内容" class="headerlink" title="更多内容"></a>更多内容</h3><p>GitHub：<a href="https://github.com/apache/incubator-airflow" target="_blank" rel="noopener">https://github.com/apache/incubator-airflow</a><br>官方文档：<a href="https://airflow.incubator.apache.org" target="_blank" rel="noopener">https://airflow.incubator.apache.org</a></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="安装和启动"><a href="#安装和启动" class="headerlink" title="安装和启动"></a>安装和启动</h3><p>我们可以通过 pip 或者 docker 来获取 Airflow 并运行，然后访问 <a href="http://localhost:8080。" target="_blank" rel="noopener">http://localhost:8080。</a></p>
<h4 id="通过-pip"><a href="#通过-pip" class="headerlink" title="通过 pip"></a>通过 pip</h4><p>通过 pip 方式获取到的 Airflow 所使用的默认数据库为 Python 自带的 sqlite3，如需使用其他数据库（如 MySQL、PostgreSQL）详见官方文档的<a href="http://airflow.apache.org/installation.html" target="_blank" rel="noopener">安装说明</a>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定Airflow的home目录，默认为~/airflow</span></span><br><span class="line">export AIRFLOW_HOME=~/airflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过pip安装apache-airflow</span></span><br><span class="line">pip install apache-airflow</span><br><span class="line"><span class="comment"># 安装kubernete插件，否则后续运行会一直报错</span></span><br><span class="line">pip install airflow[<span class="string">'kubernetes'</span>] kubernetes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化数据库</span></span><br><span class="line">airflow initdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动web服务器，默认端口为8080</span></span><br><span class="line">airflow webserver -p <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动调度器</span></span><br><span class="line">airflow scheduler​</span><br></pre></td></tr></table></figure>
<h4 id="通过-docker"><a href="#通过-docker" class="headerlink" title="通过 docker"></a>通过 docker</h4><p>目前尚没有 Airflow 官方的 docker 版，而开源社区里有几个用户各自自发地维护了 docker 版的 airflow，其中比较出名的有 <a href="https://github.com/puckel/docker-airflow。" target="_blank" rel="noopener">https://github.com/puckel/docker-airflow。</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取airflow镜像</span></span><br><span class="line">docker pull puckel/docker-airflow</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动web服务器，映射端口为8080</span></span><br><span class="line">docker run -d -p <span class="number">8080</span>:<span class="number">8080</span> puckel/docker-airflow webserver</span><br></pre></td></tr></table></figure>
<h3 id="DAG"><a href="#DAG" class="headerlink" title="DAG"></a>DAG</h3><p>为了更好的说明如何使用 DAG 来定义工作流，本文将使用官网的<a href="http://airflow.apache.org/tutorial.html#example-pipeline-definition" target="_blank" rel="noopener">一个例子</a>进行说明。</p>
<h4 id="任务流程图"><a href="#任务流程图" class="headerlink" title="任务流程图"></a>任务流程图</h4><img src="/2019/10/23/Airflow-探究/1.png">
<p>假定有一个任务叫 print_date，用以输出日期。当它执行完后，会同时执行两个名为 templated 和 sleep 的任务，而：</p>
<ul>
<li>templated 任务用于循环输出日期和参数</li>
<li>sleep 任务用于休眠一段时间</li>
</ul>
<h4 id="DAG-定义文件"><a href="#DAG-定义文件" class="headerlink" title="DAG 定义文件"></a>DAG 定义文件</h4><p>Airflow 直接使用 Python 脚本来编写 DAG 定义文件，上述任务流程写成 DAG 定义文件如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Code that goes along with the Airflow tutorial located at:</span></span><br><span class="line"><span class="string">https://github.com/apache/incubator-airflow/blob/master/airflow/example_dags/tutorial.py</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> airflow <span class="keyword">import</span> DAG</span><br><span class="line"><span class="keyword">from</span> airflow.operators.bash_operator <span class="keyword">import</span> BashOperator</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line"><span class="comment"># 初始化DAG</span></span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line"><span class="comment"># 用作整个流程的默认参数</span></span><br><span class="line">default_args = &#123;</span><br><span class="line">    <span class="string">'owner'</span>: <span class="string">'airflow'</span>,</span><br><span class="line">    <span class="string">'depends_on_past'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'start_date'</span>: datetime(<span class="number">2018</span>, <span class="number">11</span>, <span class="number">20</span>),</span><br><span class="line">    <span class="string">'email'</span>: [<span class="string">'airflow@example.com'</span>],</span><br><span class="line">    <span class="string">'email_on_failure'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'email_on_retry'</span>: <span class="keyword">False</span>,</span><br><span class="line">    <span class="string">'retries'</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">'retry_delay'</span>: timedelta(minutes=<span class="number">5</span>),</span><br><span class="line">    <span class="comment"># 'queue': 'bash_queue',</span></span><br><span class="line">    <span class="comment"># 'pool': 'backfill',</span></span><br><span class="line">    <span class="comment"># 'priority_weight': 10,</span></span><br><span class="line">    <span class="comment"># 'end_date': datetime(2018, 11, 20),</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们需要一个DAG对象，用来组合各个任务。第一个参数为表示其唯一身份的ID，</span></span><br><span class="line"><span class="comment"># 第二个参数是一组调度相关的配置</span></span><br><span class="line"><span class="comment"># 第三个参数表示每天调度一次,也可以用crontab的语法描述时间间隔，如'0 0 * * *'</span></span><br><span class="line">dag = DAG(<span class="string">'tutorial'</span>, default_args=default_args, schedule_interval=timedelta(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line"><span class="comment"># 初始化任务</span></span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line"><span class="comment"># t1即为print_date任务，task_id为任务的唯一标识符</span></span><br><span class="line"><span class="comment"># 使用bash命令date来打印日期</span></span><br><span class="line">t1 = BashOperator(</span><br><span class="line">    task_id=<span class="string">'print_date'</span>,</span><br><span class="line">    bash_command=<span class="string">'date'</span>,</span><br><span class="line">    dag=dag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># t2即为sleep任务</span></span><br><span class="line"><span class="comment"># 使用bash命令sleep 5来休眠5秒，重试3次</span></span><br><span class="line">t2 = BashOperator(</span><br><span class="line">    task_id=<span class="string">'sleep'</span>,</span><br><span class="line">    bash_command=<span class="string">'sleep 5'</span>,</span><br><span class="line">    retries=<span class="number">3</span>,</span><br><span class="line">    dag=dag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Jinja模板，&#123;&#123;变量名&#125;&#125;均会被Airflow替换成真实值，如&#123;&#123; ds &#125;&#125;被替换成真实的日期</span></span><br><span class="line"><span class="comment"># &#123;% for i in range(5) %&#125;表示循环5次执行</span></span><br><span class="line"><span class="comment"># 更多关于宏的说明详见 https://airflow.incubator.apache.org/code.html#macros</span></span><br><span class="line">templated_command = <span class="string">"""</span></span><br><span class="line"><span class="string">    &#123;% for i in range(5) %&#125;</span></span><br><span class="line"><span class="string">        echo "&#123;&#123; ds &#125;&#125;"</span></span><br><span class="line"><span class="string">        echo "&#123;&#123; macros.ds_add(ds, 7)&#125;&#125;"</span></span><br><span class="line"><span class="string">        echo "&#123;&#123; params.my_param &#125;&#125;"</span></span><br><span class="line"><span class="string">    &#123;% endfor %&#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># t3为templated任务</span></span><br><span class="line">t3 = BashOperator(</span><br><span class="line">    task_id=<span class="string">'templated'</span>,</span><br><span class="line">    bash_command=templated_command,</span><br><span class="line">    params=&#123;<span class="string">'my_param'</span>: <span class="string">'Parameter I passed in'</span>&#125;,</span><br><span class="line">    dag=dag)</span><br><span class="line"></span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line"><span class="comment"># 配置任务之间的依赖</span></span><br><span class="line"><span class="comment">##########################################</span></span><br><span class="line"><span class="comment"># 将t2的上游设置为t1</span></span><br><span class="line">t2.set_upstream(t1)</span><br><span class="line"><span class="comment"># 将t3的上游设置为t1</span></span><br><span class="line">t3.set_upstream(t1)​</span><br></pre></td></tr></table></figure>
<p>乍看整个文件会有些复杂，但是总的来说，Airflow 仅把此 Python 脚本作为工作流的配置文件，所以并不会出现任何的业务逻辑。<br>DAG 定义文件大致分为三块：</p>
<ul>
<li>配置参数，进而初始化 dag 对象</li>
<li>初始化一些任务</li>
<li>配置这些任务彼此间的依赖关系<br>所以整体上看配置过程是简单明了的。不过，DAG 定义文件中涉及到 DAG、Operator、Task 等概念，只有了解这些，才能轻松地进行配置。我们将在 2.3 节中重点介绍。</li>
</ul>
<h4 id="调度器"><a href="#调度器" class="headerlink" title="调度器"></a>调度器</h4><p>在 2.1 节中也介绍过，通过以下命令可以启动调度器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">airflow scheduler</span><br></pre></td></tr></table></figure>
<p>只有启动了调度器，任务才可以被调度，进而分配到某个工作进程中执行。</p>
<p>关于调度执行时间需要特别注意，在上述 DAG 定义文件的示例中：</p>
<ul>
<li>start_date 表示作业开始调度时间</li>
<li>schedule_interval 表示调度周期，它有多种表达方式：<ul>
<li>使用 datetime.timedelta 对象，如 timedelta(1)表示每天</li>
<li>使用和<a href="https://en.wikipedia.org/wiki/Cron#CRON_expression" target="_blank" rel="noopener">cron 完全相同的语法</a>，如’* * * * *‘表示每分钟</li>
<li>使用<a href="http://airflow.apache.org/scheduler.html#dag-runs" target="_blank" rel="noopener">预置的 cron</a>，如‘@once’, ‘@hourly’等</li>
</ul>
</li>
</ul>
<p>当新配置的 DAG 生效后，第一次真正调度的时间为从开始调度时间开始，一个调度周期末端时刻。比如 start_date 为 2018-11-11，schedule_interval 为一天，那么将在 2018-11-11T23:59 后马上执行 DAG。</p>
<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p><strong>运行脚本</strong><br>假定上述 DAG 定义文件名为 tutorial.py，存放于~/airflow/dags（没有则新建）下，那么执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python ~/airflow/dags/tutorial.py</span><br></pre></td></tr></table></figure>
<p>如果没有抛出任何异常，说明 DAG 文件没有大的问题，可以进入下一步。<br><strong>命令行元数据验证</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出激活的DAGs</span></span><br><span class="line">airflow list_dags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出DAG ID为"tutorial"的所有任务</span></span><br><span class="line">airflow list_tasks tutorial</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出任务层级</span></span><br><span class="line">airflow list_tasks tutorial --tree</span><br></pre></td></tr></table></figure>
<p><strong>进行测试</strong><br>注意最后一个参数为执行时间，填写当天日期即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令行: command subcommand dag_id task_id date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试print_date任务</span></span><br><span class="line">airflow <span class="built_in">test</span> tutorial print_date 2018-11-20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试sleep任务</span></span><br><span class="line">airflow <span class="built_in">test</span> tutorial sleep 2018-11-20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试templated任务</span></span><br><span class="line">airflow <span class="built_in">test</span> tutorial templated 2018-11-20​</span><br></pre></td></tr></table></figure>
<p>airflow test 命令会在本地运行任务实例，并将日志输出到标准输出。无需担心任务间的依赖，也不会将任务状态同步至数据库。<br>比如上述 print_date 任务的部分关键测试输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2018-11-20 17:53:45,512] &#123;bash_operator.py:81&#125; INFO - Running <span class="built_in">command</span>: date</span><br><span class="line">[2018-11-20 17:53:45,517] &#123;bash_operator.py:90&#125; INFO - Output:</span><br><span class="line">[2018-11-20 17:53:45,521] &#123;bash_operator.py:94&#125; INFO - Tue Nov 20 17:53:45 UTC 2018</span><br><span class="line">[2018-11-20 17:53:45,521] &#123;bash_operator.py:97&#125; INFO - Command exited with <span class="built_in">return</span> code 0</span><br></pre></td></tr></table></figure>
<h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><h4 id="DAGs"><a href="#DAGs" class="headerlink" title="DAGs"></a>DAGs</h4><p>在 Airflow 中，DAG 或者说有向无环图是若干个任务的集合，这些任务以某种方式组织，展现了彼此间的联系和依赖。因此，DAG 描述了一个工作流的过程。<br>DAG 并不关心里面的任务做了什么事情，而是关心：</p>
<ul>
<li>任务在特定的时间开始</li>
<li>若干任务以正确的顺序进行</li>
<li>对未期望的情况有正确的处理</li>
</ul>
<p>DAG 定义文件需存放在 DAG_FOLDER 目录（通过~/airflow/airflow.cfg 进行配置）下，Airflow 会执行该目录下的每个 py 文件，来动态地生成 DAG 对象。</p>
<p><strong>作用域（Scope）</strong></p>
<p>Airflow 将加载它可以从 DAG 文件导入的任何 DAG 对象。，也就意味着 DAG 必须出现在 globals()中。<br>在下面的示例中，只会加载 dag_1：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dag_1 = DAG(<span class="string">'this_dag_will_be_discovered'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_function</span><span class="params">()</span>:</span></span><br><span class="line">    dag_2 = DAG(<span class="string">'but_this_dag_will_not'</span>)</span><br><span class="line"></span><br><span class="line">my_function()​</span><br></pre></td></tr></table></figure>
<p>不过有时这么用也有它的意义。比如在函数中使用 SubDagOperator 来定义子 dag。</p>
<p><strong>默认参数（Default Arguments）</strong></p>
<p>默认参数需传入 DAG 的 default_args 中，进而会应用到所有的操作器上。这样，当许多操作器需要共同参数时，通过这种方式就方便了许多。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">default_args = &#123;</span><br><span class="line">    <span class="string">'start_date'</span>: datetime(<span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">    <span class="string">'owner'</span>: <span class="string">'Airflow'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dag = DAG(<span class="string">'my_dag'</span>, default_args=default_args)</span><br><span class="line">op = DummyOperator(task_id=<span class="string">'dummy'</span>, dag=dag)</span><br><span class="line">print(op.owner) <span class="comment"># Airflow​</span></span><br></pre></td></tr></table></figure>
<p><strong>上下文管理器（Conext Manager）</strong><br>DAG 可以当做上下文管理器来使用，这样一来，作用域内的操作器会自动地赋值 dag。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> DAG(<span class="string">'my_dag'</span>, start_date=datetime(<span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>)) <span class="keyword">as</span> dag:</span><br><span class="line">    op = DummyOperator(<span class="string">'op'</span>)</span><br><span class="line"></span><br><span class="line">op.dag <span class="keyword">is</span> dag <span class="comment"># True，这里的操作器op就被自动地赋值上了dag​</span></span><br></pre></td></tr></table></figure>
<h4 id="操作器（Operator）"><a href="#操作器（Operator）" class="headerlink" title="操作器（Operator）"></a>操作器（Operator）</h4><p>Operator 用来描述工作流中单个任务的内容，即做什么。它通常（但并非总是）是原子的，这意味着其可以独立运行，而不需要与其他 Operator 共享资源，因此可能在两台完全不同的机器上运行。<br>通常来说，如果两个 Operator 需要共享信息，如文件名或少量数据，应该考虑将它们组合到一个操作器中。如果没法避免，则可以使用 Airflow 提供的名为 XCom 的特性来进行操作器间的通信。<br>Airflow 内置了很多的操作器来完成常见任务，包括：</p>
<ul>
<li>BashOperator - 执行 bash 命令</li>
<li>PythonOperator - 调用任意的 Python 函数</li>
<li>EmailOperator - 发送邮件</li>
<li>SimpleHttpOperator - 发送 HTTP 请求</li>
<li>MySqlOperator, SqliteOperator, PostgresOperator, MsSqlOperator, OracleOperator, JdbcOperator 等 - 执行 SQL 命令</li>
<li>Sensor - 等待一个特定的时间、文件、数据库行、S3 key 等</li>
</ul>
<p>除了这些常用的，还有特定的操作器，如 DockerOperator、HiveOperator、S3FileTransformOperator、PrestoToMysqlOperator、SlackOperator 等<br><a href="https://github.com/apache/airflow/tree/master/airflow/contrib" target="_blank" rel="noopener">airflow/contrib</a>目录中包含了更多由社区构建的操作器，允许用户更轻松地向平台添加新功能，但不保证质量。</p>
<p><strong>DAG 赋值（DAG Assignment）</strong><br>操作器无需立即赋值 DAG。 但是，一旦为操作器赋值 DAG，就无法转移或取消。 在创建操作器时，通过延迟赋值或甚至从其他操作器推导，可以显式地完成 DAG 赋值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dag = DAG(<span class="string">'my_dag'</span>, start_date=datetime(<span class="number">2018</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示地设置DAG</span></span><br><span class="line">explicit_op = DummyOperator(task_id=<span class="string">'op1'</span>, dag=dag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 延迟设置DAG</span></span><br><span class="line">deferred_op = DummyOperator(task_id=<span class="string">'op2'</span>)</span><br><span class="line">deferred_op.dag = dag</span><br><span class="line"></span><br><span class="line"><span class="comment"># DAG推导赋值（和链接的操作器，也就是例子中的deferred_op，必须是在同一个DAG中）</span></span><br><span class="line">inferred_op = DummyOperator(task_id=<span class="string">'op3'</span>)</span><br><span class="line">inferred_op.set_upstream(deferred_op)​</span><br></pre></td></tr></table></figure>
<p><strong>位移组合（Bitshift Composition）</strong><br>通常使用 set_upstream()和 set_downstream()方法设置操作器间的依赖关系。 在 Airflow 1.8 及以后，可以通过 Python 位移操作符”&gt;&gt;”和”&lt;&lt;”来达到相同的目的。<br>以下四个语句在功能上都是等价的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">op1 &gt;&gt; op2</span><br><span class="line">op1.set_downstream(op2)</span><br><span class="line"></span><br><span class="line">op2 &lt;&lt; op1</span><br><span class="line">op2.set_upstream(op1)</span><br></pre></td></tr></table></figure>
<p>op1 &gt;&gt; op2 表示先运行 op1，再 op2 运行。<br>我们还可以组成多个操作器。要注意的是链式从左到右执行，并且始终返回最右边的对象。 例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">op1 &gt;&gt; op2 &gt;&gt; op3 &lt;&lt; op4</span><br></pre></td></tr></table></figure>
<p>表示两个任务分支：一个是依次运行 op1、op2、op3，一个是依次运行 op4、op3。与之等价的语句如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">op1.set_downstream(op2)</span><br><span class="line">op2.set_downstream(op3)</span><br><span class="line">op3.set_upstream(op4)</span><br></pre></td></tr></table></figure>
<p>为了方便，位移操作符还可以用于 DAG，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dag &gt;&gt; op1 &gt;&gt; op2</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">op1.dag = dag</span><br><span class="line">op1.set_downstream(op2)</span><br></pre></td></tr></table></figure>
<p>结合<strong>上下文管理器</strong>和<strong>位移组合</strong>，我们就可以编写出如下例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> DAG(<span class="string">'my_dag'</span>, start_date=datetime(<span class="number">2016</span>, <span class="number">1</span>, <span class="number">1</span>)) <span class="keyword">as</span> dag:</span><br><span class="line">    (</span><br><span class="line">        DummyOperator(task_id=<span class="string">'dummy_1'</span>)</span><br><span class="line">        &gt;&gt; BashOperator(</span><br><span class="line">            task_id=<span class="string">'bash_1'</span>,</span><br><span class="line">            bash_command=<span class="string">'echo "HELLO!"'</span>)</span><br><span class="line">        &gt;&gt; PythonOperator(</span><br><span class="line">            task_id=<span class="string">'python_1'</span>,</span><br><span class="line">            python_callable=<span class="keyword">lambda</span>: print(<span class="string">"GOODBYE!"</span>))</span><br><span class="line">    )​</span><br></pre></td></tr></table></figure>
<p>本示例表示依次执行 DummyOperator、BashOperator、PythonOperator。</p>
<h4 id="任务（Tasks）"><a href="#任务（Tasks）" class="headerlink" title="任务（Tasks）"></a>任务（Tasks）</h4><p>一旦操作器被实例化，它就被称作“任务”。 由于在实例化操作器时指定了特定的值，从而形成了参数化的任务，而这样的任务便成了 DAG 中的一个节点。</p>
<h4 id="任务实例（Task-Instances）"><a href="#任务实例（Task-Instances）" class="headerlink" title="任务实例（Task Instances）"></a>任务实例（Task Instances）</h4><p>任务实例表示任务的特定运行时，其特点在于 dag、任务和时间点的组合。 任务实例也有状态，如“运行”、“成功”、“失败”、“跳过”、“重试”等。</p>
<h4 id="工作流（Workflows）"><a href="#工作流（Workflows）" class="headerlink" title="工作流（Workflows）"></a>工作流（Workflows）</h4><p>上述概念可以定义如下：</p>
<ul>
<li>DAG: 描述工作应该进行的顺序</li>
<li>Operator: 某些工作的模板</li>
<li>Task: Operator 的参数化实例</li>
<li>Task Instance:一个任务的运行时，它被赋值了 DAG，且有与 DAG 的特定运行相关联的状态</li>
</ul>
<p>而工作流，就是组合 DAG、Operators 来创建多个 TaskInstance 。</p>
<h2 id="测试数据"><a href="#测试数据" class="headerlink" title="测试数据"></a>测试数据</h2><h3 id="任务执行时间"><a href="#任务执行时间" class="headerlink" title="任务执行时间"></a>任务执行时间</h3><p>本测试创建了 3 个相同的任务（下文用 t1、t2、t3 指代），任务内容是使用 PythonOperator 执行一个 Python 函数，将时间写入到文件中，核心代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义默认参数</span></span><br><span class="line">default_args = &#123;</span><br><span class="line">    <span class="string">'owner'</span>: <span class="string">'airflow'</span>,  <span class="comment"># 拥有者名称</span></span><br><span class="line">    <span class="string">'start_date'</span>: datetime(<span class="number">2018</span>, <span class="number">11</span>, <span class="number">27</span>, <span class="number">23</span>, <span class="number">1</span>),  <span class="comment"># 第一次开始执行的时间，为格林威治时间</span></span><br><span class="line">    <span class="string">'retries'</span>: <span class="number">1</span>,  <span class="comment"># 失败重试次数</span></span><br><span class="line">    <span class="string">'retry_delay'</span>: timedelta(seconds=<span class="number">5</span>)  <span class="comment"># 失败重试间隔</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义DAG</span></span><br><span class="line">dag = DAG(</span><br><span class="line">    dag_id=<span class="string">'hello_world'</span>,  <span class="comment"># dag_id</span></span><br><span class="line">    default_args=default_args,  <span class="comment"># 指定默认参数</span></span><br><span class="line">    <span class="comment"># schedule_interval="00, *, *, *, *"  # 执行周期，依次是分，时，天，月，年，此处表示每个整点执行</span></span><br><span class="line">    schedule_interval=timedelta(minutes=<span class="number">1</span>)  <span class="comment"># 执行周期，表示每分钟执行一次</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello_world_1</span><span class="params">()</span>:</span></span><br><span class="line">    current_time = str(datetime.today())</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'/tmp/hello_world_1.txt'</span>, <span class="string">'a'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">'%s\n'</span> % current_time)</span><br><span class="line"></span><br><span class="line">t1 = PythonOperator(</span><br><span class="line">    task_id=<span class="string">'hello_world_1'</span>,  <span class="comment"># task_id</span></span><br><span class="line">    python_callable=hello_world_1,  <span class="comment"># 指定要执行的函数</span></span><br><span class="line">    dag=dag,  <span class="comment"># 指定归属的dag</span></span><br><span class="line">)​</span><br></pre></td></tr></table></figure>
<p>任务依赖关系如下：</p>
<img src="/2019/10/23/Airflow-探究/2.png">
<p>当使用 SequentialExecutor 时，Airflow Scheduler 为不同配置时执行 dag 中每个任务的时间统计如下：</p>
<img src="/2019/10/23/Airflow-探究/3.png">
<p>从上述数据可以看出：</p>
<ul>
<li>对于周期性 dag 来说，实际调度时间不准确，基本上晚于计划时间一个周期甚至更久</li>
<li>调度并不意味着真正要执行任务，真正执行时间晚于调度时间约 4 秒</li>
<li>整个任务执行时间较长，t1、t2、t3 使用 PythonOperator 将日期输出到文件中，毫秒级就可以完成。但是从结果看，整个时间要持续 1-3 秒左右</li>
</ul>
<h3 id="加载-DAG-的方式"><a href="#加载-DAG-的方式" class="headerlink" title="加载 DAG 的方式"></a>加载 DAG 的方式</h3><p>Airflow 会不断加载 dags 目录下的 dag 文件，scheduler 加载 dag 文件的相关日志如下：</p>
<img src="/2019/10/23/Airflow-探究/4.png">
<p>从中可以看出：</p>
<ul>
<li>Airflow 会依次加载 dag 中的所有 dag 文件，待所有文件加载好后，重头开始，如此循环往复</li>
<li>每次都是新开一个进程加载一个 dag 文件</li>
<li>加载一个 dag 文件的时间大概在 3-4s 左右</li>
</ul>
<h2 id="部署架构"><a href="#部署架构" class="headerlink" title="部署架构"></a>部署架构</h2><h3 id="单机部署"><a href="#单机部署" class="headerlink" title="单机部署"></a>单机部署</h3><img src="/2019/10/23/Airflow-探究/5.png">
<p>在该场景中：</p>
<ul>
<li>Repo 指代元数据库（如 MySQL、Postgre 等），存放 DAGs、DAG run、任务、变量等内容</li>
<li>WebServer 展现 DAGs 及其状态指标（数据从 Repo 中获取）</li>
<li>Scheduler 读取 DAGs，将其信息存放至 Repo。它也负责启动 Executor</li>
<li>Executor 读取调度间隔信息，在 Repo 中创建 DAGs 和任务的实例</li>
<li>Worker 读取任务实例并运行任务，将状态写回 Repo</li>
</ul>
<h3 id="Worker-分布式部署"><a href="#Worker-分布式部署" class="headerlink" title="Worker 分布式部署"></a>Worker 分布式部署</h3><img src="/2019/10/23/Airflow-探究/6.png">
<p>分布式部署和单机部署最大的区别在于 Executor 和 Wroker 的变化。这种场景下，我们一般使用 Celery Worker 作为 worker，所以 Executor 也会使用 Celery Executor。而 Celery 需要使用像 RabbitMQ 这样的 broker 作为消息传递：</p>
<ul>
<li>RabbitMQ 是 Celery Executor 存放任务实例的分布式消息服务，而 Worker 就是从此读取消息来执行任务</li>
<li>Executor 会被配置为 Celery Executor（在 airflow.cfg 中配置），并且指向 RabbitMQ Broker</li>
<li>Worker 被安装在不同的节点上，它们从 RabbitMQ Broker 中读取任务，并执行，最终将结果写入 Backend（就是图中的 Repo，可以是 MySQL 等数据库）</li>
</ul>
<h3 id="Airflow-高可用-Worker-分布式部署"><a href="#Airflow-高可用-Worker-分布式部署" class="headerlink" title="Airflow 高可用+Worker 分布式部署"></a>Airflow 高可用+Worker 分布式部署</h3><img src="/2019/10/23/Airflow-探究/7.png">
<p>我们主要说明上图左侧的 Airflow 高可用的架构，图中绿色部分为的主实例(实例 1)，红色为备实例（实例 2）：</p>
<ul>
<li>实例 1 和实例 2 均会启动并运行，实例 1 首先在元数据库（Repo）的表中声明为主实例</li>
<li>主实例（实例 1）会包含实际的 DAGs；备实例（实例 2）会包含 PrimaryServerPoller（Counterpart Poller） DAG，PrimaryServerPoller 会不断地向主实例的调度器拉取数据</li>
<li>假设主实例（实例 1）挂掉，则 PrimaryServerPoller 会检测到，然后：<ul>
<li>实例 2 在元数据库（Repo）的表中声明为主实例</li>
<li>将实例 1 中 DAGs 文件夹中所有 DAGs 移出，并把 PrimaryServerPoller DAG 移入</li>
<li>将实例 2 中 DAGs 文件夹中 PrimaryServerPoller DAG 移出，并把所有的 DAGs 移入</li>
</ul>
</li>
<li>由此，实例 1、2 的身份对调</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://airflow.incubator.apache.org/start.html" target="_blank" rel="noopener">Airflow 官方文档</a></li>
<li><a href="http://clairvoyantsoft.com/assets/whitepapers/GuideToApacheAirflow.pdf" target="_blank" rel="noopener">Guide to Apache Airflow</a></li>
<li><a href="https://www.jianshu.com/p/e878bbc9ead2" target="_blank" rel="noopener">浅谈调度工具——Airflow</a></li>
<li><a href="https://juejin.im/post/5b7ba247e51d4538d42ab6a0" target="_blank" rel="noopener">理解 Apache Airflow 的关键概念</a></li>
<li><a href="https://www.jianshu.com/p/56fe5a271c14" target="_blank" rel="noopener">工作流管理平台 Airflow 入门</a></li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>]]></content>
      <categories>
        <category>DevOps</category>
        <category>Airflow</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>DevOps</tag>
        <tag>Airflow</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Python 玩转 WMI</title>
    <url>/2019/10/20/%E4%BD%BF%E7%94%A8-Python-%E7%8E%A9%E8%BD%AC-WMI/</url>
    <content><![CDATA[<p>（备注：本文是之前在博客园中发表的文章，因为老博客不再维护，把有价值的博文转移到这里。）</p>
<p>最近在网上搜索 Python 和 WMI 相关资料时，发现大部分文章都千篇一律，并且基本上只说了很基础的使用，并未深入说明如何使用 WMI。本文打算更进一步，让我们使用 Python 玩转 WMI。</p>
<a id="more"></a>
<h2 id="什么是-WMI"><a href="#什么是-WMI" class="headerlink" title="什么是 WMI"></a>什么是 WMI</h2><p>具体请看微软官网对 <a href="https://docs.microsoft.com/zh-cn/windows/win32/wmisdk/wmi-start-page" target="_blank" rel="noopener">WMI</a> 的介绍。这里简单说明下，WMI 的全称是 Windows Management Instrumentation，即 Windows 管理规范。它是 Windows 操作系统上管理数据和操作的基础设施。我们可以使用 WMI 脚本或者应用自动化管理任务等。</p>
<p>从 <a href="https://docs.microsoft.com/zh-cn/windows/win32/wmisdk/using-wmi" target="_blank" rel="noopener">Using WMI</a> 可以知道 WMI 支持如下语言：</p>
<table>
<thead>
<tr>
<th>Application language</th>
<th style="text-align:center">Topic</th>
</tr>
</thead>
<tbody>
<tr>
<td>Scripts written in Microsoft ActiveX script hosting, including Visual Basic Scripting Edition (VBScript) and Perl</td>
<td style="text-align:center"><a href="https://docs.microsoft.com/zh-cn/windows/win32/wmisdk/scripting-api-for-wmi" target="_blank" rel="noopener">Scripting API for WMI</a>.<br>Start with <a href="https://docs.microsoft.com/zh-cn/windows/win32/wmisdk/creating-a-wmi-script" target="_blank" rel="noopener">Creating a WMI Script</a>.<br>For script code examples, see <a href="https://docs.microsoft.com/zh-cn/windows/win32/wmisdk/wmi-tasks-for-scripts-and-applications" target="_blank" rel="noopener">WMI Tasks for Scripts and Applications</a> and the TechNet <a href="http://go.microsoft.com/fwlink/p/?linkid=46710" target="_blank" rel="noopener">ScriptCenter</a> Script Repository.</td>
</tr>
<tr>
<td>Windows PowerShell</td>
<td style="text-align:center"><a href="https://docs.microsoft.com/zh-cn/powershell/scripting/getting-started/getting-started-with-windows-powershell?view=powershell-6" target="_blank" rel="noopener">Getting Started with Windows PowerShell</a><br>WMI PowerShell Cmdlets, such as <a href="https://docs.microsoft.com/en-us/previous-versions//dd315295%28v=technet.10%29" target="_blank" rel="noopener">Get-WmiObject</a>.</td>
</tr>
<tr>
<td>Visual Basic applications</td>
<td style="text-align:center"><a href="https://docs.microsoft.com/zh-cn/windows/win32/wmisdk/scripting-api-for-wmi" target="_blank" rel="noopener">Scripting API for WMI</a>.</td>
</tr>
<tr>
<td>Active Server Pages</td>
<td style="text-align:center"><a href="https://docs.microsoft.com/zh-cn/windows/win32/wmisdk/scripting-api-for-wmi" target="_blank" rel="noopener">Scripting API for WMI</a>.<br>Start with <a href="https://docs.microsoft.com/zh-cn/windows/win32/wmisdk/creating-active-server-pages-for-wmi" target="_blank" rel="noopener">Creating Active Server Pages for WMI</a>.</td>
</tr>
<tr>
<td>C++ applications</td>
<td style="text-align:center"><a href="https://docs.microsoft.com/zh-cn/windows/win32/wmisdk/com-api-for-wmi" target="_blank" rel="noopener">COM API for WMI</a>.<br>Start with <a href="https://docs.microsoft.com/zh-cn/windows/win32/wmisdk/creating-a-wmi-application-using-c-" target="_blank" rel="noopener">Creating a WMI Application Using C++</a> and <a href="https://docs.microsoft.com/zh-cn/windows/win32/wmisdk/wmi-c---application-examples" target="_blank" rel="noopener">WMI C++ Application Examples</a> (contains examples).</td>
</tr>
<tr>
<td>.NET Framework applications written in C#, Visual Basic .NET, or J#</td>
<td style="text-align:center">Classes in the <a href="https://docs.microsoft.com/en-us/previous-versions//hh872326%28v=vs.85%29" target="_blank" rel="noopener">Microsoft.Management.Infrastructure</a> namespace. (The System.Management namespace is no longer supported). For more information, see <a href="https://docs.microsoft.com/en-us/previous-versions/bb404655%28v=vs.90%29" target="_blank" rel="noopener">WMI .NET Overview</a>.</td>
</tr>
</tbody>
</table>
<p>很遗憾，WMI 并不原生支持 Python。不过没有关系，它支持 VB，而 Python 中的两个第三方库 wmi 和 win32com，均能以类似 VB 的用法来使用。那么接下来，我们来讲讲如何使用。</p>
<h2 id="使用-WMI"><a href="#使用-WMI" class="headerlink" title="使用 WMI"></a>使用 WMI</h2><h3 id="使用-wmi-库操作-WMI"><a href="#使用-wmi-库操作-WMI" class="headerlink" title="使用 wmi 库操作 WMI"></a>使用 wmi 库操作 WMI</h3><p>以下是一个遍历所有进程，所有服务的示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> wmi</span><br><span class="line">c = wmi.WMI ()</span><br><span class="line"><span class="comment"># 遍历进程</span></span><br><span class="line"><span class="keyword">for</span> process <span class="keyword">in</span> c.Win32_Process ():</span><br><span class="line">    <span class="keyword">print</span> process.ProcessId, process.Name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历服务</span></span><br><span class="line"><span class="keyword">for</span> service <span class="keyword">in</span> c.Win32_Service ():</span><br><span class="line">    <span class="keyword">print</span> service.ProcessId, service.Name</span><br></pre></td></tr></table></figure>
<p>可以看到，使用起来非常简单。但是有两个问题：一是 wmi 库实在是太慢了，能不能快点？二是如何知道例子中 process 和 service 有哪些属性（比如 ProcessId 等）？由于 wmi 库是动态生成底层执行语句，用 dir(process)这种方式是获取不到 ProcessId 这种属性的。</p>
<p>针对第一个问题，我们可以使用 win32com 这个库来解决，它相较于 wmi 的速度快了很多。而第二个问题，先卖个关子，后文会有介绍。</p>
<h3 id="使用-win32com-库操作-WMI"><a href="#使用-win32com-库操作-WMI" class="headerlink" title="使用 win32com 库操作 WMI"></a>使用 win32com 库操作 WMI</h3><p>win32com 能模仿 VB 的行为，想了解如何使用 win32com 来操作 WMI，最直接的方式是了解如何使用 VB 来操作 WMI。在微软的官网上提供了很多现成的例子：WMI Tasks: Processes， WMI Tasks: Services。</p>
<p>其中一个例子关于进程是这样的：</p>
<figure class="highlight vb"><table><tr><td class="code"><pre><span class="line">strComputer = <span class="string">"."</span></span><br><span class="line"><span class="keyword">Set</span> objWMIService = GetObject(<span class="string">"winmgmts:"</span> &amp; <span class="string">"&#123;impersonationLevel=impersonate&#125;!\\"</span> &amp; strComputer &amp; <span class="string">"\root\cimv2"</span>)</span><br><span class="line"><span class="keyword">Set</span> colProcesses = objWMIService.ExecQuery(<span class="string">"Select * from Win32_Process"</span>)</span><br><span class="line"><span class="keyword">For</span> <span class="keyword">Each</span> objProcess <span class="keyword">in</span> colProcesses</span><br><span class="line"></span><br><span class="line">    Wscript.Echo <span class="string">"Process: "</span> &amp; objProcess.Name</span><br><span class="line">    sngProcessTime = (<span class="built_in">CSng</span>(objProcess.KernelModeTime) + <span class="built_in">CSng</span>(objProcess.UserModeTime)) / <span class="number">10000000</span></span><br><span class="line">    Wscript.Echo <span class="string">"Processor Time: "</span> &amp; sngProcessTime</span><br><span class="line">    Wscript.Echo <span class="string">"Process ID: "</span> &amp; objProcess.ProcessID</span><br><span class="line">    Wscript.Echo <span class="string">"Working Set Size: "</span> &amp; objProcess.WorkingSetSize</span><br><span class="line">    Wscript.Echo <span class="string">"Page File Size: "</span> &amp; objProcess.PageFileUsage</span><br><span class="line">    Wscript.Echo <span class="string">"Page Faults: "</span> &amp; objProcess.PageFaults</span><br><span class="line"><span class="keyword">Next</span></span><br></pre></td></tr></table></figure>
<p>它做了这样一件事：首先通过 GetObject 连接到 Win32_Process 所在的名称空间，然后执行 WQL 语句（类似 SQL 的查询语句）查到所有的进程，再把每一个进程的相关信息打印出来。WQL 的具体用法请见官网，这里不详细介绍。</p>
<p>那么用 win32com 就可以这么写（例子中打印的属性为了简便，就不像上面那么多啦）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> win32com.client <span class="keyword">import</span> GetObject</span><br><span class="line"></span><br><span class="line">wmi = GetObject(<span class="string">'winmgmts:/root/cimv2'</span>)</span><br><span class="line"><span class="comment"># wmi = GetObject('winmgmts:') #更简单的写法</span></span><br><span class="line">processes = wmi.ExecQuery(<span class="string">'Select * from Win32_Process'</span>)</span><br><span class="line"><span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">    print(process.ProcessID, process.Name)</span><br></pre></td></tr></table></figure>
<p>看上去，VB 和 win32com 的用法非常接近！那么当我们想要使用 win32com 对 WMI 进行操作时，就可以参考微软官网上 VB 的例子，然后比葫芦画瓢写出 Python 版的代码。</p>
<p>上例中，我们使用了查询函数 ExecQuery 来查询符合条件的内容，不过如果我们仅仅是想要获得所有的数据，而没有特定的限定条件，就可以使用更简单的方式——InstancesOf，那么就可以写成下面这样：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> win32com.client <span class="keyword">import</span> GetObject</span><br><span class="line"></span><br><span class="line">wmi = GetObject(<span class="string">'winmgmts:/root/cimv2'</span>)</span><br><span class="line">processes = wmi.InstancesOf(<span class="string">'Win32_Process'</span>)</span><br><span class="line"><span class="keyword">for</span> process <span class="keyword">in</span> processes:</span><br><span class="line">    print(process.ProcessID, process.Name)</span><br></pre></td></tr></table></figure>
<p>有读者可能会问，我们怎么知道自己想要了解的内容在哪个名称空间，我们应该获取哪个实例，又该获取实例中的哪些属性呢？</p>
<h2 id="WMI-的名称空间"><a href="#WMI-的名称空间" class="headerlink" title="WMI 的名称空间"></a>WMI 的名称空间</h2><p>使用下面的脚本可以获得当前计算机上的名称空间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> win32com.client <span class="keyword">import</span> GetObject</span><br><span class="line"><span class="keyword">import</span> pywintypes</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enum_namespace</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        wmi = GetObject(<span class="string">'winmgmts:/'</span> + name)</span><br><span class="line">        namespaces = wmi.InstancesOf(<span class="string">'__Namespace'</span>)</span><br><span class="line">        <span class="keyword">for</span> namespace <span class="keyword">in</span> namespaces:</span><br><span class="line">            enum_namespace(<span class="string">'&#123;name&#125;/&#123;subname&#125;'</span>.format(name=name,</span><br><span class="line">                                                     subname=namespace.Name))</span><br><span class="line">    <span class="keyword">except</span> pywintypes.com_error:</span><br><span class="line">        print(name, <span class="string">'limit of authority'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(name)</span><br><span class="line">enum_namespace(<span class="string">'root'</span>)</span><br></pre></td></tr></table></figure>
<p>获得的内容大概是这样的(…表示省略了一些输出内容)：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line">root/subscription</span><br><span class="line">root/subscription/ms_409</span><br><span class="line">root/DEFAULT</span><br><span class="line">root/DEFAULT/ms_409</span><br><span class="line">root/CIMV2</span><br><span class="line">root/CIMV2/Security</span><br><span class="line">...</span><br><span class="line">root/Cli</span><br><span class="line">root/Cli/MS_409</span><br><span class="line">root/SECURITY</span><br><span class="line">...</span><br><span class="line">root/WMI</span><br><span class="line">root/WMI/ms_409</span><br><span class="line">root/directory</span><br><span class="line">root/directory/LDAP</span><br><span class="line">root/directory/LDAP/ms_409</span><br><span class="line">root/Interop</span><br><span class="line">root/Interop/ms_409</span><br><span class="line">root/ServiceModel</span><br><span class="line">root/SecurityCenter</span><br><span class="line">root/MSAPPS12</span><br><span class="line">root/Microsoft</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>通用的名称空间的简单介绍：</p>
<p>root 是名称空间层次结构的最高级。</p>
<p>CIMV2 名称空间存放着和系统管理域相关（比如计算机以及它们的操作系统）的对象。</p>
<p>DEFAULT 名称空间存放着默认被创建而不指定名称空间的类。</p>
<p>directory 目录服务的通用名称空间，WMI 创建了名为 LDAP 的子名称空间。</p>
<p>SECURITY 用来支持 Windows 9x 计算机上的 WMI 的名称空间。</p>
<p>WMI 使用 Windows Driver Model providers 的类所在的名称空间。这是为了避免和 CIMV2 名称空间中类名冲突。</p>
<p>其中，root/CIMV2 可以说是最为基本和常用的名称空间了。它的作用主要是提供关于计算机、磁盘、外围设备、文件、文件夹、文件系统、网络组件、操作系统、打印机、进程、安全性、服务、共享、SAM 用户及组，以及更多资源的信息；管理 Windows 事件日志，如读取、备份、清除、复制、删除、监视、重命名、压缩、解压缩和更改事件日志设置。</p>
<h2 id="类-实例和属性-值"><a href="#类-实例和属性-值" class="headerlink" title="类/实例和属性/值"></a>类/实例和属性/值</h2><p>了解了名称空间的获取，每个名称空间的主要功能，那么如何获取特定名称空间下所有的类，以及它们的属性和值呢？</p>
<p>Windows 提供了一个 WMI 测试器，使得查询这些内容变得尤为方便。按下”win+R”，输入 wbemtest，从而打开 WMI 测试器。打开后的界面如下：</p>
<img src="/2019/10/20/使用-Python-玩转-WMI/1.png">
<p>点击“连接”，输入想要查询的名称空间，再点击“连接”即可连到特定名称空间。</p>
<p>然后点击“枚举类”，在弹出的界面中选择“递归”，然后点击“确定”，就会得到这个名称空间下所有的类：</p>
<img src="/2019/10/20/使用-Python-玩转-WMI/2.png">
<img src="/2019/10/20/使用-Python-玩转-WMI/3.png">
<p>从上图可以看到，之前举例中提到的 Win32_Process 位列其中，我们不妨双击它，看看关于它的具体内容：</p>
<img src="/2019/10/20/使用-Python-玩转-WMI/4.png">
<p>我们可以很容易地找到 Win32_Process 的属性和方法。除了使用 wbemtest 查看特定名称空间下的所有类，我们还可以在 WMI/MI/OMI Providers 中找到所有的类。我们依次在这个页面中点击 CIMWin32, Win32, Power Management Events，Win32 Provider，Operating System Classes，Win32_Process 最终找到 Win32_Process 的属性和方法：</p>
<img src="/2019/10/20/使用-Python-玩转-WMI/5.png">
<p>对比上面两张图，里面的方法都是一致的。</p>
<p>那么如何获得实例和它的值呢？我们继续在刚刚打开的 wbemtest 界面中点击右边的“实例”按钮，就会显示所有的进程实例。双击某个具体的实例，然后在弹出的界面中点击右侧的“显示 MOF”按钮就会显示这个实例中具体属性的值。</p>
<img src="/2019/10/20/使用-Python-玩转-WMI/6.png">
<img src="/2019/10/20/使用-Python-玩转-WMI/7.png">
<p>通过上述定位名称空间、类、属性的方法，我们就可以愉快地使用 Python 来玩耍 WMI。</p>
<h2 id="实战，以-IIS-为例"><a href="#实战，以-IIS-为例" class="headerlink" title="实战，以 IIS 为例"></a>实战，以 IIS 为例</h2><p>了解了这么多内容，咱们就拿个对象练练手。现在有这么个需求，我们想要获取 IIS 的版本号以及它所有的站点名称，怎么办？</p>
<p>在微软官网上比较容易的找到 IIS WMI 的说明，根据直觉，我们要查询的信息可能会是在类名中包含 setting 的类中，那么看起来比较有可能的有 IIsSetting (WMI), IIsWebServerSetting (WMI), IIsWebInfoSetting (WMI)。</p>
<p>对这些类都分别看一看，发现 IIsSetting 中提供了一个例子：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">o = getobj(<span class="string">"winmgmts:/root/microsoftiisv2"</span>)</span><br><span class="line">nodes = o.ExecQuery(<span class="string">"select * from IIsWebServerSetting where name='w3svc/1'"</span>)</span><br><span class="line">e = <span class="keyword">new</span> Enumerator(nodes)</span><br><span class="line">for(; ! e.atEnd(); e.moveNext()) &#123;</span><br><span class="line">  WScript.Echo(e.item().Name + <span class="string">" ("</span> + e.item().Path_.<span class="keyword">Class</span> + <span class="string">")"</span>)</span><br><span class="line">&#125;</span><br><span class="line">// The output should be:</span><br><span class="line">//   w3svc/1 (IIsWebServerSetting)</span><br><span class="line"></span><br><span class="line">nodes = o.ExecQuery(<span class="string">"select * from</span></span><br><span class="line"><span class="string">IIsSetting where name='w3svc/1'"</span>)</span><br><span class="line">e = <span class="keyword">new</span> Enumerator(nodes)</span><br><span class="line">for(; ! e.atEnd(); e.moveNext()) &#123;</span><br><span class="line">  WScript.Echo(e.item().Name + <span class="string">" ("</span> + e.item().Path_.<span class="keyword">Class</span> + <span class="string">")"</span>)</span><br><span class="line">&#125;</span><br><span class="line">// The output should be:</span><br><span class="line">//   w3svc/1 (IIsIPSecuritySetting)</span><br><span class="line">//   w3svc/1 (IIsWebServerSetting)</span><br></pre></td></tr></table></figure>
<p>从这个例子中，我们可以知道 iis 的名称空间是‘/root/microsoftiisv2’，然后我们可以直接在这个空间中查询各种相关类，比如说“IIsWebServerSetting”。</p>
<p>结合 wbemtest 和 IIS 管理器，我们可以看出 IIsWebServerSetting 实例中的 ServerComment 属性值和网站名称一致：</p>
<img src="/2019/10/20/使用-Python-玩转-WMI/8.png">
<p>而版本信息则在类名包含 setting 的类中无法找到，那再去类名包含 info 的类中瞧一瞧。果然，在 IIsWebInfo (WMI)中找到了 MajorIIsVersionNumber 和 MinorIIsVersionNumber 属性，分别表示大版本和小版本。那么我们就能比较轻松地写出下面的 Python 代码来获得版本和站点名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> win32com.client <span class="keyword">import</span> GetObject</span><br><span class="line"></span><br><span class="line">wmi = GetObject(<span class="string">'winmgmts:/root/microsoftiisv2'</span>)</span><br><span class="line"><span class="comment"># 版本</span></span><br><span class="line">webinfo = wmi.execquery(<span class="string">'select * from IIsWebInfo '</span>)[<span class="number">0</span>]</span><br><span class="line">version = <span class="string">'&#123;major&#125;.&#123;min&#125;'</span>.format(major=webinfo.MajorIIsVersionNumber,</span><br><span class="line">                                 min=webinfo.MinorIIsVersionNumber)</span><br><span class="line">print(version)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 站点名称</span></span><br><span class="line">websettings = wmi.execquery(<span class="string">'select * from IIsWebServerSetting '</span>)</span><br><span class="line">websites = <span class="string">' | '</span>.join(setting.ServerComment <span class="keyword">for</span> setting <span class="keyword">in</span> websettings)</span><br><span class="line">print(websites)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 Python 操作 WMI，最大的难点并不在于如何编写 Python 语句，而在于如果获知想要查询的内容在哪个名称空间以及对应的类和属性。而这些内容则需要查阅官方文档以及使用 wbemtest 进行探索。获得了这些必要的信息后，再去编写 Python 代码就是一件非常轻松的事情。</p>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>]]></content>
      <categories>
        <category>Windows</category>
        <category>WMI</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Windows</tag>
        <tag>WMI</tag>
      </tags>
  </entry>
  <entry>
    <title>Python内存数据库/引擎</title>
    <url>/2019/10/20/Python%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h2 id="初探"><a href="#初探" class="headerlink" title="初探"></a>初探</h2><p>（备注：本文是之前在博客园中发表的文章，因为老博客不再维护，把有价值的博文转移到这里。）</p>
<p>在平时的开发工作中，我们可能会有这样的需求：我们希望有一个内存数据库或者数据引擎，用比较 Pythonic 的方式进行数据库的操作（比如说插入和查询）。</p>
<p>举个具体的例子，分别向数据库 db 中插入两条数据，”a=1, b=1” 和 “a=1, b=2”, 然后想查询 a=1 的数据可能会使用这样的语句 db.query(a=1)，结果就是返回前面插入的两条数据； 如果想查询 a=1, b=2 的数据，就使用这样的语句 db.query(a=1, b=2)，结果就返回前面的第二条数据。</p>
<a id="more"></a>
<p>那么是否拥有实现上述需求的现成的第三方库呢？几经查找，发现 PyDbLite 能够满足这样的需求。其实，PyDbLite 和 Python 自带的 SQLite 均支持内存数据库模式，只是前者是 Pythonic 的用法，而后者则是典型的 SQL 用法。<br>他们具体的用法是这样的：</p>
<h3 id="PyDbLite"><a href="#PyDbLite" class="headerlink" title="PyDbLite"></a>PyDbLite</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pydblite</span><br><span class="line"><span class="comment"># 使用内存数据库</span></span><br><span class="line">pydb = pydblite.Base(<span class="string">':memory:'</span>)</span><br><span class="line"><span class="comment"># 创建a,b,c三个字段</span></span><br><span class="line">pydb.create(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line"><span class="comment"># 为字段a,b创建索引</span></span><br><span class="line">pydb.create_index(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"><span class="comment"># 插入一条数据</span></span><br><span class="line">pydb.insert(a=<span class="number">-1</span>, b=<span class="number">0</span>, c=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 查询符合特定要求的数据</span></span><br><span class="line">results = pydb(a=<span class="number">-1</span>, b=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h3 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line"><span class="comment"># 使用内存数据库</span></span><br><span class="line">con = sqlite3.connect(<span class="string">':memory:'</span>)</span><br><span class="line"><span class="comment"># 创建a,b,c三个字段</span></span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">'create table test (a char(256), b char(256), c char(256));'</span>)</span><br><span class="line"><span class="comment"># 为字段a,b创建索引</span></span><br><span class="line">cur.execute(<span class="string">'create index a_index on test(a)'</span>)</span><br><span class="line">cur.execute(<span class="string">'create index b_index on test(b)'</span>)</span><br><span class="line"><span class="comment"># 插入一条数据</span></span><br><span class="line">cur.execute(<span class="string">'insert into test values(?, ?, ?)'</span>, (<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line"><span class="comment"># 查询符合特定要求的数据</span></span><br><span class="line">cur.execute(<span class="string">'select * from test where a=? and b=?'</span>,(<span class="number">-1</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h2 id="pydblite-和-sqlite-的性能"><a href="#pydblite-和-sqlite-的性能" class="headerlink" title="pydblite 和 sqlite 的性能"></a>pydblite 和 sqlite 的性能</h2><p>毫无疑问，pydblite 的使用方式非常地 Pythonic，但是它的效率如何呢？由于我们主要关心的是数据插入和查询速度，所以不妨仅对这两项做一个对比。写一个简单的测试脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">count = <span class="number">100000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timeit</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kws)</span>:</span></span><br><span class="line">        t = time.time()</span><br><span class="line">        func(*args)</span><br><span class="line">        <span class="keyword">print</span> time.time() - t, kws[<span class="string">'des'</span>]</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timeit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_insert</span><span class="params">(mdb, des=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(count):</span><br><span class="line">        mdb.insert(a=i<span class="number">-1</span>, b=i, c=i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@timeit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_query_object</span><span class="params">(mdb, des=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(count):</span><br><span class="line">        c = mdb(a=i<span class="number">-1</span>, b=i)</span><br><span class="line"></span><br><span class="line"><span class="meta">@timeit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sqlite_insert</span><span class="params">(cur, des=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(count):</span><br><span class="line">        cur.execute(<span class="string">'insert into test values(?, ?, ?)'</span>, (i<span class="number">-1</span>, i, i+<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">@timeit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_sqlite_query</span><span class="params">(cur, des=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(count):</span><br><span class="line">        cur.execute(<span class="string">'select * from test where a=? and b=?'</span>, (i<span class="number">-1</span>, i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'-------pydblite--------'</span></span><br><span class="line"><span class="keyword">import</span> pydblite</span><br><span class="line">pydb = pydblite.Base(<span class="string">':memory:'</span>)</span><br><span class="line">pydb.create(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line">pydb.create_index(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">test_insert(pydb, des=<span class="string">'insert'</span>)</span><br><span class="line">test_query_object(pydb, des=<span class="string">'query, object call'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'-------sqlite3--------'</span></span><br><span class="line"><span class="keyword">import</span> sqlite3</span><br><span class="line">con = sqlite3.connect(<span class="string">':memory:'</span>)</span><br><span class="line">cur = con.cursor()</span><br><span class="line">cur.execute(<span class="string">'create table test (a char(256), b char(256), c char(256));'</span>)</span><br><span class="line">cur.execute(<span class="string">'create index a_index on test(a)'</span>)</span><br><span class="line">cur.execute(<span class="string">'create index b_index on test(b)'</span>)</span><br><span class="line">test_sqlite_insert(cur, des=<span class="string">'insert'</span>)</span><br><span class="line">test_sqlite_query(cur, des=<span class="string">'query'</span>)</span><br></pre></td></tr></table></figure>
<p>在创建索引的情况下，10w 次的插入和查询的时间如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-------pydblite--------</span><br><span class="line">1.14199995995 insert</span><br><span class="line">0.308000087738 query, object call</span><br><span class="line">-------sqlite3--------</span><br><span class="line">0.411999940872 insert</span><br><span class="line">0.30999994278 query</span><br></pre></td></tr></table></figure>
<p>在未创建索引的情况（把创建索引的测试语句注释掉）下，1w 次的插入和查询时间如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-------pydblite--------</span><br><span class="line">0.0989999771118 insert</span><br><span class="line">5.15300011635 query, object call</span><br><span class="line">-------sqlite3--------</span><br><span class="line">0.0169999599457 insert</span><br><span class="line">7.43400001526 query</span><br></pre></td></tr></table></figure>
<p>我们不难得出如下结论：</p>
<p>sqlite 的插入速度是 pydblite 的 3-5 倍；而在建立索引的情况下，sqlite 的查询速度和 pydblite 相当；在未建立索引的情况下，sqlite 的查询速度比 pydblite 慢 1.5 倍左右。</p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>我们的目标非常明确，使用 Pythonic 的内存数据库，提高插入和查询效率，而不考虑持久化。那么能否既拥有 pydblite 的 pythonic 的使用方式，又同时具备 pydblite 和 sqlite 中插入和查询速度快的那一方的速度？针对我们的目标，看看能否对 pydblite 做一些优化。</p>
<p>阅读 pydblite 的源码，首先映入眼帘的是对 python2 和 3 做了一个简单的区分。给外部调用的 Base 基于_BasePy2 或者_BasePy3，它们仅仅是在<strong>iter</strong>上有细微差异，最终调用的是_Base 这个类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BasePy2</span><span class="params">(_Base)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Iteration on the records"""</span></span><br><span class="line">        <span class="keyword">return</span> iter(self.records.itervalues())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_BasePy3</span><span class="params">(_Base)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Iteration on the records"""</span></span><br><span class="line">        <span class="keyword">return</span> iter(self.records.values())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.version_info[<span class="number">0</span>] == <span class="number">2</span>:</span><br><span class="line">    Base = _BasePy2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    Base = _BasePy3</span><br></pre></td></tr></table></figure>
<p>然后看下_Base 的构造函数，做了简单的初始化文件的操作，由于我们就是使用内存数据库，所以文件相关的内容完全可以抛弃。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">_Base</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, path, protocol=pickle.HIGHEST_PROTOCOL, save_to_file=True,</span></span></span><br><span class="line"><span class="function"><span class="params">                 sqlite_compat=False)</span>:</span></span><br><span class="line">        <span class="string">"""protocol as defined in pickle / pickle.</span></span><br><span class="line"><span class="string">        Defaults to the highest protocol available.</span></span><br><span class="line"><span class="string">        For maximum compatibility use protocol = 0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.path = path</span><br><span class="line">        <span class="string">"""The path of the database in the file system"""</span></span><br><span class="line">        self.name = os.path.splitext(os.path.basename(path))[<span class="number">0</span>]</span><br><span class="line">        <span class="string">"""The basename of the path, stripped of its extension"""</span></span><br><span class="line">        self.protocol = protocol</span><br><span class="line">        self.mode = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">if</span> path == <span class="string">":memory:"</span>:</span><br><span class="line">            save_to_file = <span class="keyword">False</span></span><br><span class="line">        self.save_to_file = save_to_file</span><br><span class="line">        self.sqlite_compat = sqlite_compat</span><br><span class="line">        self.fields = []</span><br><span class="line">        <span class="string">"""The list of the fields (does not include the internal</span></span><br><span class="line"><span class="string">        fields __id__ and __version__)"""</span></span><br><span class="line">        <span class="comment"># if base exists, get field names</span></span><br><span class="line">        <span class="keyword">if</span> save_to_file <span class="keyword">and</span> self.exists():</span><br><span class="line">            <span class="keyword">if</span> protocol == <span class="number">0</span>:</span><br><span class="line">                _in = open(self.path)  <span class="comment"># don't specify binary mode !</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                _in = open(self.path, <span class="string">'rb'</span>)</span><br><span class="line">            self.fields = pickle.load(_in)</span><br></pre></td></tr></table></figure>
<p>紧接着比较重要的是 create（创建字段）、create_index（创建索引）两个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(self, *fields, **kw)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create a new base with specified field names.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        - \*fields (str): The field names to create.</span></span><br><span class="line"><span class="string">        - mode (str): the mode used when creating the database.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    - if mode = 'create' : create a new base (the default value)</span></span><br><span class="line"><span class="string">    - if mode = 'open' : open the existing base, ignore the fields</span></span><br><span class="line"><span class="string">    - if mode = 'override' : erase the existing base and create a</span></span><br><span class="line"><span class="string">      new one with the specified fields</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        - the database (self).</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    self.mode = kw.get(<span class="string">"mode"</span>, <span class="string">'create'</span>)</span><br><span class="line">    <span class="keyword">if</span> self.save_to_file <span class="keyword">and</span> os.path.exists(self.path):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(self.path):</span><br><span class="line">            <span class="keyword">raise</span> IOError(<span class="string">"%s exists and is not a file"</span> % self.path)</span><br><span class="line">        <span class="keyword">elif</span> self.mode <span class="keyword">is</span> <span class="string">'create'</span>:</span><br><span class="line">            <span class="keyword">raise</span> IOError(<span class="string">"Base %s already exists"</span> % self.path)</span><br><span class="line">        <span class="keyword">elif</span> self.mode == <span class="string">"open"</span>:</span><br><span class="line">            <span class="keyword">return</span> self.open()</span><br><span class="line">        <span class="keyword">elif</span> self.mode == <span class="string">"override"</span>:</span><br><span class="line">            os.remove(self.path)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">"Invalid value given for 'open': '%s'"</span> % open)</span><br><span class="line"></span><br><span class="line">    self.fields = []</span><br><span class="line">    self.default_values = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> field <span class="keyword">in</span> fields:</span><br><span class="line">        <span class="keyword">if</span> type(field) <span class="keyword">is</span> dict:</span><br><span class="line">            self.fields.append(field[<span class="string">"name"</span>])</span><br><span class="line">            self.default_values[field[<span class="string">"name"</span>]] = field.get(<span class="string">"default"</span>, <span class="keyword">None</span>)</span><br><span class="line">        <span class="keyword">elif</span> type(field) <span class="keyword">is</span> tuple:</span><br><span class="line">            self.fields.append(field[<span class="number">0</span>])</span><br><span class="line">            self.default_values[field[<span class="number">0</span>]] = field[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.fields.append(field)</span><br><span class="line">            self.default_values[field] = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    self.records = &#123;&#125;</span><br><span class="line">    self.next_id = <span class="number">0</span></span><br><span class="line">    self.indices = &#123;&#125;</span><br><span class="line">    self.commit()</span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_index</span><span class="params">(self, *fields)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Create an index on the specified field names</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    An index on a field is a mapping between the values taken by the field</span></span><br><span class="line"><span class="string">    and the sorted list of the ids of the records whose field is equal to</span></span><br><span class="line"><span class="string">    this value</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    For each indexed field, an attribute of self is created, an instance</span></span><br><span class="line"><span class="string">    of the class Index (see above). Its name it the field name, with the</span></span><br><span class="line"><span class="string">    prefix _ to avoid name conflicts</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        - fields (list): the fields to index</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    reset = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> fields:</span><br><span class="line">        <span class="keyword">if</span> f <span class="keyword">not</span> <span class="keyword">in</span> self.fields:</span><br><span class="line">            <span class="keyword">raise</span> NameError(<span class="string">"%s is not a field name %s"</span> % (f, self.fields))</span><br><span class="line">        <span class="comment"># initialize the indices</span></span><br><span class="line">        <span class="keyword">if</span> self.mode == <span class="string">"open"</span> <span class="keyword">and</span> f <span class="keyword">in</span> self.indices:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        reset = <span class="keyword">True</span></span><br><span class="line">        self.indices[f] = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> _id, record <span class="keyword">in</span> self.records.items():</span><br><span class="line">            <span class="comment"># use bisect to quickly insert the id in the list</span></span><br><span class="line">            bisect.insort(self.indices[f].setdefault(record[f], []), _id)</span><br><span class="line">        <span class="comment"># create a new attribute of self, used to find the records</span></span><br><span class="line">        <span class="comment"># by this index</span></span><br><span class="line">        setattr(self, <span class="string">'_'</span> + f, Index(self, f))</span><br><span class="line">    <span class="keyword">if</span> reset:</span><br><span class="line">        self.commit()</span><br></pre></td></tr></table></figure>
<p>可以看出，pydblite 在内存中维护了一个名为 records 的字典变量，用来存放一条条的数据。它的 key 是内部维护的 id，从 0 开始自增；而它的 value 则是用户插入的数据，为了后续查询和记录的方便，这里在每条数据中额外又加入了<strong>id</strong>和<strong>version</strong>。其次，内部维护的 indices 字典变量则是是个索引表，它的 key 是字段名，而 value 则是这样一个字典：其 key 是这个字段所有已知的值，value 是这个值所在的那条数据的 id。</p>
<p>举个例子，假设我们插入了“a=-1,b=0,c=1”和“a=0,b=1,c=2”两条数据，那么 records 和 indices 的内容会是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># records</span></span><br><span class="line">&#123;<span class="number">0</span>: &#123;<span class="string">'__id__'</span>: <span class="number">0</span>, <span class="string">'__version__'</span>: <span class="number">0</span>, <span class="string">'a'</span>: <span class="number">-1</span>, <span class="string">'b'</span>: <span class="number">0</span>, <span class="string">'c'</span>: <span class="number">1</span>&#125;,</span><br><span class="line"> <span class="number">1</span>: &#123;<span class="string">'__id__'</span>: <span class="number">1</span>, <span class="string">'__version__'</span>: <span class="number">0</span>, <span class="string">'a'</span>: <span class="number">0</span>, <span class="string">'b'</span>: <span class="number">1</span>, <span class="string">'c'</span>: <span class="number">2</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># indices</span></span><br><span class="line">&#123;<span class="string">'a'</span>: &#123;<span class="number">-1</span>: [<span class="number">0</span>], <span class="number">0</span>: [<span class="number">1</span>]&#125;, <span class="string">'b'</span>: &#123;<span class="number">0</span>: [<span class="number">0</span>], <span class="number">1</span>: [<span class="number">1</span>]&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>比方说现在我们想查找 a=0 的数据，那么就会在 indices 中找 key 为’a’的 value，即{-1: set([0]), 0: set([1])}，然后在这里面找 key 为 0 的 value，即[1]，由此我们直到了我们想要的这条数据它的 id 是 1（也可能会有多个）；假设我们对数据还有其他要求比如 a=0,b=1，那么它会继续上述的查找过程，找到 a=0 和 b=1 分别对应的 ids，做交集，就得到了满足这两个条件的 ids，然后再到 records 里根据 ids 找到所有对应的数据。</p>
<p>明白了原理，我们再看看有什么可优化的地方：</p>
<p>数据结构，整体的 records 和 indeices 数据结构已经挺精简了，暂时不需要优化。其中的<strong>version</strong>可以不要，因为我们并不关注这个数据被修改了几次。其次是由于 indices 中最终的 ids 是个 list，在查询和插入的时候会比较慢，我们知道内部维护的 id 一定是唯一的，所以这里改成 set 会好一些。</p>
<p>python 语句，不难看出，整个_Base 为了同时兼容 python2 和 python3，不得不使用了 2 和 3 都支持的语句，这就导致在部分语句上针对特定版本的 python 就会造成浪费或者说是性能开销。比如说，d 是个字典，那么为了同事兼容 python2 和 3，作者使用了类似与 for key in d.keys()这样的语句，在 python2 中，d.keys()会首先产生一个 list，用 d.iterkeys 是个更明智的方案。再如，作者会使用类似 set(d.keys()) - set([1])这样的语句，但是 python2 中，使用 d.viewkeys() - set([1])效率将会更高，因为它不需要将 list 转化成 set。</p>
<p>对特定版本 python 的优化语句就不一一举例，概括地说，从数据结构，python 语句以及是否需要某些功能等方面可以对 pydblite 做进一步的优化。前面只是说了 create 和 create_index 两个函数，包括 insert 和<strong>call</strong>的优化也十分类似。此外，用普通方法来代替魔法方法，也能稍微提升下效率，所以在后续的优化中将<strong>call</strong>改写为了 query。</p>
<p>优化后的代码，请见 MemLite。</p>
<h2 id="memlite、pydblite-和-sqlite-的性能"><a href="#memlite、pydblite-和-sqlite-的性能" class="headerlink" title="memlite、pydblite 和 sqlite 的性能"></a>memlite、pydblite 和 sqlite 的性能</h2><p>让我们在上文的测试代码中加入对 memlite 的测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@timeit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_query_method</span><span class="params">(mdb, des=<span class="string">''</span>)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(count):</span><br><span class="line">        c = mdb.query(a=i<span class="number">-1</span>, b=i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'-------memlite-------'</span></span><br><span class="line"><span class="keyword">import</span> memlite</span><br><span class="line">db = memlite.Base()</span><br><span class="line">db.create(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>)</span><br><span class="line">db.create_index(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">test_insert(db, des=<span class="string">'insert'</span>)</span><br><span class="line">test_query_method(db, des=<span class="string">'query, method call'</span>)</span><br></pre></td></tr></table></figure>
<p>在创建索引的情况下，10w 次的插入和查询的时间如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-------memlite-------</span><br><span class="line">0.378000020981 insert</span><br><span class="line">0.285000085831 query, method call</span><br><span class="line">-------pydblite--------</span><br><span class="line">1.3140001297 insert</span><br><span class="line">0.309000015259 query, object call</span><br><span class="line">-------sqlite3--------</span><br><span class="line">0.414000034332 insert</span><br><span class="line">0.3109998703 query</span><br></pre></td></tr></table></figure>
<p>在未创建索引的情况（把创建索引的测试语句注释掉）下，1w 次的插入和查询时间如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-------memlite-------</span><br><span class="line">0.0179998874664 insert</span><br><span class="line">5.90199995041 query, method call</span><br><span class="line">-------pydblite--------</span><br><span class="line">0.0980000495911 insert</span><br><span class="line">4.87400007248 query, object call</span><br><span class="line">-------sqlite3--------</span><br><span class="line">0.0170001983643 insert</span><br><span class="line">7.42399978638 query</span><br></pre></td></tr></table></figure>
<p>可以看出，在创建索引的情况下，memlite 的插入和查询性能在 sqlite 和 pydblite 之上；而在未创建索引的情况下，memlite 的插入性能和 sqlite 一样，好于 pydblite，memlite 的查询性能比 pydblite 稍差，但好于 sqlite。综合来看，memlite 即拥有 pydblite 的 pythonic 的使用方式，又拥有 pydblite 和 sqlite 中性能较高者的效率，符合预期的优化目标。</p>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>内存数据库</tag>
        <tag>内存数据引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 2003上 SaltStack/Salt 和 psutil 可能存在的问题及解决</title>
    <url>/2019/10/20/Windows-2003%E4%B8%8A-SaltStack-Salt-%E5%92%8C-psutil-%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<p>（备注：本文是之前在博客园中发表的文章，因为老博客不再维护，把有价值的博文转移到这里。）</p>
<p>之前把 salt 安装在 windows 2003 上，发现无法启动，随之而来的是一个有一个的坑，让我们一起逐个排查。</p>
<a id="more"></a>
<h2 id="问题一（salt-无法启动）"><a href="#问题一（salt-无法启动）" class="headerlink" title="问题一（salt 无法启动）"></a>问题一（salt 无法启动）</h2><p>salt 无法启动，错误结果如图：</p>
<img src="/2019/10/20/Windows-2003上-SaltStack-Salt-和-psutil-可能存在的问题及解决/1.png">
<h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>这种错误完全无厘头呀，本着相信 salt 的原则，我们看看 python 能不能正常启动，由此产生新的问题。</p>
<h2 id="问题二（python-无法启动）"><a href="#问题二（python-无法启动）" class="headerlink" title="问题二（python 无法启动）"></a>问题二（python 无法启动）</h2><p>启动 C:\salt\bin\python，发现仍旧无法启动。这就奇怪了，我有理由相信这可能是 salt 自带的 python 的问题。那么从 Python 的官网下载个新包 Python2.7.12 看看，安装后发现官网的 Python 启动正常。莫非是初始化了一些环境变量？回过头来再去看 salt 中的 python 能不能用，奇迹般地好了~</p>
<h3 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h3><p>重新安装一次官网的 Python，然后再启动 salt 中的 python 试试。</p>
<p>原因在于，这台 windows 2003 原来装过 python，但可能因为后来卸载不彻底，以及中间各种软件安装影响了一些环境变量，导致 salt 中 python 无法正常启动。</p>
<h2 id="问题三（缺少-MSCVCR100-dll）"><a href="#问题三（缺少-MSCVCR100-dll）" class="headerlink" title="问题三（缺少 MSCVCR100.dll）"></a>问题三（缺少 MSCVCR100.dll）</h2><p>既然 python 启动问题已经搞定，那就再去启动 salt-minion 吧。这次开启 debug 模式，看看能否正常启动，启动不了也会有详细信息。执行 C:\salt\salt-minion-debug.bat，结果没过多久报了这个错：</p>
<img src="/2019/10/20/Windows-2003上-SaltStack-Salt-和-psutil-可能存在的问题及解决/2.png">
<h3 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h3><p>既然 windows 2003 这位老先生明确告诉我们缺少了 MSVCR100.dll 这个动态链接库，那就找到它吧。这个库是 vc++2010 里的，所以从微软的官网下载 Microsoft Visual C++ 2010 可再发行组件包 (x86)， 安装完毕后，再启动 salt-minion 就不会报错了。</p>
<h2 id="问题四（psutil-中-‘from-import-psutil-windows-as-cext’-报错）"><a href="#问题四（psutil-中-‘from-import-psutil-windows-as-cext’-报错）" class="headerlink" title="问题四（psutil 中 ‘from . import _psutil_windows as cext’ 报错）"></a>问题四（psutil 中 ‘from . import _psutil_windows as cext’ 报错）</h2><p>由于项目中用到 psutil，自然想到要检验下 salt 自带的 python 第三方 psutil 能否正常使用，结果很遗憾：</p>
<img src="/2019/10/20/Windows-2003上-SaltStack-Salt-和-psutil-可能存在的问题及解决/3.png">
<p>这是什么鬼？不能导入的原因太模糊了吧，dll 导入失败？！哪个 dll？</p>
<p>去报错相应的目录下看看吧，也就是 C:\salt\bin\lib\site-packages\psutil\下，发现要导入的_psutil_windows 包其实是_psutil_windows.pyd 这个链接库。导入这个链接库失败，那么就看看这个链接库到底链接了什么东西。</p>
<p>使用 <a href="http://dependencywalker.com/" target="_blank" rel="noopener">dependency walker</a> 去瞅瞅，发现是这样的问题：</p>
<img src="/2019/10/20/Windows-2003上-SaltStack-Salt-和-psutil-可能存在的问题及解决/4.png">
<h3 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h3><p>把缺失的这两个 dll（msvcr90.dll, msjava.dll）补上？补上后仍然有问题，看下文。</p>
<h2 id="问题五（At-least-one-module-has-an-unresolved-import-…）"><a href="#问题五（At-least-one-module-has-an-unresolved-import-…）" class="headerlink" title="问题五（At least one module has an unresolved import …）"></a>问题五（At least one module has an unresolved import …）</h2><p>补上两个 dll 后，还显示一个错误：</p>
<img src="/2019/10/20/Windows-2003上-SaltStack-Salt-和-psutil-可能存在的问题及解决/5.png">
<p>根据图片中的显示，大概是 iphlpapi.dll 和 kernel32.dll 的导入或被导入出现了问题。但是这两个是系统的呀，能奈之何？</p>
<p>先不管这个错误，尝试运行下 python，然后 import psutil，看看会不会报错：</p>
<img src="/2019/10/20/Windows-2003上-SaltStack-Salt-和-psutil-可能存在的问题及解决/6.png">
<p>看来还是老错误，无法避免。</p>
<p>会不会是 salt 预装的 psutil 有问题？去 C:\salt\bin\scripts\下，pip uninstall psutil 卸载掉再重装试试，结果还是不行。</p>
<p>这就非常奇怪，突发奇想该不会是高版本的 psutil 不支持低版本的系统导致的吧？于是再次卸载掉 psutil，装了个 1.x 版本试验了下，结果可以了。</p>
<h3 id="解决-4"><a href="#解决-4" class="headerlink" title="解决"></a>解决</h3><p>安装一个低版本的 psutil 试试，注意你用到的 psutil 的功能在低版本中可能不存在。</p>
<h2 id="问题六（salt-模块依赖的-wmi-可以用吗？）"><a href="#问题六（salt-模块依赖的-wmi-可以用吗？）" class="headerlink" title="问题六（salt 模块依赖的 wmi 可以用吗？）"></a>问题六（salt 模块依赖的 wmi 可以用吗？）</h2><p>从 <a href="https://docs.saltstack.com/en/latest/topics/installation/windows.html" target="_blank" rel="noopener">salt 官网</a>上看到关于 windows 2003 这样的描述：</p>
<img src="/2019/10/20/Windows-2003上-SaltStack-Salt-和-psutil-可能存在的问题及解决/7.png">
<p>貌似是 wmi 需要额外安装。</p>
<p>那就先看看 wmi 能不能正常导入吧：</p>
<p>很好，wmi 库可以正常导入，项目要用到的 wmic（第一次在 cmd 中输入，会自动安装）也能正常使用，皆大欢喜。</p>
<img src="/2019/10/20/Windows-2003上-SaltStack-Salt-和-psutil-可能存在的问题及解决/8.png">
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在低版本的系统上，可能会有各种各样想不到的坑。再次做个记录留作备忘，也给将来可能踩坑的同学借鉴经验。</p>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>DevOps</category>
        <category>SaltStack</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Salt</tag>
        <tag>SaltStack</tag>
        <tag>Windows</tag>
        <tag>DevOps</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：深入 docopt</title>
    <url>/2019/10/15/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9A%E6%B7%B1%E5%85%A5-docopt/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在第一篇“初探 docopt”的文章中，我们初步掌握了使用 <code>docopt</code> 的三个步骤，了解了它不同于 <code>argparse</code> 的设计思路。<br>那么 <code>docopt</code> 的使用模式都有哪些呢？其接口描述中都支持哪些语法规则呢？本文将带你深入了解 <code>docopt</code>。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<h2 id="使用模式"><a href="#使用模式" class="headerlink" title="使用模式"></a>使用模式</h2><p>在上一篇文章中我们提到 <code>docopt</code> 是通过定义一个包含特定内容的字符串，也就是接口描述，来达到描述命令行功能的目的。<br>那么接口描述的总体规则是这样的：</p>
<ul>
<li>位于关键字 <code>usage:</code> （大小写不敏感）和一个可见的空行之间的文本内容会被解释为一个个使用模式。</li>
<li><code>useage:</code> 后的第一个词会被解释为程序的名称，比如下面就是一个没有命令行参数的示例程序：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: cli</span><br></pre></td></tr></table></figure>
<ul>
<li>接口描述中可以包含很多有各种元素的模式，以描述命令行用法，比如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  cli command --option &lt;argument&gt;</span><br><span class="line">  cli [&lt;optional-argument&gt;]</span><br><span class="line">  cli --another-option=&lt;with-argument&gt;</span><br><span class="line">  cli (--either-that-option | &lt;or-this-argument&gt;)</span><br><span class="line">  cli &lt;repeating-argument&gt; &lt;repeating-argument&gt;...</span><br></pre></td></tr></table></figure>
<h3 id="位置参数："><a href="#位置参数：" class="headerlink" title="位置参数： "></a>位置参数： <argument></argument></h3><p>使用 <code>&lt;</code> 和 <code>&gt;</code> 包裹的参数会被解释为位置参数。</p>
<p>比如，我们可以指定两个位置参数 <code>x</code> 和 <code>y</code> ，先添加的 <code>x</code> 位于第一个位置，后加入的 <code>y</code> 位于第二个位置。那么在命令行中输入 <code>1 2</code>的时候，分别对应到的就是 <code>x</code> 和 <code>y</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Usage: cli &lt;x&gt; &lt;y&gt;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> docopt <span class="keyword">import</span> docopt</span><br><span class="line"></span><br><span class="line">arguments = docopt(__doc__, argv=[<span class="string">'1'</span>, <span class="string">'2'</span>])</span><br><span class="line">print(arguments)</span><br></pre></td></tr></table></figure>
<p>其输出为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'&lt;x&gt;'</span>: <span class="string">'1'</span>,</span><br><span class="line"> <span class="string">'&lt;y&gt;'</span>: <span class="string">'2'</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选项参数：-o-–option"><a href="#选项参数：-o-–option" class="headerlink" title="选项参数： -o –option"></a>选项参数： -o –option</h3><p>以单个破折号（<code>-</code>）开头的的参数为短选项，以双破折号（<code>--</code>）开头的参数为长选项。</p>
<ul>
<li>短选项支持集中表达多个短选项，比如 <code>-abc</code> 等价于 <code>-a</code>、<code>-b</code> 和 <code>-c</code></li>
<li>长选项后可跟参数，通过 <code>空格</code> 或 <code>=</code> 指定，比如 <code>--input ARG</code> 等价于 <code>--input=ARG</code></li>
<li>短选项后可跟参数，通可选的 <code>空格</code> 指定，比如 <code>-f FILE</code> 等价于 <code>-fFILE</code></li>
</ul>
<p>在下面这个例子中，我们希望通过 <code>-n</code> h 或 <code>--name</code> 来指定名字：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">  cli [options]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">  -n, --name NAME   Set name.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> docopt <span class="keyword">import</span> docopt</span><br><span class="line"></span><br><span class="line">arguments = docopt(__doc__, argv=[<span class="string">'-n'</span>, <span class="string">'Eric'</span>])</span><br><span class="line">print(arguments)</span><br><span class="line"></span><br><span class="line">arguments = docopt(__doc__, argv=[<span class="string">'-nEric'</span>])</span><br><span class="line">print(arguments)</span><br><span class="line"></span><br><span class="line">arguments = docopt(__doc__, argv=[<span class="string">'--name'</span>, <span class="string">'Eric'</span>])</span><br><span class="line">print(arguments)</span><br><span class="line"></span><br><span class="line">arguments = docopt(__doc__, argv=[<span class="string">'--name=Eric'</span>])</span><br><span class="line">print(arguments)</span><br></pre></td></tr></table></figure>
<p>上面的示例中，我们通过 4 种方式（2 个短选项参数方式和 2 个长选项参数方式）来指定命令行输入，其输出均为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'--name'</span>: <span class="string">'Eric'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是：</p>
<p><code>--input ARG</code>（而不是 <code>--input=ARG</code>）的含义是模糊不清的，因为这不能看出 <code>ARG</code> 究竟是选项参数，<br>还是位置参数。在 <code>docopt</code> 的使用模式中，只有在接口描述中定义了对应选项才会被解释为一个带参数的选项，<br>否则就会被解释为一个选项和一个独立的位置参数。</p>
<p><code>-f FILE</code> 和 <code>-fFILE</code> 这种写法也有同样的模糊点。后者无法说明这究竟是一系列短选项的集合，<br>还是一个带参数的选项。只有在接口描述中定义了对应选项才会被解释为一个带参数的选项。</p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>这里的命令也就是 <code>argparse</code> 中嵌套解析器所要完成的事情，准确的说，对整个命令行程序来说，实现的是子命令。</p>
<p>在 <code>docopt</code> 中，凡是不符合 <code>--options</code> 或 <code>&lt;arguments&gt;</code> 约定的词，均会被解释为子命令。</p>
<p>在下面这个例子中，我们支持 <code>create</code> 和 <code>delete</code> 两个子命令，用来创建或删除指定路径。而 <code>delete</code> 命令支持 <code>--recursive</code> 参数来表明是否递归删除指定路径：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">  cli create</span></span><br><span class="line"><span class="string">  cli delete [--recursive]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">  -r, --recursive   Recursively remove the directory.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> docopt <span class="keyword">import</span> docopt</span><br><span class="line"></span><br><span class="line">arguments = docopt(__doc__)</span><br><span class="line">print(arguments)</span><br></pre></td></tr></table></figure>
<p>直接指定 <code>delete -r</code>，输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 cli.py delete -r</span><br><span class="line"></span><br><span class="line">&#123;<span class="string">'--recursive'</span>: True,</span><br><span class="line"> <span class="string">'create'</span>: False,</span><br><span class="line"> <span class="string">'delete'</span>: True&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可选元素：-optional-elements"><a href="#可选元素：-optional-elements" class="headerlink" title="可选元素： [optional elements]"></a>可选元素： [optional elements]</h3><p>以中括号“[]”包裹的元素（选项、参数和命令）均会被标记为可选。多个元素放在一对中括号中或各自放在中括号中是等价的。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: cli [<span class="built_in">command</span> --option &lt;argument&gt;]</span><br></pre></td></tr></table></figure>
<p>等价于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: cli [<span class="built_in">command</span>] [--option] [&lt;argument&gt;]</span><br></pre></td></tr></table></figure>
<h3 id="必填元素：-required-elements"><a href="#必填元素：-required-elements" class="headerlink" title="必填元素： (required elements)"></a>必填元素： (required elements)</h3><p>没被中括号“[]”包裹的所有元素默认都是必填的。但有时候使用小括号“()”将元素包裹住，用以标记必填是有必要的。<br>比如，要将多个互斥元素进行分组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: my_program (--either-this &lt;and-that&gt; | &lt;or-this&gt;)</span><br></pre></td></tr></table></figure>
<p>另一个例子是，当出现一个参数时，也要求提供另一个参数，那么就可以这么写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: my_program [(&lt;one-argument&gt; &lt;another-argument&gt;)]</span><br></pre></td></tr></table></figure>
<p>这个例子中，<code>&lt;one-argument&gt;</code> 和 <code>&lt;another-argument&gt;</code> 要么都出现，要么都不出现。</p>
<h3 id="互斥参数：-element-another"><a href="#互斥参数：-element-another" class="headerlink" title="互斥参数： element|another"></a>互斥参数： element|another</h3><p>在 <code>argparse</code> 中要想实现互斥参数，还需要先调用 <code>parser.add_mutually_exclusive_group()</code> 添加互斥组，<br>再在组里添加参数。而在 <code>docopt</code> 中就特别简单，直接使用 <code>|</code> 进行分隔：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: my_program go (--up | --down | --left | --right)</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，使用小括号“()”来对四个互斥选项分组，要求必填其中一个选项。<br>在下面的示例中，使用中括号“()”来对四个互斥选项分组，可以不填，或填其中一个选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: my_program go [--up | --down | --left | --right]</span><br></pre></td></tr></table></figure>
<p>我们还可以发散一下思路，子命令天然需要互斥，那么除了这种写法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: my_program run [--fast]</span><br><span class="line">       my_program jump [--high]</span><br></pre></td></tr></table></figure>
<p>使用如下 <code>|</code> 的写法，也是等价的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: my_program (run [--fast] | jump [--high])</span><br></pre></td></tr></table></figure>
<h3 id="可变参数列表：-element…"><a href="#可变参数列表：-element…" class="headerlink" title="可变参数列表： element…"></a>可变参数列表： element…</h3><p>可变参数列表也就是定义参数可以有多个值。在 <code>argparse</code> 中，我们通过 <code>parser.add_argument(&#39;--foo&#39;, nargs=&#39;?&#39;)</code> 来指定，其中 <code>nargs</code> 可以是数字、<code>?</code>、<code>+</code>、<code>*</code>来表示参数个数。</p>
<p>在 <code>docopt</code> 中，自然也有相同的能力，使用省略号 <code>...</code> 来实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: my_program open &lt;file&gt;...</span><br><span class="line">       my_program move (&lt;from&gt; &lt;to&gt;)...</span><br></pre></td></tr></table></figure>
<p>若要参数提供 N 个，则写 N 个参数即可，比如下面的示例中要求提供 2 个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage: my_program &lt;file&gt; &lt;file&gt;</span><br></pre></td></tr></table></figure>
<p>若要参数提供 0 个或多个，则配合中括号“[]”进行定义，如下 3 中定义方式等价：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: my_program [&lt;file&gt;...]</span><br><span class="line">       my_program [&lt;file&gt;]...</span><br><span class="line">       my_program [&lt;file&gt; [&lt;file&gt; ...]]</span><br></pre></td></tr></table></figure>
<p>若要参数提供 1 个或多个，则可以这么写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: my_program &lt;file&gt;...</span><br></pre></td></tr></table></figure>
<p>在下面完整示例中，所获得的 <code>arguments</code> 是 <code>{&#39;&lt;file&gt;&#39;: [&#39;f1&#39;, &#39;f2&#39;]}</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">  cli &lt;file&gt;...</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> docopt <span class="keyword">import</span> docopt</span><br><span class="line"></span><br><span class="line">arguments = docopt(__doc__, argv=[<span class="string">'f1'</span>, <span class="string">'f2'</span>])</span><br><span class="line">print(arguments)</span><br></pre></td></tr></table></figure>
<h3 id="选项简写：-options"><a href="#选项简写：-options" class="headerlink" title="选项简写： [options]"></a>选项简写： [options]</h3><p>“[options]”用于简写选项，比如下面的示例中定义了 3 个选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: my_program [--all --long --human-readable] &lt;path&gt;</span><br><span class="line"></span><br><span class="line">--all             List everything.</span><br><span class="line">--long            Long output.</span><br><span class="line">--human-readable  Display <span class="keyword">in</span> human-readable format.</span><br></pre></td></tr></table></figure>
<p>可以简写为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: my_program [options] &lt;path&gt;</span><br><span class="line"></span><br><span class="line">--all             List everything.</span><br><span class="line">--long            Long output.</span><br><span class="line">--human-readable  Display <span class="keyword">in</span> human-readable format.</span><br></pre></td></tr></table></figure>
<p>如果一个模式中有多个选项，那么这会很有用。</p>
<p>另外，如果选项包含长短选项，那么也可以用它们中的任意一个写在模式中，比如下面的示例的模式中均使用短选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: my_program [-alh] &lt;path&gt;</span><br><span class="line"></span><br><span class="line">-a, --all             List everything.</span><br><span class="line">-l, --long            Long output.</span><br><span class="line">-h, --human-readable  Display <span class="keyword">in</span> human-readable format.</span><br></pre></td></tr></table></figure>
<h3 id="–"><a href="#–" class="headerlink" title="[–]"></a>[–]</h3><p>当双破折号“–”不是选项时，通常用于分隔选项和位置参数，以便处理例如将文件名误认为选项的情况。<br>为了支持此约定，需要在位置参数前添加 <code>[--]</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: my_program [options] [--] &lt;file&gt;...</span><br></pre></td></tr></table></figure>
<h3 id><a href="#" class="headerlink" title="[-]"></a>[-]</h3><p>当单破折号“-”不是选项时，通常用于表示程序应处理 <code>stdin</code>，而非文件。为了支持此约定，需要在使用模式中加入 <code>[-]</code>。</p>
<h3 id="选项描述"><a href="#选项描述" class="headerlink" title="选项描述"></a>选项描述</h3><p>选项描述就是描述一系列选项参数的模式。如果使用模式中的选项定义是清晰的，那么选项描述就是可选的。</p>
<p>选项描述可以定义如下内容：</p>
<ul>
<li>短选项和长选项代表相同含义</li>
<li>带参数的选项</li>
<li>有默认值的选项参数</li>
</ul>
<p>选项描述的每一行需要以 <code>-</code> 或 <code>--</code> 开头（不算空格），比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Options:</span><br><span class="line">  --verbose   <span class="comment"># 好</span></span><br><span class="line">  -o FILE     <span class="comment"># 好</span></span><br><span class="line">Other: --bad  <span class="comment"># 坏, 没有以 "-" 开头</span></span><br></pre></td></tr></table></figure>
<p>选项描述中，使用空格或“=”来连接选项和参数，以定义带选项的参数。参数可以使用<code>&lt;Arg&gt;</code>的形式，<br>或是使用<code>ARG</code>大写字母的形式。可用逗号“,”来分隔长短选项。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-o FILE --output=FILE       <span class="comment"># 没有逗号 长选项使用 "=" 分隔</span></span><br><span class="line">-i &lt;file&gt;, --input &lt;file&gt;   <span class="comment"># 有逗号, 长选项使用空格分隔</span></span><br></pre></td></tr></table></figure>
<p>选项描述中每个选项定义和说明之间要有两个空格，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--verbose MORE text.    <span class="comment"># 坏, 会被认为是带参数 MORE 的选项</span></span><br><span class="line">                        <span class="comment"># --version 和 MORE text. 之间应该有2个空格</span></span><br><span class="line">-q        Quit.         <span class="comment"># 好</span></span><br><span class="line">-o FILE   Output file.  <span class="comment"># 好</span></span><br><span class="line">--stdout  Use stdout.   <span class="comment"># 好，2个空格</span></span><br></pre></td></tr></table></figure>
<p>选项描述中在说明中使用 <code>[default: &lt;default-value&gt;]</code> 来给带参数的选项赋以默认值，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--coefficient=K  The K coefficient [default: 2.95]</span><br><span class="line">--output=FILE    Output file [default: test.txt]</span><br><span class="line">--directory=DIR  Some directory [default: ./]</span><br></pre></td></tr></table></figure>
<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>关于 <code>docopt</code> 的方方面面我们都了解的差不多了，回过头来看，对于命令行元信息的定义，它比 <code>argparse</code> 要来的更加简洁。<br><code>argparse</code> 像是命令式编程，调用一个个的函数逐步将命令行元信息定义清楚；而 <code>docopt</code> 则像是声明式编程，通过声明定义命令行元信息。<br>两者站在的维度不同，编程的套路也不尽相同，甚是有趣。</p>
<p>了解了这么多，也该练练手了。在下篇文章中，我们仍然会以 <code>git</code> 命令作为实战项目，看看如何使用 <code>docopt</code> 来实现 <code>git</code> 命令。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>docopt</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：初探 docopt</title>
    <url>/2019/10/09/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9A%E5%88%9D%E6%8E%A2-docopt/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在本系列前面四篇文章中，我们介绍了 <code>argparse</code> 的方方面面。它无疑是强大的，但使用方式上略显麻烦。需要先设置解析器，再定义参数，再解析命令行，最后实现业务逻辑。</p>
<p>而今天要介绍的 <a href="http://docopt.org/" target="_blank" rel="noopener">docopt</a> 则是站在一个全新的视角来审视命令行。你可曾想过，一个命令行程序的帮助信息其实已然包含了这个命令行的完整元信息，那么是否可以通过定义帮助信息来定义命令行呢？<code>docopt</code> 就是基于这样的想法去设计的。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="http://docopt.org/" target="_blank" rel="noopener">docopt</a> 基于长久以来在帮助信息和手册中描述程序接口的约定，其接口描述是形式化的帮助信息。它能够根据命令行程序中定义的接口描述，来自动生成解析器。</p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="定义接口描述-帮助信息"><a href="#定义接口描述-帮助信息" class="headerlink" title="定义接口描述/帮助信息"></a>定义接口描述/帮助信息</h3><p>第一步要做的就是命令行程序的定义接口描述或者是帮助信息，这样 <code>docopt</code> 就能知道命令行的元信息，从而自动解析。</p>
<p>接口描述通常定义在一个模块的文档字符串中，我们仍然以在 <code>Python 命令行之旅：初探 argparse</code> 的例子为例，讲解如何使用 <code>docopt</code> 来定义接口描述。</p>
<p>在 <code>cmd.py</code> 中，我们定义如下接口描述：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">"""Num accumulator.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">  cmd.py [--sum] &lt;num&gt;...</span></span><br><span class="line"><span class="string">  cmd.py (-h | --help)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">  -h --help     Show help.</span></span><br><span class="line"><span class="string">  --sum         Sum the nums (default: find the max).</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>在上面的接口描述中，我们定义了命令行程序 <code>cmd.py</code> 接受一个或多个数字 <code>num</code>，而 <code>--sum</code> 选项则是可选，<code>-h</code> 或 <code>--help</code> 则输出帮助信息。</p>
<p>若提供 <code>--sum</code>，则累加给定的数字；反之，取给定多个数字中最大的一个。这个业务逻辑我们将在后文实现。</p>
<h3 id="解析命令行"><a href="#解析命令行" class="headerlink" title="解析命令行"></a>解析命令行</h3><p>定义好接口描述后，就可以使用 <code>docopt</code> 进行解析，写法非常简单：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> docopt <span class="keyword">import</span> docopt</span><br><span class="line"></span><br><span class="line">arguments = docopt(__doc__, options_first=<span class="keyword">True</span>)</span><br><span class="line">print(arguments)</span><br></pre></td></tr></table></figure>
<p>由于我们之前是将接口描述定义在模块的文档字符串中，那么直接使用 <code>__doc__</code> 即可获得接口描述。然后使用 <code>docopt</code> 函数即可解析命令行为参数字典。为了支持负数，我们将 <code>options_first</code> 设置为 <code>True</code>。</p>
<p>当我们执行 <code>python3 cmd.py --sum 1 2 3</code> 时，将会得到如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">'--help'</span>: False,</span><br><span class="line"> <span class="string">'--sum'</span>: True,</span><br><span class="line"> <span class="string">'&lt;num&gt;'</span>: [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到：</p>
<ul>
<li>没有提供 <code>-h</code> 或者 <code>--help</code>，所以 <code>arguments</code> 中 <code>--help</code> 为 <code>False</code></li>
<li>提供了 <code>--sum</code>，所以 <code>arguments</code> 中 <code>--sum</code> 为 <code>True</code></li>
<li>提供了 <code>&lt;num&gt;...</code> 为 <code>1 2 3</code>，所以 <code>arguments</code> 中 <code>&lt;num&gt;</code> 为 <code>[&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</code></li>
</ul>
<h3 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h3><p>获得了解析后的命令行参数，我们就可以根据自己的业务需求做进一步处理了。<br>在本文示例中，我们希望当用户提供 <code>--sum</code> 选项时，是对给定的一组数字求和；反之则是取最大值，那么就可以这么写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = (int(num) <span class="keyword">for</span> num <span class="keyword">in</span> arguments[<span class="string">'&lt;num&gt;'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> arguments[<span class="string">'--sum'</span>]:</span><br><span class="line">    result = sum(nums)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    result = max(nums)</span><br><span class="line"></span><br><span class="line">print(result) <span class="comment"># 基于上文的 python3 cmd.py --sum 1 2 3 参数，其结果为 6</span></span><br></pre></td></tr></table></figure>
<h3 id="代码梳理"><a href="#代码梳理" class="headerlink" title="代码梳理"></a>代码梳理</h3><p>使用 <code>docopt</code> 的方式非常简单，我们将上文的代码汇总下，以有一个更清晰的认识：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cmd.py</span></span><br><span class="line"><span class="comment"># 1. 定义接口描述</span></span><br><span class="line"><span class="string">"""Num accumulator.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">  cmd.py [--sum] &lt;num&gt;...</span></span><br><span class="line"><span class="string">  cmd.py (-h | --help)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">  -h --help     Show help.</span></span><br><span class="line"><span class="string">  --sum         Sum the nums (default: find the max).</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> docopt <span class="keyword">import</span> docopt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 解析命令行</span></span><br><span class="line">arguments = docopt(__doc__, options_first=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 业务逻辑</span></span><br><span class="line">nums = (int(num) <span class="keyword">for</span> num <span class="keyword">in</span> arguments[<span class="string">'&lt;num&gt;'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> arguments[<span class="string">'--sum'</span>]:</span><br><span class="line">    result = sum(nums)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    result = max(nums)</span><br><span class="line"></span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p>若我们需要对一组数字求和，只需执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 cmd.py --sum 1 0 -1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>若我们需要对一组数字求最大值，只需执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 cmd.py 1 0 -1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>我们还可以通过 <code>-h</code> 或 <code>--help</code> 参数查看使用说明和帮助，也就是我们定义的接口描述。</p>
<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p><code>docopt</code> 的思路非常简单，就是定义接口描述，然后帮你解析命令行为参数字典，接下来就根据这个字典来编写业务逻辑。</p>
<p>重点就是在于如何定义接口描述，在下一篇文章中，我们来深入了解下如何定义命令、选项、位置参数等接口描述。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>docopt</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊 Python 的单元测试框架（三）：最火的 pytest</title>
    <url>/2019/09/25/%E8%81%8A%E8%81%8A-Python-%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%9C%80%E7%81%AB%E7%9A%84-pytest/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>本篇文章是《聊聊 Python 的单元测试框架》的第三篇，前两篇分别介绍了标准库 unittest 和第三方单元测试框架 nose。作为本系列的最后一篇，压轴出场的是 Python 世界中最火的第三方单元测试框架：pytest。</p>
<blockquote>
<p>pytest 项目地址：<a href="https://github.com/pytest-dev/pytest" target="_blank" rel="noopener">https://github.com/pytest-dev/pytest</a></p>
</blockquote>
<a id="more"></a>
<p>它有如下主要特性：</p>
<ul>
<li><a href="https://docs.pytest.org/en/latest/assert.html" target="_blank" rel="noopener">assert</a> 断言失败时输出详细信息（再也不用去记忆 <code>self.assert*</code> 名称了）</li>
<li><a href="https://docs.pytest.org/en/latest/goodpractices.html#python-test-discovery" target="_blank" rel="noopener">自动发现</a> 测试模块和函数</li>
<li><a href="https://docs.pytest.org/en/latest/fixture.html" target="_blank" rel="noopener">模块化夹具</a> 用以管理各类测试资源</li>
<li>对 <code>unittest</code> 完全兼容，对 <code>nose</code> <a href="http://pytest.org/en/latest/nose.html#unsupported-idioms-known-issues" target="_blank" rel="noopener">基本兼容</a></li>
<li>非常丰富的插件体系，有超过 315 款<a href="http://plugincompat.herokuapp.com/" target="_blank" rel="noopener">第三方插件</a>，社区繁荣</li>
</ul>
<p>和前面介绍 <code>unittest</code> 和 <code>nose</code> 一样，我们将从如下几个方面介绍 <code>pytest</code> 的特性。</p>
<h2 id="用例编写"><a href="#用例编写" class="headerlink" title="用例编写"></a>用例编写</h2><p>同 <code>nose</code> 一样，<code>pytest</code> 支持函数、测试类形式的测试用例。最大的不同点是，你可以尽情地使用 <code>assert</code> 语句进行断言，丝毫不用担心它会在 <code>nose</code> 或 <code>unittest</code> 中产生的缺失详细上下文信息的问题。</p>
<p>比如下面的测试示例中，故意使得 <code>test_upper</code> 中断言不通过：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_upper</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="string">'foo'</span>.upper() == <span class="string">'FOO1'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_one</span><span class="params">(self)</span>:</span></span><br><span class="line">        x = <span class="string">"this"</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="string">"h"</span> <span class="keyword">in</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_two</span><span class="params">(self)</span>:</span></span><br><span class="line">        x = <span class="string">"hello"</span></span><br><span class="line">        <span class="keyword">with</span> pytest.raises(TypeError):</span><br><span class="line">            x + []</span><br></pre></td></tr></table></figure>
<p>而当使用 <code>pytest</code> 去执行用例时，它会输出详细的（且是多种颜色）上下文信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=================================== <span class="built_in">test</span> session starts ===================================</span><br><span class="line">platform darwin -- Python 3.7.1, pytest-4.0.1, py-1.7.0, pluggy-0.8.0</span><br><span class="line">rootdir: /Users/prodesire/projects/tests, inifile:</span><br><span class="line">plugins: cov-2.6.0</span><br><span class="line">collected 3 items</span><br><span class="line"></span><br><span class="line">test.py F..                                                                         [100%]</span><br><span class="line"></span><br><span class="line">======================================== FAILURES =========================================</span><br><span class="line">_______________________________________ test_upper ________________________________________</span><br><span class="line"></span><br><span class="line">    def test_upper():</span><br><span class="line">&gt;       assert <span class="string">'foo'</span>.upper() == <span class="string">'FOO1'</span></span><br><span class="line">E       AssertionError: assert <span class="string">'FOO'</span> == <span class="string">'FOO1'</span></span><br><span class="line">E         - FOO</span><br><span class="line">E         + FOO1</span><br><span class="line">E         ?    +</span><br><span class="line"></span><br><span class="line">test.py:4: AssertionError</span><br><span class="line">=========================== 1 failed, 2 passed <span class="keyword">in</span> 0.08 seconds ============================</span><br></pre></td></tr></table></figure>
<p>不难看到，<code>pytest</code> 既输出了测试代码上下文，也输出了被测变量值的信息。相比于 <code>nose</code> 和 <code>unittest</code>，<code>pytest</code> 允许用户使用更简单的方式编写测试用例，又能得到一个更丰富和友好的测试结果。</p>
<h2 id="用例发现和执行"><a href="#用例发现和执行" class="headerlink" title="用例发现和执行"></a>用例发现和执行</h2><p><code>unittest</code> 和 <code>nose</code> 所支持的用例发现和执行能力，<code>pytest</code> 均支持。<br><code>pytest</code> 支持用例自动（递归）发现：</p>
<ul>
<li>默认发现当前目录下所有符合 <code>test_*.py</code> 或 <code>*_test.py</code> 的测试用例文件中，以 <code>test</code> 开头的测试函数或以 <code>Test</code> 开头的测试类中的以 <code>test</code> 开头的测试方法<ul>
<li>使用 <code>pytest</code> 命令</li>
</ul>
</li>
<li>同 <code>nose2</code> 的理念一样，通过在<a href="https://docs.pytest.org/en/latest/example/pythoncollection.html#changing-naming-conventions" target="_blank" rel="noopener">配置文件</a>中指定特定参数，可配置用例文件、类和函数的名称模式（模糊匹配）</li>
</ul>
<p><code>pytest</code> 也支持执行指定用例：</p>
<ul>
<li>指定测试文件路径<ul>
<li><code>pytest /path/to/test/file.py</code></li>
</ul>
</li>
<li>指定测试类<ul>
<li><code>pytest /path/to/test/file.py:TestCase</code></li>
</ul>
</li>
<li>指定测试方法<ul>
<li><code>pytest another.test::TestClass::test_method</code></li>
</ul>
</li>
<li>指定测试函数<ul>
<li><code>pytest /path/to/test/file.py:test_function</code></li>
</ul>
</li>
</ul>
<h2 id="测试夹具（Fixtures）"><a href="#测试夹具（Fixtures）" class="headerlink" title="测试夹具（Fixtures）"></a>测试夹具（Fixtures）</h2><p><code>pytest</code> 的<a href="https://docs.pytest.org/en/latest/fixture.html" target="_blank" rel="noopener">测试夹具</a>和 <code>unittest</code>、<code>nose</code>、<code>nose2</code>的风格迥异，它不但能实现 <code>setUp</code> 和 <code>tearDown</code>这种测试前置和清理逻辑，还其他非常多强大的功能。</p>
<h3 id="声明和使用"><a href="#声明和使用" class="headerlink" title="声明和使用"></a>声明和使用</h3><p><code>pytest</code> 中的测试夹具更像是测试资源，你只需定义一个夹具，然后就可以在用例中直接使用它。得益于 <code>pytest</code> 的依赖注入机制，你无需通过<code>from xx import xx</code>的形式显示导入，只需要在测试函数的参数中指定同名参数即可，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smtp_connection</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> smtplib.SMTP(<span class="string">"smtp.gmail.com"</span>, <span class="number">587</span>, timeout=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_ehlo</span><span class="params">(smtp_connection)</span>:</span></span><br><span class="line">    response, msg = smtp_connection.ehlo()</span><br><span class="line">    <span class="keyword">assert</span> response == <span class="number">250</span></span><br></pre></td></tr></table></figure>
<p>上述示例中定义了一个测试夹具 <code>smtp_connection</code>，在测试函数 <code>test_ehlo</code> 签名中定义了同名参数，则 <code>pytest</code> 框架会自动注入该变量。</p>
<h3 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h3><p>在 <code>pytest</code> 中，同一个测试夹具可被多个测试文件中的多个测试用例共享。只需在包（Package）中定义 <code>conftest.py</code> 文件，并把测试夹具的定义写在该文件中，则该包内所有模块（Module）的所有测试用例均可使用 <code>conftest.py</code> 中所定义的测试夹具。</p>
<p>比如，如果在如下文件结构的 <code>test_1/conftest.py</code> 定义了测试夹具，那么 <code>test_a.py</code> 和 <code>test_b.py</code> 可以使用该测试夹具；而 <code>test_c.py</code> 则无法使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">`-- test_1</span><br><span class="line">|   |-- conftest.py</span><br><span class="line">|   `-- test_a.py</span><br><span class="line">|   `-- test_b.py</span><br><span class="line">`-- test_2</span><br><span class="line">    `-- test_c.py</span><br></pre></td></tr></table></figure>
<h3 id="生效级别"><a href="#生效级别" class="headerlink" title="生效级别"></a>生效级别</h3><p><code>unittest</code> 和 <code>nose</code> 均支持测试前置和清理的生效级别：测试方法、测试类和测试模块。</p>
<p><code>pytest</code> 的测试夹具同样支持各类生效级别，且更加丰富。通过在 <a href="http://pytest.org/en/latest/reference.html#pytest-fixture" target="_blank" rel="noopener">pytest.fixture</a> 中指定 <code>scope</code> 参数来设置：</p>
<ul>
<li>function —— 函数级，即调用每个测试函数前，均会重新生成 fixture</li>
<li>class —— 类级，调用每个测试类前，均会重新生成 fixture</li>
<li>module —— 模块级，载入每个测试模块前，均会重新生成 fixture</li>
<li>package —— 包级，载入每个包前，均会重新生成 fixture</li>
<li>session —— 会话级，运行所有用例前，只生成一次 fixture</li>
</ul>
<p>当我们指定生效级别为模块级时，示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(scope="module")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smtp_connection</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> smtplib.SMTP(<span class="string">"smtp.gmail.com"</span>, <span class="number">587</span>, timeout=<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h3 id="测试前置和清理"><a href="#测试前置和清理" class="headerlink" title="测试前置和清理"></a>测试前置和清理</h3><p><code>pytest</code> 的测试夹具也能够实现测试前置和清理，通过 <code>yield</code> 语句来拆分这两个逻辑，写法变得很简单，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> smtplib</span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.fixture(scope="module")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smtp_connection</span><span class="params">()</span>:</span></span><br><span class="line">    smtp_connection = smtplib.SMTP(<span class="string">"smtp.gmail.com"</span>, <span class="number">587</span>, timeout=<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">yield</span> smtp_connection  <span class="comment"># provide the fixture value</span></span><br><span class="line">    print(<span class="string">"teardown smtp"</span>)</span><br><span class="line">    smtp_connection.close()</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>yield smtp_connection</code> 及前面的语句相当于测试前置，通过 <code>yield</code> 返回准备好的测试资源 <code>smtp_connection</code>;<br>而后面的语句则会在用例执行结束（确切的说是测试夹具的生效级别的声明周期结束时）后执行，相当于测试清理。</p>
<p>如果生成测试资源（如示例中的 <code>smtp_connection</code>）的过程支持 <code>with</code> 语句，那么还可以写成更加简单的形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.fixture(scope="module")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smtp_connection</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> smtplib.SMTP(<span class="string">"smtp.gmail.com"</span>, <span class="number">587</span>, timeout=<span class="number">5</span>) <span class="keyword">as</span> smtp_connection:</span><br><span class="line">        <span class="keyword">yield</span> smtp_connection  <span class="comment"># provide the fixture value</span></span><br></pre></td></tr></table></figure>
<p><code>pytest</code> 的测试夹具除了文中介绍到的这些功能，还有诸如<a href="http://pytest.org/en/latest/fixture.html#parametrizing-fixtures" target="_blank" rel="noopener">参数化夹具</a>、<a href="http://pytest.org/en/latest/fixture.html#factories-as-fixtures" target="_blank" rel="noopener">工厂夹具</a>、<a href="http://pytest.org/en/latest/fixture.html#modularity-using-fixtures-from-a-fixture-function" target="_blank" rel="noopener">在夹具中使用夹具</a>等更多高阶玩法，详情请阅读 <a href="http://pytest.org/en/latest/fixture.html#pytest-fixtures-explicit-modular-scalable" target="_blank" rel="noopener">“pytest fixtures: explicit, modular, scalable”</a>。</p>
<h2 id="跳过测试和预计失败"><a href="#跳过测试和预计失败" class="headerlink" title="跳过测试和预计失败"></a>跳过测试和预计失败</h2><p><code>pytest</code> 除了支持 <code>unittest</code> 和 <code>nosetest</code> 的跳过测试和预计失败的方式外，还在 <code>pytest.mark</code> 中提供对应方法：</p>
<ul>
<li>通过 <a href="http://pytest.org/en/latest/skipping.html#skipping-test-functions" target="_blank" rel="noopener">skip</a> 装饰器或 <a href="http://pytest.org/en/latest/skipping.html#xfail-mark-test-functions-as-expected-to-fail" target="_blank" rel="noopener">pytest.skip</a> 函数直接跳过测试</li>
<li>通过 <a href="http://pytest.org/en/latest/skipping.html#id1" target="_blank" rel="noopener">skipif</a>按条件跳过测试</li>
<li>通过 <a href="http://pytest.org/en/latest/skipping.html#xfail-mark-test-functions-as-expected-to-fail" target="_blank" rel="noopener">xfail</a> 预计测试失败</li>
</ul>
<p>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.skip(reason="no way of currently testing this")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_mark_skip</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_skip</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> valid_config():</span><br><span class="line">        pytest.skip(<span class="string">"unsupported configuration"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.skipif(sys.version_info &lt; (3, 6), reason="requires python3.6 or higher")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_mark_skip_if</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.xfail</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_mark_xfail</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<p>关于跳过测试和预计失败的更多玩法，参见 <a href="http://pytest.org/en/latest/skipping.html#skip-and-xfail-dealing-with-tests-that-cannot-succeed" target="_blank" rel="noopener">“Skip and xfail: dealing with tests that cannot succeed”</a></p>
<h2 id="子测试-参数化测试"><a href="#子测试-参数化测试" class="headerlink" title="子测试/参数化测试"></a>子测试/参数化测试</h2><p><code>pytest</code> 除了支持 <code>unittest</code> 中的 <code>TestCase.subTest</code>，还支持一种更为灵活的子测试编写方式，也就是 <code>参数化测试</code>，通过 <code>pytest.mark.parametrize</code> 装饰器实现。</p>
<p>在下面的示例中，定义一个 <code>test_eval</code> 测试函数，通过 <code>pytest.mark.parametrize</code> 装饰器指定 3 组参数，则将生成 3 个子测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.parametrize("test_input,expected", [("3+5", 8), ("2+4", 6), ("6*9", 42)])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_eval</span><span class="params">(test_input, expected)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> eval(test_input) == expected</span><br></pre></td></tr></table></figure>
<p>示例中故意让最后一组参数导致失败，运行用例可以看到丰富的测试结果输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">========================================= <span class="built_in">test</span> session starts =========================================</span><br><span class="line">platform darwin -- Python 3.7.1, pytest-4.0.1, py-1.7.0, pluggy-0.8.0</span><br><span class="line">rootdir: /Users/prodesire/projects/tests, inifile:</span><br><span class="line">plugins: cov-2.6.0</span><br><span class="line">collected 3 items</span><br><span class="line"></span><br><span class="line">test.py ..F                                                                                     [100%]</span><br><span class="line"></span><br><span class="line">============================================== FAILURES ===============================================</span><br><span class="line">__________________________________________ test_eval[6*9-42] __________________________________________</span><br><span class="line"></span><br><span class="line">test_input = <span class="string">'6*9'</span>, expected = 42</span><br><span class="line"></span><br><span class="line">    @pytest.mark.parametrize(<span class="string">"test_input,expected"</span>, [(<span class="string">"3+5"</span>, 8), (<span class="string">"2+4"</span>, 6), (<span class="string">"6*9"</span>, 42)])</span><br><span class="line">    def test_eval(test_input, expected):</span><br><span class="line">&gt;       assert <span class="built_in">eval</span>(test_input) == expected</span><br><span class="line">E       AssertionError: assert 54 == 42</span><br><span class="line">E        +  <span class="built_in">where</span> 54 = <span class="built_in">eval</span>(<span class="string">'6*9'</span>)</span><br><span class="line"></span><br><span class="line">test.py:6: AssertionError</span><br><span class="line">================================= 1 failed, 2 passed <span class="keyword">in</span> 0.09 seconds ==================================</span><br></pre></td></tr></table></figure>
<p>若将参数换成 <code>pytest.param</code>，我们还可以有更高阶的玩法，比如知道最后一组参数是失败的，所以将它标记为 xfail：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.parametrize(</span></span><br><span class="line">    <span class="string">"test_input,expected"</span>,</span><br><span class="line">    [(<span class="string">"3+5"</span>, <span class="number">8</span>), (<span class="string">"2+4"</span>, <span class="number">6</span>), pytest.param(<span class="string">"6*9"</span>, <span class="number">42</span>, marks=pytest.mark.xfail)],</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_eval</span><span class="params">(test_input, expected)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> eval(test_input) == expected</span><br></pre></td></tr></table></figure>
<p>如果测试函数的多个参数的值希望互相排列组合，我们可以这么写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.parametrize("x", [0, 1])</span></span><br><span class="line"><span class="meta">@pytest.mark.parametrize("y", [2, 3])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_foo</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>上述示例中会分别把 <code>x=0/y=2</code>、<code>x=1/y=2</code>、<code>x=0/y=3</code>和<code>x=1/y=3</code>带入测试函数，视作四个测试用例来执行。</p>
<h2 id="测试结果输出"><a href="#测试结果输出" class="headerlink" title="测试结果输出"></a>测试结果输出</h2><p><code>pytest</code> 的测试结果输出相比于 <code>unittest</code> 和 <code>nose</code> 来说更为丰富，其优势在于：</p>
<ul>
<li>高亮输出，通过或不通过会用不同的颜色进行区分</li>
<li>更丰富的上下文信息，自动输出代码上下文和变量信息</li>
<li>测试进度展示</li>
<li>测试结果输出布局更加友好易读</li>
</ul>
<h2 id="插件体系"><a href="#插件体系" class="headerlink" title="插件体系"></a>插件体系</h2><p><code>pytest</code> 的<a href="http://plugincompat.herokuapp.com/" target="_blank" rel="noopener">插件</a>十分丰富，而且即插即用，作为使用者不需要编写额外代码。关于插件的使用，参见<a href="http://pytest.org/en/latest/plugins.html" target="_blank" rel="noopener">“Installing and Using plugins”</a>。</p>
<p>此外，得益于 <code>pytest</code> 良好的架构设计和钩子机制，其插件编写也变得容易上手。关于插件的编写，参见<a href="http://pytest.org/en/latest/writing_plugins.html#writing-plugins" target="_blank" rel="noopener">“Writing plugins”</a>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>三篇关于 Python 测试框架的介绍到这里就要收尾了。写了这么多，各位看官怕也是看得累了。我们不妨罗列一个横向对比表，来总结下这些单元测试框架的异同：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">unittest</th>
<th style="text-align:right">nose</th>
<th style="text-align:right">nose2</th>
<th style="text-align:right">pytest</th>
</tr>
</thead>
<tbody>
<tr>
<td>自动发现用例</td>
<td style="text-align:center">✔</td>
<td style="text-align:right">✔</td>
<td style="text-align:right">✔</td>
<td style="text-align:right">✔</td>
</tr>
<tr>
<td>指定（各级别）用例执行</td>
<td style="text-align:center">✔</td>
<td style="text-align:right">✔</td>
<td style="text-align:right">✔</td>
<td style="text-align:right">✔</td>
</tr>
<tr>
<td>支持 assert 断言</td>
<td style="text-align:center">弱</td>
<td style="text-align:right">弱</td>
<td style="text-align:right">弱</td>
<td style="text-align:right">强</td>
</tr>
<tr>
<td>测试夹具</td>
<td style="text-align:center">✔</td>
<td style="text-align:right">✔</td>
<td style="text-align:right">✔</td>
<td style="text-align:right">✔</td>
</tr>
<tr>
<td>测试夹具种类</td>
<td style="text-align:center">前置和清理</td>
<td style="text-align:right">前置和清理</td>
<td style="text-align:right">前置和清理</td>
<td style="text-align:right">前置、清理、内置各类 fixtures，自定义各类 fixtures</td>
</tr>
<tr>
<td>测试夹具生效级别</td>
<td style="text-align:center">方法、类、模块</td>
<td style="text-align:right">方法、类、模块</td>
<td style="text-align:right">方法、类、模块</td>
<td style="text-align:right">方法、类、模块、包、会话</td>
</tr>
<tr>
<td>支持跳过测试和预计失败</td>
<td style="text-align:center">✔</td>
<td style="text-align:right">✔</td>
<td style="text-align:right">✔</td>
<td style="text-align:right">✔</td>
</tr>
<tr>
<td>子测试</td>
<td style="text-align:center">✔</td>
<td style="text-align:right">✔</td>
<td style="text-align:right">✔</td>
<td style="text-align:right">✔</td>
</tr>
<tr>
<td>测试结果输出</td>
<td style="text-align:center">一般</td>
<td style="text-align:right">较好</td>
<td style="text-align:right">较好</td>
<td style="text-align:right">好</td>
</tr>
<tr>
<td>插件</td>
<td style="text-align:center">-</td>
<td style="text-align:right">较丰富</td>
<td style="text-align:right">一般</td>
<td style="text-align:right">丰富</td>
</tr>
<tr>
<td>钩子</td>
<td style="text-align:center">-</td>
<td style="text-align:right">-</td>
<td style="text-align:right">✔</td>
<td style="text-align:right">✔</td>
</tr>
<tr>
<td>社区生态</td>
<td style="text-align:center">作为标准库，由官方维护</td>
<td style="text-align:right">停止维护</td>
<td style="text-align:right">维护中，活跃度低</td>
<td style="text-align:right">维护中，活跃度高</td>
</tr>
</tbody>
</table>
<p>Python 的单元测试框架看似种类繁多，实则是一代代的进化，有迹可循。抓住其特点，结合使用场景，就能容易的做出选择。</p>
<p>若你不想安装或不允许第三方库，那么 <code>unittest</code> 是最好也是唯一的选择。反之，<code>pytest</code> 无疑是最佳选择，众多 Python 开源项目（如大名鼎鼎的 <a href="https://github.com/psf/requests" target="_blank" rel="noopener">requests</a>）都是使用 <code>pytest</code> 作为单元测试框架。甚至，连 <code>nose2</code> 在<a href="https://docs.nose2.io/en/latest/#nose2-vs-pytest" target="_blank" rel="noopener">官方文档</a>上都建议大家使用 <code>pytest</code>，这得是多大的敬佩呀！</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/09/11/聊聊-Python-的单元测试框架（一）：unittest/" title="聊聊 Python 的单元测试框架（一）：unittest">聊聊 Python 的单元测试框架（一）：unittest</a></li>
<li><a href="/2019/09/17/聊聊-Python-的单元测试框架（二）：nose-和它的继任者-nose2/" title="聊聊 Python 的单元测试框架（二）：nose 和它的继任者 nose2">聊聊 Python 的单元测试框架（二）：nose 和它的继任者 nose2</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>]]></content>
      <categories>
        <category>Python</category>
        <category>单元测试</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>单元测试</tag>
        <tag>pytest</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊 Python 的单元测试框架（二）：nose 和它的继任者 nose2</title>
    <url>/2019/09/17/%E8%81%8A%E8%81%8A-Python-%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9Anose-%E5%92%8C%E5%AE%83%E7%9A%84%E7%BB%A7%E4%BB%BB%E8%80%85-nose2/</url>
    <content><![CDATA[<p>本文首发于 <a href="https://mp.weixin.qq.com/s/cVKNQmEMo-yHVCfyikQSLA" target="_blank" rel="noopener">HelloGitHub</a> 公众号。</p>
<h2 id="nose"><a href="#nose" class="headerlink" title="nose"></a>nose</h2><p><a href="https://nose.readthedocs.io/en/latest/" target="_blank" rel="noopener">nose</a> 是一个第三方单元测试框架，它<strong>完全兼容 <code>unittest</code></strong>，并且号称是一个更好用的测试框架。</p>
<p>那么 <code>nose</code> 除了具备 <code>unittest</code> 的所有功能外，还具有哪些优势呢？</p>
<a id="more"></a>
<h3 id="用例编写"><a href="#用例编写" class="headerlink" title="用例编写"></a>用例编写</h3><p>用例的编写方式除了编写继承于 <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener">unittest.TestCase</a> 的测试类外，还可以编写成<strong>没有继承的测试类</strong>。比如，写成如下形式也会被 <code>nose</code> 视作一个测试类：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> nose.tools <span class="keyword">import</span> raises</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStringMethods</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_upper</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="string">'foo'</span>.upper() == <span class="string">'FOO'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_isupper</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="string">'FOO'</span>.isupper()</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> <span class="string">'Foo'</span>.isupper()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @raises(TypeError)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_split</span><span class="params">(self)</span>:</span></span><br><span class="line">        s = <span class="string">'hello world'</span></span><br><span class="line">        <span class="keyword">assert</span> s.split() == [<span class="string">'hello'</span>, <span class="string">'world'</span>]</span><br><span class="line">        <span class="comment"># check that s.split fails when the separator is not a string</span></span><br><span class="line">        s.split(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<p>当然，测试类并没有继承 <code>unittest.TestCase</code>，将不能使用其内置的各类 <code>assertXXX</code> 方法，进而导致用例出错时无法获得更加详细的上下文信息。</p>
<p>此外，<code>nose</code> 也支持<strong>定义函数</strong>来作为测试，这给许多简单的测试场景带来很大的便利：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_upper</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="string">'foo'</span>.upper() == <span class="string">'FOO'</span></span><br></pre></td></tr></table></figure>
<h3 id="用例发现和执行"><a href="#用例发现和执行" class="headerlink" title="用例发现和执行"></a>用例发现和执行</h3><p><code>unittest</code> 所支持的用例发现和执行能力，<code>nose</code> 均支持。<br><code>nose</code> 支持用例自动（递归）发现：</p>
<ul>
<li>默认发现当前目录下所有包含 <code>test</code> 的测试用例，但不包括以 <code>_</code> 开头的用例<ul>
<li>使用 <code>nosetests</code> 命令</li>
</ul>
</li>
<li>通过 <code>-w</code> 参数指定要自动发现的目录， <code>-m</code> 参数指定用例文件、目录、函数、类的名称模式（正则匹配）<ul>
<li><code>nosetests -w project_directory &quot;test_.+&quot;</code></li>
</ul>
</li>
</ul>
<p><code>nose</code> 也支持执行指定用例：</p>
<ul>
<li>指定测试模块<ul>
<li><code>nosetests test.module</code></li>
</ul>
</li>
<li>指定测试类<ul>
<li><code>nosetests a.test:TestCase</code></li>
</ul>
</li>
<li>指定测试方法<ul>
<li><code>nosetests another.test:TestCase.test_method</code></li>
</ul>
</li>
<li>指定测试文件路径<ul>
<li><code>nosetests /path/to/test/file.py</code></li>
</ul>
</li>
<li>指定测试文件路径+测试类或测试函数（这是 <code>unittest</code> 所不支持的）<ul>
<li><code>nosetests /path/to/test/file.py:TestCase</code></li>
<li><code>nosetests /path/to/test/file.py:TestCase.test_method</code></li>
<li><code>nosetests /path/to/test/file.py:test_function</code></li>
</ul>
</li>
</ul>
<h3 id="测试夹具（Fixtures）"><a href="#测试夹具（Fixtures）" class="headerlink" title="测试夹具（Fixtures）"></a>测试夹具（Fixtures）</h3><p><code>nose</code> 除了支持 <code>unittest</code> 所支持的定义测试前置和清理方式，还支持一种更为简单的定义方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setup_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"set up test fixtures"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">teardown_func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"tear down test fixtures"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@with_setup(setup_func, teardown_func)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"test ..."</span></span><br></pre></td></tr></table></figure>
<p>只需定义两个函数用来表示前置和清理方法，通过 <a href="https://nose.readthedocs.io/en/latest/testing_tools.html?highlight=with_setup#nose.tools.with_setup" target="_blank" rel="noopener">nose.tools.with_setup</a> 装饰器装饰测试函数，<code>nose</code> 便会在执行测试用例前后分别执行所定义的前置和清理函数。</p>
<h3 id="子测试-测试生成器"><a href="#子测试-测试生成器" class="headerlink" title="子测试/测试生成器"></a>子测试/测试生成器</h3><p><code>nose</code> 除了支持 <code>unittest</code> 中的 <code>TestCase.subTest</code>，还支持一种更为强大的子测试编写方式，也就是 <code>测试生成器（Test generators）</code>，通过 <code>yield</code> 实现。</p>
<p>在下面的示例中，定义一个 <code>test_evens</code> 测试函数，里面生成了 5 个子测试 <code>check_even</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_evens</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> check_even, i, i*<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_even</span><span class="params">(n, nn)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> n % <span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> nn % <span class="number">2</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>此外，相较于 <code>unittest.TestCase.subTest</code> 多个子测试只能执行一次测试前置和清理，<code>nose</code> 的 <code>测试生成器</code> 可以支持每个子测试执行一次测试前置和清理，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_generator</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">yield</span> func, arg, arg <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@with_setup(setup_func, teardown_func)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> something_about(arg)</span><br></pre></td></tr></table></figure>
<h3 id="插件体系"><a href="#插件体系" class="headerlink" title="插件体系"></a>插件体系</h3><p><code>nose</code> 相较于 <code>unittest</code> 一个最大的优势就是插件体系，自带了很多有用的插件，也有丰富的第三方插件。这样就能做更多的事情。</p>
<p>其中，自带插件如下：</p>
<ul>
<li><a href="https://nose.readthedocs.io/en/latest/plugins/allmodules.html" target="_blank" rel="noopener">AllModules</a>: 在所有模块中收集用例</li>
<li><a href="https://nose.readthedocs.io/en/latest/plugins/attrib.html" target="_blank" rel="noopener">Attrib</a>: 给用例打标签，并可运行含指定标签的用例</li>
<li><a href="https://nose.readthedocs.io/en/latest/plugins/capture.html" target="_blank" rel="noopener">Capture</a>: 捕获用例的标准输出</li>
<li><a href="https://nose.readthedocs.io/en/latest/plugins/collect.html" target="_blank" rel="noopener">Collect</a>: 快速收集用例</li>
<li><a href="https://nose.readthedocs.io/en/latest/plugins/cover.html" target="_blank" rel="noopener">Cover</a>: 统计代码覆盖率</li>
<li><a href="https://nose.readthedocs.io/en/latest/plugins/debug.html" target="_blank" rel="noopener">Debug</a>: 用例失败时进入 pdb 调试</li>
<li><a href="https://nose.readthedocs.io/en/latest/plugins/deprecated.html" target="_blank" rel="noopener">Deprecated</a>: 标记用例为弃用</li>
<li><a href="https://nose.readthedocs.io/en/latest/plugins/deprecated.html" target="_blank" rel="noopener">Doctests</a>: 运行文档用例</li>
<li><a href="https://nose.readthedocs.io/en/latest/plugins/failuredetail.html" target="_blank" rel="noopener">Failure Detail</a>: 断言失败时提供上下文信息</li>
<li><a href="https://nose.readthedocs.io/en/latest/plugins/isolate.html" target="_blank" rel="noopener">Isolate</a>: 保护用例避免受一些副作用的影响</li>
<li><a href="https://nose.readthedocs.io/en/latest/plugins/logcapture.html" target="_blank" rel="noopener">Logcapture</a>: 捕捉 logging 输出</li>
<li><a href="https://nose.readthedocs.io/en/latest/plugins/multiprocess.html" target="_blank" rel="noopener">Multiprocess</a>: 并行执行用例</li>
<li><a href="https://nose.readthedocs.io/en/latest/plugins/prof.html" target="_blank" rel="noopener">Prof</a>: 使用热点分析器进行分析</li>
<li><a href="https://nose.readthedocs.io/en/latest/plugins/skip.html" target="_blank" rel="noopener">Skip</a>: 标记用例为跳过</li>
<li><a href="https://nose.readthedocs.io/en/latest/plugins/testid.html" target="_blank" rel="noopener">Testid</a>: 为输出的每个用例名称添加测试 ID</li>
<li><a href="https://nose.readthedocs.io/en/latest/plugins/xunit.html" target="_blank" rel="noopener">Xunit</a>: 以 xunit 格式输出测试结果</li>
</ul>
<p>而第三方库则多种多样，如用来生成 HTML 格式测试报告的 <a href="https://github.com/ionelmc/nose-htmloutput" target="_blank" rel="noopener">nose-htmloutput</a> 等，这里不再一一列出。</p>
<p>得益于 <code>nose</code> 丰富的插件生态，当 <code>nose</code> 本身不能够完全满足我们的测试需求时，可以通过安装插件，并在 <code>nosetests</code> 命令行指定该插件所提供的特定参数即可非常容易的使用插件。<br>相较于 <code>unittest</code>，就能省去很多自己开发额外测试逻辑的精力。</p>
<h2 id="nose2"><a href="#nose2" class="headerlink" title="nose2"></a>nose2</h2><p><a href="https://github.com/nose-devs/nose2" target="_blank" rel="noopener">nose2</a> 是 <a href="https://nose.readthedocs.io/en/latest/" target="_blank" rel="noopener">nose</a> 的继任者。<br>它们的理念都是让编写和运行测试用例变得更容易。</p>
<p>它们有很多相同点，比如都兼容 <code>unittest</code>，支持使用函数作为测试用例，支持子测试，拥有插件体系。但也有很多不同点，下面列出一些主要的不同点：</p>
<ul>
<li>发现和载入测试<ul>
<li><code>nose</code> 自行实现了模块加载功能，使用惰性方式加载测试模块，加载一个执行一个。</li>
<li><code>nose2</code> 则借助内建的 <a href="https://docs.python.org/3/library/functions.html#__import__" target="_blank" rel="noopener"><strong>import</strong>()</a> 导入模块，并且是先全部载入，再执行用例</li>
<li><code>nose2</code> 并不支持 <code>nose</code> 所支持的所有测试用例项目结构，比如如下用例文件的结构在 <code>nose2</code> 中就不受支持：</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">`-- tests</span><br><span class="line">    |-- more_tests</span><br><span class="line">    |   `-- test.py</span><br><span class="line">    `-- test.py</span><br></pre></td></tr></table></figure>
<ul>
<li>测试前置和清理函数级别<ul>
<li><code>nose</code> 支持方法、类、模块和包级别的测试前置和清理函数</li>
<li><code>nose2</code> 则不支持包级别的测试前置和清理函数</li>
</ul>
</li>
<li>子测试<ul>
<li><code>nose2</code> 除了支持使用测试生成器来实现子测试外，还支持使用<a href="https://docs.nose2.io/en/latest/params.html#parameterized-tests" target="_blank" rel="noopener">参数化测试（Parameterized tests）</a>来实现子测试</li>
<li><code>nose2</code> 除了像 <code>nose</code> 一样支持在测试函数和测试类（不继承于 <code>unittest.TestCase</code>）中支持参数化测试和测试生成器外，还支持在继承于 <code>unittest.TestCase</code> 的测试类中使用</li>
</ul>
</li>
<li>配置化<ul>
<li><code>nose</code> 期望所有插件的配置通过命令行参数进行配置</li>
<li><code>nose2</code> 则通过配置文件进行控制，以最小化命令行参数让人读得更舒服</li>
</ul>
</li>
</ul>
<p>更多对比详见 <a href="https://docs.nose2.io/en/latest/differences.html" target="_blank" rel="noopener">官方文档</a>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>nose</code> 和 <code>nose2</code> 在做到兼容 <code>unittest</code> 上就足以看出它们的目标，那便是要吸引原来那些使用 <code>unittest</code> 的用户来使用它们。它们确实做到了！</p>
<p><code>nose</code> 和 <code>nose2</code> 在用例编写、测试夹具、子测试上做出改进，已经能让日常用例编写工作变得更加容易和灵活。同时又引入插件体系，进一步将单元测试框架的能力提升了一个大大的台阶，这让很多在基础测试功能之上的高阶功能的实现和共享成为了可能。也难怪有众多开发者对它们情有独钟。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/09/11/聊聊-Python-的单元测试框架（一）：unittest/" title="聊聊 Python 的单元测试框架（一）：unittest">聊聊 Python 的单元测试框架（一）：unittest</a></li>
<li><a href="/2019/09/25/聊聊-Python-的单元测试框架（三）：最火的-pytest/" title="聊聊 Python 的单元测试框架（三）：最火的 pytest">聊聊 Python 的单元测试框架（三）：最火的 pytest</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>]]></content>
      <categories>
        <category>Python</category>
        <category>单元测试</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>单元测试</tag>
        <tag>nose</tag>
        <tag>nose2</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊 Python 的单元测试框架（一）：unittest</title>
    <url>/2019/09/11/%E8%81%8A%E8%81%8A-Python-%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9Aunittest/</url>
    <content><![CDATA[<p>本文首发于 <a href="https://mp.weixin.qq.com/s/njxc8GXSlc3z_RibK70ROg" target="_blank" rel="noopener">HelloGitHub</a> 公众号。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说到 Python 的单元测试框架，想必接触过 Python 的朋友脑袋里第一个想到的就是 <a href="https://docs.python.org/3/library/unittest.html" target="_blank" rel="noopener">unittest</a>。<br>的确，作为 Python 的标准库，它很优秀，并被广泛用于各个项目。但你知道吗？其实在 Python 众多项目中，主流的单元测试框架远不止这一个。</p>
<p>本系列文章将为大家介绍目前流行的 Python 的单元测试框架，讲讲它们的功能和特点并比较其异同，以让大家在面对不同场景、不同需求的时候，能够权衡利弊，选择最佳的单元测试框架。</p>
<a id="more"></a>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">本文默认以 Python 3 为例进行介绍，若某些特性在 Python 2 中没有或不同，会特别说明。</span><br></pre></td></tr></table></figure>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://docs.python.org/3/library/unittest.html" target="_blank" rel="noopener">unittest</a> 单元测试框架最早受到 JUnit 的启发，和其他语言的主流单元测试框架有着相似的风格。<br>它支持测试自动化，多个测试用例共享前置（setUp）和清理（tearDown）代码，聚合多个测试用例到测试集中，并将测试和报告框架独立。</p>
<h2 id="用例编写"><a href="#用例编写" class="headerlink" title="用例编写"></a>用例编写</h2><p>下面这段简单的示例来自于<a href="https://docs.python.org/3/library/unittest.html#basic-example" target="_blank" rel="noopener">官方文档</a>，用来测试三种字符串方法：<code>upper</code>、<code>isupper</code>、<code>split</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestStringMethods</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_upper</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(<span class="string">'foo'</span>.upper(), <span class="string">'FOO'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_isupper</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertTrue(<span class="string">'FOO'</span>.isupper())</span><br><span class="line">        self.assertFalse(<span class="string">'Foo'</span>.isupper())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_split</span><span class="params">(self)</span>:</span></span><br><span class="line">        s = <span class="string">'hello world'</span></span><br><span class="line">        self.assertEqual(s.split(), [<span class="string">'hello'</span>, <span class="string">'world'</span>])</span><br><span class="line">        <span class="comment"># check that s.split fails when the separator is not a string</span></span><br><span class="line">        <span class="keyword">with</span> self.assertRaises(TypeError):</span><br><span class="line">            s.split(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    unittest.main()</span><br></pre></td></tr></table></figure>
<p>上述示例中，通过继承 <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase" target="_blank" rel="noopener">unittest.TestCase</a> 来创建一个测试用例。<br>在这个类中，定义以 <code>test</code> 开头的方法，测试框架将把它作为独立的测试去执行。</p>
<p>每个用例都采用 <code>unittest</code> 内置的断言方法来判断被测对象的行为是否符合预期，比如：</p>
<ul>
<li>在 <code>test_upper</code> 测试中，使用 <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertEqual" target="_blank" rel="noopener">assertEqual</a> 检查是否是预期值</li>
<li>在 <code>test_isupper</code> 测试中，使用 <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertTrue" target="_blank" rel="noopener">assertTrue</a> 或 <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertFalse" target="_blank" rel="noopener">assertFalse</a> 验证是否符合条件</li>
<li>在 <code>test_split</code> 测试中，使用 <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.assertRaises" target="_blank" rel="noopener">assertRaises</a> 验证是否抛出一个特定异常</li>
</ul>
<p>可能有人会好奇，为什么不使用内置断言语句 <code>assert</code>，而要额外提供这么多断言方法并使用呢？原因是通过使用 <code>unittest</code> 提供的断言方法，测试框架在运行结束后，能够聚合所有的测试结果并产生信息丰富的测试报告。而直接使用 <code>assert</code> 虽然也可以达到验证被测对象是否符合预期的目的，但在用例出错时，报错信息不够丰富。</p>
<h2 id="用例发现和执行"><a href="#用例发现和执行" class="headerlink" title="用例发现和执行"></a>用例发现和执行</h2><p><code>unittest</code> 支持用例自动（递归）发现：</p>
<ul>
<li>默认发现当前目录下所有符合 <code>test*.py</code> 测试用例<ul>
<li>使用 <code>python -m unittest</code> 或 <code>python -m unittest discover</code></li>
</ul>
</li>
<li>通过 <code>-s</code> 参数指定要自动发现的目录， <code>-p</code> 参数指定用例文件的名称模式<ul>
<li><code>python -m unittest discover -s project_directory -p &quot;test_*.py&quot;</code></li>
</ul>
</li>
<li>通过位置参数指定自动发现的目录和用例文件的名称模式<ul>
<li><code>python -m unittest discover project_directory &quot;test_*.py&quot;</code></li>
</ul>
</li>
</ul>
<p><code>unittest</code> 支持执行指定用例：</p>
<ul>
<li>指定测试模块<ul>
<li><code>python -m unittest test_module1 test_module2</code></li>
</ul>
</li>
<li>指定测试类<ul>
<li><code>python -m unittest test_module.TestClass</code></li>
</ul>
</li>
<li>指定测试方法<ul>
<li><code>python -m unittest test_module.TestClass.test_method</code></li>
</ul>
</li>
<li>指定测试文件路径（仅 Python 3）<ul>
<li><code>python -m unittest tests/test_something.py</code></li>
</ul>
</li>
</ul>
<h2 id="测试夹具（Fixtures）"><a href="#测试夹具（Fixtures）" class="headerlink" title="测试夹具（Fixtures）"></a>测试夹具（Fixtures）</h2><p>测试夹具也就是测试前置（setUp）和清理（tearDown）方法。</p>
<p>测试前置方法<a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.setUp" target="_blank" rel="noopener">setUp()</a>用来做一些准备工作，比如建立数据库连接。它会在用例执行前被测试框架自动调用。</p>
<p>测试清理方法<a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.tearDown" target="_blank" rel="noopener">tearDown()</a>用来做一些清理工作，比如断开数据库连接。它会在用例执行完成（包括失败的情况）后被测试框架自动调用。</p>
<p>测试前置和清理方法可以有不同的执行级别。</p>
<h3 id="生效级别：测试方法"><a href="#生效级别：测试方法" class="headerlink" title="生效级别：测试方法"></a>生效级别：测试方法</h3><p>如果我们希望每个测试方法之前前后分别执行测试前置和清理方法，那么需要在测试类中定义好 <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.setUp" target="_blank" rel="noopener">setUp()</a> 和 <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.tearDown" target="_blank" rel="noopener">tearDown()</a>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDown</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="生效级别：测试类"><a href="#生效级别：测试类" class="headerlink" title="生效级别：测试类"></a>生效级别：测试类</h3><p>如果我们希望单个测试类中只执行一次前置方法，再执行该测试类中的所有测试，最后执行一次清理方法，那么需要在测试类中定义好 <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.setUpClass" target="_blank" rel="noopener">setUpClass()</a> 和 <a href="https://docs.python.org/3/library/unittest.html#unittest.TestCase.tearDownClass" target="_blank" rel="noopener">tearDownClass()</a>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setUpClass</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tearDownClass</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h3 id="生效级别：测试模块"><a href="#生效级别：测试模块" class="headerlink" title="生效级别：测试模块"></a>生效级别：测试模块</h3><p>如果我们希望单个测试模块中只执行一次前置方法，再执行该模块中所有测试类的所有测试，最后执行一次清理方法，那么需要在测试模块中定义好<a href="https://docs.python.org/3/library/unittest.html#setupmodule-and-teardownmodule" target="_blank" rel="noopener">setUpModule()</a> 和 <a href="https://docs.python.org/3/library/unittest.html#setupmodule-and-teardownmodule" target="_blank" rel="noopener">tearDownModule()</a>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setUpModule</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tearDownModule</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<h2 id="跳过测试和预计失败"><a href="#跳过测试和预计失败" class="headerlink" title="跳过测试和预计失败"></a>跳过测试和预计失败</h2><p><code>unittest</code> 支持直接跳过或按条件跳过测试，也支持预计测试失败：</p>
<ul>
<li>通过 <a href="https://docs.python.org/3/library/unittest.html#unittest.skip" target="_blank" rel="noopener">skip</a> 装饰器或 <a href="https://docs.python.org/3/library/unittest.html#unittest.SkipTest" target="_blank" rel="noopener">SkipTest</a> 直接跳过测试</li>
<li>通过 <a href="https://docs.python.org/3/library/unittest.html#unittest.skipIf" target="_blank" rel="noopener">skipIf</a> 或 <a href="https://docs.python.org/3/library/unittest.html#unittest.skipUnless" target="_blank" rel="noopener">skipUnless</a> 按条件跳过或不跳过测试</li>
<li>通过 <a href="https://docs.python.org/3/library/unittest.html#unittest.expectedFailure" target="_blank" rel="noopener">expectedFailure</a> 预计测试失败</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestCase</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @unittest.skip("直接跳过")</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_nothing</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.fail(<span class="string">"shouldn't happen"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @unittest.skipIf(mylib.__version__ &lt; (1, 3),</span></span><br><span class="line">                     <span class="string">"满足条件跳过"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_format</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># Tests that work for only a certain version of the library.</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @unittest.skipUnless(sys.platform.startswith("win"), "满足条件不跳过")</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_windows_support</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># windows specific testing code</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_maybe_skipped</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> external_resource_available():</span><br><span class="line">            self.skipTest(<span class="string">"跳过"</span>)</span><br><span class="line">        <span class="comment"># test code that depends on the external resource</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @unittest.expectedFailure</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_fail</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.assertEqual(<span class="number">1</span>, <span class="number">0</span>, <span class="string">"这个目前是失败的"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="子测试"><a href="#子测试" class="headerlink" title="子测试"></a>子测试</h2><p>有时候，你可能想编写这样的测试：在一个测试方法中传入不同的参数来测试同一段逻辑，但它将被视作一个测试，但是如果使用了<a href="https://docs.python.org/3/library/unittest.html#distinguishing-test-iterations-using-subtests" target="_blank" rel="noopener">子测试</a>，就能被视作 N（即为参数的个数）个测试。下面是一个示例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumbersTest</span><span class="params">(unittest.TestCase)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test_even</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Test that numbers between 0 and 5 are all even.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">6</span>):</span><br><span class="line">            <span class="keyword">with</span> self.subTest(i=i):</span><br><span class="line">                self.assertEqual(i % <span class="number">2</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>示例中使用了 <code>with self.subTest(i=i)</code> 的方式定义子测试，这种情况下，即使单个子测试执行失败，也不会影响后续子测试的执行。这样，我们就能看到输出中有三个子测试不通过：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">======================================================================</span><br><span class="line">FAIL: test_even (__main__.NumbersTest) (i=1)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"subtests.py"</span>, line 32, <span class="keyword">in</span> test_even</span><br><span class="line">    self.assertEqual(i % 2, 0)</span><br><span class="line">AssertionError: 1 != 0</span><br><span class="line"></span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_even (__main__.NumbersTest) (i=3)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"subtests.py"</span>, line 32, <span class="keyword">in</span> test_even</span><br><span class="line">    self.assertEqual(i % 2, 0)</span><br><span class="line">AssertionError: 1 != 0</span><br><span class="line"></span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_even (__main__.NumbersTest) (i=5)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"subtests.py"</span>, line 32, <span class="keyword">in</span> test_even</span><br><span class="line">    self.assertEqual(i % 2, 0)</span><br><span class="line">AssertionError: 1 != 0</span><br></pre></td></tr></table></figure>
<h2 id="测试结果输出"><a href="#测试结果输出" class="headerlink" title="测试结果输出"></a>测试结果输出</h2><p>基于简单示例小节中提到的例子，来说明下 <code>unittest</code> 在运行完测试后的结果输出。</p>
<p>默认情况下的输出非常简单，展示运行了多少个用例，以及所花费的时间：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 3 tests <span class="keyword">in</span> 0.000s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>通过指定 <code>-v</code> 参数，可以得到详细输出，除了默认输出的内容，还额外显示了用例名称：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test_isupper (__main__.TestStringMethods) ... ok</span><br><span class="line">test_split (__main__.TestStringMethods) ... ok</span><br><span class="line">test_upper (__main__.TestStringMethods) ... ok</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 3 tests <span class="keyword">in</span> 0.001s</span><br><span class="line"></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>假定 <code>test_upper</code> 测试失败，则在详细输出模式下，结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test_isupper (tests.test.TestStringMethods) ... ok</span><br><span class="line">test_split (tests.test.TestStringMethods) ... ok</span><br><span class="line">test_upper (tests.test.TestStringMethods) ... FAIL</span><br><span class="line"></span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_upper (tests.test.TestStringMethods)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/prodesire/projects/tests/test.py"</span>, line 6, <span class="keyword">in</span> test_upper</span><br><span class="line">    self.assertEqual(<span class="string">'foo'</span>.upper(), <span class="string">'FOO1'</span>)</span><br><span class="line">AssertionError: <span class="string">'FOO'</span> != <span class="string">'FOO1'</span></span><br><span class="line">- FOO</span><br><span class="line">+ FOO1</span><br><span class="line">?    +</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 3 tests <span class="keyword">in</span> 0.001s</span><br><span class="line"></span><br><span class="line">FAILED (failures=1)</span><br></pre></td></tr></table></figure>
<p>如果我们将 <code>test_upper</code> 测试方法中的 <code>self.assertEqual</code> 改为 <code>assert</code>，则测试结果输出中将会少了对排查错误很有帮助的上下文信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test_isupper (tests.test.TestStringMethods) ... ok</span><br><span class="line">test_split (tests.test.TestStringMethods) ... ok</span><br><span class="line">test_upper (tests.test.TestStringMethods) ... FAIL</span><br><span class="line"></span><br><span class="line">======================================================================</span><br><span class="line">FAIL: test_upper (tests.test.TestStringMethods)</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/Users/prodesire/projects/tests/test.py"</span>, line 6, <span class="keyword">in</span> test_upper</span><br><span class="line">    assert <span class="string">'foo'</span>.upper() == <span class="string">'FOO1'</span></span><br><span class="line">AssertionError</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">Ran 3 tests <span class="keyword">in</span> 0.001s</span><br><span class="line"></span><br><span class="line">FAILED (failures=1)</span><br></pre></td></tr></table></figure>
<p>如果想要生成 HTML 格式的报告，那么就需要额外借助第三方库（如 <a href="https://github.com/oldani/HtmlTestRunner" target="_blank" rel="noopener">HtmlTestRunner</a>）来操作。<br>在安装好第三方库后，你不能直接使用 <code>python -m unittest</code> 加上类似 <code>--html report.html</code> 的方式来生成 HTML 报告，而是需要自行编写少量代码来运行测试用例进而得到 HTML 报告。<br>详情请查看 <a href="https://github.com/oldani/HtmlTestRunner#usage" target="_blank" rel="noopener">HtmlTestRunner 使用说明</a>。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><a href="https://docs.python.org/3/library/unittest.html" target="_blank" rel="noopener">unittest</a> 作为 Python 标准库提供的单元测试框架，使用简单、功能强大，日常测试需求均能得到很好的满足。在不引入第三方库的情况下，是单元测试的不二之选。</p>
<p>在下篇文章中，我们将介绍第三方单元测试框架 <code>nose</code> 和 <code>nose2</code>，讲讲它对比于 <code>unittest</code> 有哪些改进，以至于让很多开发人员优先选择了它。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/09/17/聊聊-Python-的单元测试框架（二）：nose-和它的继任者-nose2/" title="聊聊 Python 的单元测试框架（二）：nose 和它的继任者 nose2">聊聊 Python 的单元测试框架（二）：nose 和它的继任者 nose2</a></li>
<li><a href="/2019/09/25/聊聊-Python-的单元测试框架（三）：最火的-pytest/" title="聊聊 Python 的单元测试框架（三）：最火的 pytest">聊聊 Python 的单元测试框架（三）：最火的 pytest</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>]]></content>
      <categories>
        <category>Python</category>
        <category>单元测试</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>单元测试</tag>
        <tag>unittest</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：使用 argparse 实现 git 命令</title>
    <url>/2019/09/04/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9A%E4%BD%BF%E7%94%A8-argparse-%E5%AE%9E%E7%8E%B0-git-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>本文首发于 <a href="https://mp.weixin.qq.com/s/o7wlp4EEkFGwN-snXU03aQ" target="_blank" rel="noopener">HelloGitHub</a> 公众号。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面三篇介绍 <code>argparse</code> 的文章中，我们全面了解了 <code>argparse</code> 的能力，相信不少小伙伴们都已经摩拳擦掌，想要打造一个属于自己的命令行工具。</p>
<p>本文将以我们日常工作中最常见的 <code>git</code> 命令为例，讲解如何使用 <code>argparse</code> 库来实现一个真正可用的命令行程序。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<h2 id="git-常用命令"><a href="#git-常用命令" class="headerlink" title="git 常用命令"></a>git 常用命令</h2><p>大家不妨回忆一下，平时最常使用 <code>git</code> 子命令都有哪些？</p>
<p>当你写好一段代码或增删一些文件后，会用如下命令查看文件状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>
<p>确认文件状态后，会用如下命令将的一个或多个文件（夹）添加到暂存区：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add [pathspec [pathspec ...]]</span><br></pre></td></tr></table></figure>
<p>然后使用如下命令提交信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"your commit message"</span></span><br></pre></td></tr></table></figure>
<p>最后使用如下命令将提交推送到远程仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure>
<p>我们将使用 <code>argparse</code> 和 <code>gitpython</code> 库来实现这 4 个子命令。</p>
<h2 id="关于-gitpython"><a href="#关于-gitpython" class="headerlink" title="关于 gitpython"></a>关于 gitpython</h2><p><a href="https://gitpython.readthedocs.io/en/stable/intro.html" target="_blank" rel="noopener">gitpython</a> 是一个和 <code>git</code> 仓库交互的 Python 第三方库。<br>我们将借用它的能力来实现真正的 <code>git</code> 逻辑。</p>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install gitpython</span><br></pre></td></tr></table></figure>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>在实现前，我们不妨先思考下会用到 <code>argparse</code> 的哪些功能？整个程序的结构是怎样的？</p>
<p><strong>argparse</strong></p>
<ul>
<li>要实现子命令，那么之前介绍到的 <code>嵌套解析器</code> 必不可少</li>
<li>当用户键入子命令时，子命令所对应的子解析器需要作出响应，那么需要用到子解析器的 <code>set_defaults</code> 功能</li>
<li>针对 <code>git add [pathspec [pathspec ...]]</code>，我们需要实现位置参数，而且数量是任意个</li>
<li>针对 <code>git commit --message msg</code> 或 <code>git commit -m msg</code>，我们需要实现选项参数，且即可长选项，又可短选项</li>
</ul>
<p><strong>程序结构</strong></p>
<ul>
<li>命令行程序需要一个 <code>cli</code> 函数来作为统一的入口，它负责构建解析器，并解析命令行参数</li>
<li>我们还需要四个 <code>handle_xxx</code> 函数响应对应的子命令</li>
</ul>
<p>则基本结构如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">from</span> git.cmd <span class="keyword">import</span> Git</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    git 命名程序入口</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_status</span><span class="params">(git, args)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 status 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_add</span><span class="params">(git, args)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 add 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_commit</span><span class="params">(git, args)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 -m &lt;msg&gt; 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_push</span><span class="params">(git, args)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 push 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    cli()</span><br></pre></td></tr></table></figure>
<p>下面我们将一步步地实现我们的 <code>git</code> 程序。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>假定我们在 <a href="https://github.com/HelloGitHub-Team/Article/blob/master/contents/Python/cmdline/argparse-git.py" target="_blank" rel="noopener">argparse-git.py</a> 文件中实现我们的 <code>git</code> 程序。</p>
<h3 id="构建解析器"><a href="#构建解析器" class="headerlink" title="构建解析器"></a>构建解析器</h3><p>我们需要构建一个父解析器，作为程序的根解析器，程序名称指定为 <code>git</code>。然后在上面添加子解析器，为后续的子命令的解析做准备：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    git 命名程序入口</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    parser = argparse.ArgumentParser(prog=<span class="string">'git'</span>)</span><br><span class="line">    subparsers = parser.add_subparsers(</span><br><span class="line">        title=<span class="string">'These are common Git commands used in various situations'</span>,</span><br><span class="line">        metavar=<span class="string">'command'</span>)</span><br></pre></td></tr></table></figure>
<p><code>add_subparsers</code> 中的 <code>title</code> 和 <code>metavar</code> 参数主要用于命令行帮助信息，最终的效果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usage: git [-h] <span class="built_in">command</span> ...</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">These are common Git commands used <span class="keyword">in</span> various situations:</span><br><span class="line">  <span class="built_in">command</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<h3 id="status-子命令"><a href="#status-子命令" class="headerlink" title="status 子命令"></a>status 子命令</h3><p>我们需要在 <code>cli</code> 函数中添加一个用于解析 <code>status</code> 命令的子解析器 <code>status_parser</code>，并指定其对应的处理函数为 <code>handle_status</code>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># status</span></span><br><span class="line">    status_parser = subparsers.add_parser(</span><br><span class="line">        <span class="string">'status'</span>,</span><br><span class="line">        help=<span class="string">'Show the working tree status'</span>)</span><br><span class="line">    status_parser.set_defaults(handle=handle_status)</span><br></pre></td></tr></table></figure>
<p>需要说明的是，在 <code>status_parser.set_defaults</code> 函数中，能接收任意名称的关键字参数，这个参数值会存放于父解析器解析命令行参数后的变量中。</p>
<p>比如，在本文示例程序中，我们为每个子解析器定义了 <code>handle</code>，那么 <code>args = parser.parse_args()</code> 中的 <code>args</code> 将具有 <code>handle</code> 属性，我们传入不同的子命令，那么这个 <code>handle</code> 就是不同的响应函数。</p>
<p>定义了 <code>status</code> 的子解析器后，我们再实现下 <code>handle_status</code> 即可实现 <code>status</code> 命令的响应：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_status</span><span class="params">(git, args)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 status 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cmd = [<span class="string">'git'</span>, <span class="string">'status'</span>]</span><br><span class="line">    output = git.execute(cmd)</span><br><span class="line">    print(output)</span><br></pre></td></tr></table></figure>
<p>不难看出，我们最后调用了真正的 <code>git status</code> 来实现，并打印了输出。</p>
<p>你可能会对 <code>handle_status</code> 的函数签名感到困惑，这里的 <code>git</code> 和 <code>args</code> 是怎么传入的呢？这其实是由我们自己控制的，将在本文最后讲解。</p>
<h3 id="add-子命令"><a href="#add-子命令" class="headerlink" title="add 子命令"></a>add 子命令</h3><p>同样，我们需要在 <code>cli</code> 函数中添加一个用于解析 <code>add</code> 命令的子解析器 <code>add_parser</code>，并指定其对应的处理函数为 <code>handle_add</code>。</p>
<p>额外要做的是，要在子解析器 <code>add_parser</code> 上添加一个 <code>pathspec</code> 位置参数，且其数量是任意的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># add</span></span><br><span class="line">    add_parser = subparsers.add_parser(</span><br><span class="line">        <span class="string">'add'</span>,</span><br><span class="line">        help=<span class="string">'Add file contents to the index'</span>)</span><br><span class="line">    add_parser.add_argument(</span><br><span class="line">        <span class="string">'pathspec'</span>,</span><br><span class="line">        help=<span class="string">'Files to add content from'</span>,</span><br><span class="line">        nargs=<span class="string">'*'</span>)</span><br><span class="line">    add_parser.set_defaults(handle=handle_add)</span><br></pre></td></tr></table></figure>
<p>然后，就是实现 <code>handle_add</code> 函数，我们需要用到表示文件路径的 <code>args.pathspec</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_add</span><span class="params">(git, args)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 add 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cmd = [<span class="string">'git'</span>, <span class="string">'add'</span>] + args.pathspec</span><br><span class="line">    output = git.execute(cmd)</span><br><span class="line">    print(output)</span><br></pre></td></tr></table></figure>
<h3 id="commit-子命令"><a href="#commit-子命令" class="headerlink" title="commit 子命令"></a>commit 子命令</h3><p>同样，我们需要在 <code>cli</code> 函数中添加一个用于解析 <code>commit</code> 命令的子解析器 <code>commit_parser</code>，并指定其对应的处理函数为 <code>handle_commit</code>。</p>
<p>额外要做的是，要在子解析器 <code>commit_parser</code> 上添加一个 <code>-m</code>/<code>--message</code> 选项参数，且要求必填：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># commit</span></span><br><span class="line">    commit_parser = subparsers.add_parser(</span><br><span class="line">        <span class="string">'commit'</span>,</span><br><span class="line">        help=<span class="string">'Record changes to the repository'</span>)</span><br><span class="line">    commit_parser.add_argument(</span><br><span class="line">        <span class="string">'--message'</span>, <span class="string">'-m'</span>,</span><br><span class="line">        help=<span class="string">'Use the given &lt;msg&gt; as the commit message'</span>,</span><br><span class="line">        metavar=<span class="string">'msg'</span>,</span><br><span class="line">        required=<span class="keyword">True</span>)</span><br><span class="line">    commit_parser.set_defaults(handle=handle_commit)</span><br></pre></td></tr></table></figure>
<p>然后，就是实现 <code>handle_commit</code> 函数，我们需要用到表示提交信息的 <code>args.message</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_commit</span><span class="params">(git, args)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理 -m &lt;msg&gt; 命令</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cmd = [<span class="string">'git'</span>, <span class="string">'commit'</span>, <span class="string">'-m'</span>, args.message]</span><br><span class="line">    output = git.execute(cmd)</span><br><span class="line">    print(output)</span><br></pre></td></tr></table></figure>
<h3 id="push-子命令"><a href="#push-子命令" class="headerlink" title="push 子命令"></a>push 子命令</h3><p>同样，我们需要在 <code>cli</code> 函数中添加一个用于解析 <code>push</code> 命令的子解析器 <code>push_parser</code>，并指定其对应的处理函数为 <code>handle_push</code>。</p>
<p>它同 <code>status</code> 子命令的实现方式一致：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># push</span></span><br><span class="line">    push_parser = subparsers.add_parser(</span><br><span class="line">      <span class="string">'push'</span>,</span><br><span class="line">      help=<span class="string">'Update remote refs along with associated objects'</span>)</span><br><span class="line">    push_parser.set_defaults(handle=handle_push)</span><br></pre></td></tr></table></figure>
<p>然后，就是实现 <code>handle_push</code> 函数，和 <code>handle_status</code> 类似：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_push</span><span class="params">(git, args)</span>:</span></span><br><span class="line">    cmd = [<span class="string">'git'</span>, <span class="string">'push'</span>]</span><br><span class="line">    output = git.execute(cmd)</span><br><span class="line">    print(output)</span><br></pre></td></tr></table></figure>
<h3 id="解析参数"><a href="#解析参数" class="headerlink" title="解析参数"></a>解析参数</h3><p>在定义完父子解析器，并添加参数后，我们就需要对参数做解析，这项工作也是实现在 <code>cli</code> 函数中：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cli</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br><span class="line">    git = Git(os.getcwd())</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    <span class="keyword">if</span> hasattr(args, <span class="string">'handle'</span>):</span><br><span class="line">        args.handle(git, args)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        parser.print_help()</span><br></pre></td></tr></table></figure>
<ul>
<li>通过 <code>git.cmd.Git</code> 实例化出 <code>git</code> 对象，用来和 <code>git</code> 仓库交互</li>
<li>通过 <code>parser.parse_args()</code> 解析命令行</li>
<li>通过 <code>hasattr(args, &#39;handle&#39;)</code> 判断是否输入了子命令。<ul>
<li>由于每个子解析器都定义了 <code>handle</code>，那么如果当用户在命令行不输入任何命令时，<code>args</code> 就没有 <code>handle</code> 属性，那么我们就输出帮助信息</li>
<li>如果用户输入了子命令，那么就调用 <code>args.handle</code>，传入 <code>git</code> 和 <code>args</code> 对象，用以处理对应命令</li>
</ul>
</li>
</ul>
<p>至此，我们就实现了一个简单的 <code>git</code> 命令行，使用 <code>python argparse-git.py -h</code> 查看帮助如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usage: git [-h] <span class="built_in">command</span> ...</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">These are common Git commands used <span class="keyword">in</span> various situations:</span><br><span class="line">  <span class="built_in">command</span></span><br><span class="line">    status    Show the working tree status</span><br><span class="line">    add       Add file contents to the index</span><br><span class="line">    commit    Record changes to the repository</span><br><span class="line">    push      Update remote refs along with associated objects</span><br></pre></td></tr></table></figure>
<p>然后我们就可以愉快地使用亲手打造的 <code>git</code> 程序啦！</p>
<p>想看整个源码，请戳 <a href="https://github.com/HelloGitHub-Team/Article/blob/master/contents/Python/cmdline/argparse-git.py" target="_blank" rel="noopener">argparse-git.py</a> 。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文简单介绍了日常工作中常用的 <code>git</code> 命令，然后提出实现它的思路，最终一步步地使用 <code>argparse</code> 和 <code>gitpython</code> 实现了 <code>git</code> 程序。是不是很有成就感呢？</p>
<p>关于 <code>argparse</code> 的讲解将告一段落，回顾下 <code>argparse</code> 的四步曲，加上今天的内容，感觉它还是挺清晰、简单的。<br>不过，这还只是打开了命令行大门的一扇门。</p>
<p>你是否想过，<code>argparse</code> 的四步曲虽然理解简单，但略微麻烦。有没有更简单的方式？<br>如果我很熟悉命令行帮助语法，我能不能写个帮助字符串就把所有的命令行元信息给定义出来？然后就直接轻松愉快地获取解析后的参数信息呢？</p>
<p>在下篇文章中，将为大家讲解另一个站在一个全新的思路，又无比强大的库 <code>docopt</code>。</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>argparse</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：深入 argparse（二）</title>
    <url>/2019/08/27/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9A%E6%B7%B1%E5%85%A5-argparse%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p>本文首发于 <a href="https://mp.weixin.qq.com/s/oM6o7PdmPg-YRfHN-tWQFw" target="_blank" rel="noopener">HelloGitHub</a> 公众号。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇“深入 argparse（一）”的文章中，我们深入了解了 <code>argparse</code> 的包括参数动作和参数类别在内的基本功能，具备了编写一个简单命令行程序的能力。本文将继续深入了解 <code>argparse</code> 的进阶玩法，一窥探其全貌，助力我们拥有实现复杂命令行程序的能力。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><h3 id="自动生成帮助"><a href="#自动生成帮助" class="headerlink" title="自动生成帮助"></a>自动生成帮助</h3><p>当你在命令行程序中指定 <code>-h</code> 或 <code>--help</code> 参数时，都会输出帮助信息。而 <code>argparse</code> 可通过指定 <code>add_help</code> 入参为 <code>True</code> 或不指定，以达到自动输出帮助信息的目的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import argparse</span><br><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(add_help=True)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'-h'</span>])</span><br><span class="line">usage: [-h] [--foo FOO]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  --foo FOO</span><br></pre></td></tr></table></figure>
<p>如果 <code>add_help=False</code>，那么在命令行中指定 <code>-h</code> 则会报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import argparse</span><br><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(add_help=False)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--foo'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'-h'</span>])</span><br><span class="line">usage: [--foo FOO]</span><br><span class="line">: error: unrecognized arguments: -h</span><br></pre></td></tr></table></figure>
<h3 id="自定义帮助"><a href="#自定义帮助" class="headerlink" title="自定义帮助"></a>自定义帮助</h3><p><code>ArgumentParser</code> 使用 <code>formatter_class</code> 入参来控制所输出的帮助格式。<br>比如，通过指定 <code>formatter_class=argparse.RawTextHelpFormatter</code>，我们可以让帮助内容遵循原始格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import argparse</span><br><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(</span><br><span class="line">...     add_help=True,</span><br><span class="line">...     formatter_class=argparse.RawTextHelpFormatter,</span><br><span class="line">...     description=<span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">...     description</span></span><br><span class="line"><span class="string">...         raw</span></span><br><span class="line"><span class="string">...            formatted"</span><span class="string">""</span></span><br><span class="line">... )</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(</span><br><span class="line">...     <span class="string">'-a'</span>, action=<span class="string">"store_true"</span>,</span><br><span class="line">...     <span class="built_in">help</span>=<span class="string">""</span><span class="string">"argument</span></span><br><span class="line"><span class="string">...         raw</span></span><br><span class="line"><span class="string">...             formatted</span></span><br><span class="line"><span class="string">...     "</span><span class="string">""</span></span><br><span class="line">... )</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'-h'</span>])</span><br><span class="line">usage: [-h] [-a]</span><br><span class="line"></span><br><span class="line">    description</span><br><span class="line">        raw</span><br><span class="line">           formatted</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  -a          argument</span><br><span class="line">                      raw</span><br><span class="line">                          formatted</span><br></pre></td></tr></table></figure>
<p>对比下不指定 <code>formatter_class</code> 的帮助输出，就可以发现 descirption 和 -a 两个帮助内容上的差异：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import argparse</span><br><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(</span><br><span class="line">...     add_help=True,</span><br><span class="line">...     description=<span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">...     description</span></span><br><span class="line"><span class="string">...         notraw</span></span><br><span class="line"><span class="string">...            formatted"</span><span class="string">""</span></span><br><span class="line">... )</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(</span><br><span class="line">...     <span class="string">'-a'</span>, action=<span class="string">"store_true"</span>,</span><br><span class="line">...     <span class="built_in">help</span>=<span class="string">""</span><span class="string">"argument</span></span><br><span class="line"><span class="string">...         notraw</span></span><br><span class="line"><span class="string">...             formatted</span></span><br><span class="line"><span class="string">...     "</span><span class="string">""</span></span><br><span class="line">... )</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'-h'</span>])</span><br><span class="line">usage: [-h] [-a]</span><br><span class="line"></span><br><span class="line">description notraw formatted</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  -a          argument notraw formatted</span><br></pre></td></tr></table></figure>
<h2 id="参数组"><a href="#参数组" class="headerlink" title="参数组"></a>参数组</h2><p>有时候，我们需要给参数分组，以使得在显示帮助信息时能够显示到一起。</p>
<p>比如某命令行支持三个参数选项 <code>--user</code>、<code>--password</code>和<code>--push</code>，前两者需要放在一个名为 <code>authentication</code> 的分组中以表示它们是身份认证信息。那么我们可以用 <code>ArgumentParser.add_argument_group</code> 来满足：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import argparse</span><br><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser()</span><br><span class="line">&gt;&gt;&gt; group = parser.add_argument_group(<span class="string">'authentication'</span>)</span><br><span class="line">&gt;&gt;&gt; group.add_argument(<span class="string">'--user'</span>, action=<span class="string">"store"</span>)</span><br><span class="line">&gt;&gt;&gt; group.add_argument(<span class="string">'--password'</span>, action=<span class="string">"store"</span>)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--push'</span>, action=<span class="string">'store'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'-h'</span>])</span><br><span class="line">usage: [-h] [--user USER] [--password PASSWORD] [--push PUSH]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>           show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  --push PUSH</span><br><span class="line"></span><br><span class="line">authentication:</span><br><span class="line">  --user USER</span><br><span class="line">  --password PASSWORD</span><br></pre></td></tr></table></figure>
<p>可以看到，当我们输出帮助信息时，<code>--user</code> 和 <code>--password</code> 选项都出现在 <code>authentication</code> 分组中。</p>
<h2 id="选项参数前缀"><a href="#选项参数前缀" class="headerlink" title="选项参数前缀"></a>选项参数前缀</h2><p>不知你是否注意到，在不同平台上命令行程序的选项参数前缀可能是不同的。比如在 Unix 上，其前缀是 <code>-</code>；而在 Windows 上，大多数命令行程序（比如 <code>findstr</code>）的选项参数前缀是 <code>/</code>。</p>
<p>在 <code>argparse</code> 中，选项参数前缀默认采用 Unix 命令行约定，也就是 <code>-</code>。但它也支持自定义前缀，下面是一个例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import argparse</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(</span><br><span class="line">...     description=<span class="string">'Option prefix'</span>,</span><br><span class="line">...     prefix_chars=<span class="string">'-+/'</span>,</span><br><span class="line">... )</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'-power'</span>, action=<span class="string">"store_false"</span>,</span><br><span class="line">...                     default=None,</span><br><span class="line">...                     <span class="built_in">help</span>=<span class="string">'Set power off'</span>,</span><br><span class="line">...                     )</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'+power'</span>, action=<span class="string">"store_true"</span>,</span><br><span class="line">...                     default=None,</span><br><span class="line">...                     <span class="built_in">help</span>=<span class="string">'Set power on'</span>,</span><br><span class="line">...                     )</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'/win'</span>,</span><br><span class="line">...                     action=<span class="string">"store_true"</span>,</span><br><span class="line">...                     default=False)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'-power'</span>])</span><br><span class="line">Namespace(power=False, win=False)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'+power'</span>, <span class="string">'/win'</span>])</span><br><span class="line">Namespace(power=True, win=True)</span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们指定了三个选项参数前缀 <code>-</code>、<code>+</code>和<code>/</code>，从而：</p>
<ul>
<li>通过指定选项参数 <code>-power</code>，使得 <code>power=False</code></li>
<li>通过指定选项参数 <code>+power</code>，使得 <code>power=True</code></li>
<li>通过指定选项参数 <code>/win</code>，使得 <code>win=True</code></li>
</ul>
<h2 id="共享解析器"><a href="#共享解析器" class="headerlink" title="共享解析器"></a>共享解析器</h2><p>有些时候我们需要共享解析器，以共享里面的参数配置。比如，我们的命令行工具需要支持对阿里云和 AWS 进行操作，两类操作都需要指定 <code>AccessKeyId</code> 和 <code>AccessKeySecret</code> 来表明用户身份和权限。那么共享解析器就显得尤为必要，这样就可以少去重复代码。</p>
<p>我们可以这样做，在 <code>base.py</code> 中定义一个父解析器，存放 <code>AccessKey</code> 相关参数配置，作为公用的解析器。由于后续的子解析器会自动生成帮助信息，这里的父解析器指定 <code>add_help=False</code> 以不自动生成帮助信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># bash.py</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(add_help=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'--ak-id'</span>, action=<span class="string">"store"</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--ak-secret'</span>, action=<span class="string">"store"</span>)</span><br></pre></td></tr></table></figure>
<p>然后就可以分别在 <code>ali.py</code> 和 <code>aws.py</code> 中分别定义子解析器，通过 <code>parents</code> 入参指定上述父解析器，从而继承公共的参数，并实现各自的参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ali.py</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> base</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(</span><br><span class="line">    parents=[base.parser],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'--ros'</span>,</span><br><span class="line">                    action=<span class="string">"store_true"</span>,</span><br><span class="line">                    default=<span class="keyword">False</span>,</span><br><span class="line">                    help=<span class="string">'Using ROS service to orchestrate cloud resources'</span>)</span><br><span class="line"></span><br><span class="line">print(parser.parse_args())</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># aws.py</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> base</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser(</span><br><span class="line">    parents=[base.parser],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">'--cloudformation'</span>,</span><br><span class="line">                    action=<span class="string">"store_true"</span>,</span><br><span class="line">                    default=<span class="keyword">False</span>,</span><br><span class="line">                    help=<span class="string">'Using CloudFormation service to orchestrate cloud resources'</span>)</span><br><span class="line"></span><br><span class="line">print(parser.parse_args())</span><br></pre></td></tr></table></figure>
<p>最终通过 <code>-h</code> 参数分别看 <code>ali.py</code> 和 <code>aws.py</code> 所支持的参数，其中共同参数为 <code>--ak-id</code> 和 <code>--ak-secret</code>，特定参数分别为 <code>--ros</code> 和 <code>--cloudformation</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 ali.py -h</span><br><span class="line"></span><br><span class="line">usage: ali.py [-h] [--ak-id AK_ID] [--ak-secret AK_SECRET] [--ros]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>            show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  --ak-id AK_ID</span><br><span class="line">  --ak-secret AK_SECRET</span><br><span class="line">  --ros                 Using ROS service to orchestrate cloud resources</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 aws.py -h</span><br><span class="line"></span><br><span class="line">usage: aws.py [-h] [--ak-id AK_ID] [--ak-secret AK_SECRET] [--cloudformation]</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>            show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  --ak-id AK_ID</span><br><span class="line">  --ak-secret AK_SECRET</span><br><span class="line">  --cloudformation      Using CloudFormation service to orchestrate cloud</span><br><span class="line">                        resources</span><br></pre></td></tr></table></figure>
<h2 id="嵌套解析器"><a href="#嵌套解析器" class="headerlink" title="嵌套解析器"></a>嵌套解析器</h2><p>我们之前介绍的命令行中，使用形式通常是 <code>cli --a --b xxx</code>。但还有一种极为常见的命令行使用方式是 <code>cli subcmd --a --b xxx</code>。比如当我们要通过 <code>git</code> 推送标签时，会用到 <code>git push --tags</code>。</p>
<p>通过实现嵌套解析器，我们可以很容易地对这种子命令的形式进行解析。</p>
<p>在嵌套解析器中，我们定义一个父解析器来作为整个命令行的入口，再分别定义 N 个子解析器来对应 N 个子命令，由此即可实现整个功能。</p>
<p>在下面这个例子中，我们支持 <code>create</code> 和 <code>delete</code> 两个子命令，用来创建或删除指定路径。而 <code>delete</code> 命令支持 <code>--recursive</code> 参数来表明是否递归删除指定路径：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cli.py</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line"></span><br><span class="line">subparsers = parser.add_subparsers(help=<span class="string">'commands'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create</span></span><br><span class="line">create_parser = subparsers.add_parser(</span><br><span class="line">    <span class="string">'create'</span>, help=<span class="string">'Create a directory'</span>)</span><br><span class="line">create_parser.add_argument(</span><br><span class="line">    <span class="string">'dirname'</span>, action=<span class="string">'store'</span>,</span><br><span class="line">    help=<span class="string">'New directory to create'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Delete</span></span><br><span class="line">delete_parser = subparsers.add_parser(</span><br><span class="line">    <span class="string">'delete'</span>, help=<span class="string">'Remove a directory'</span>)</span><br><span class="line">delete_parser.add_argument(</span><br><span class="line">    <span class="string">'dirname'</span>, action=<span class="string">'store'</span>, help=<span class="string">'The directory to remove'</span>)</span><br><span class="line">delete_parser.add_argument(</span><br><span class="line">    <span class="string">'--recursive'</span>, <span class="string">'-r'</span>, default=<span class="keyword">False</span>, action=<span class="string">'store_true'</span>,</span><br><span class="line">    help=<span class="string">'Recursively remove the directory'</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">print(parser.parse_args())</span><br></pre></td></tr></table></figure>
<p>直接指定 <code>-h</code> 来查看所支持的子命令和参数选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 cli.py -h</span><br><span class="line"></span><br><span class="line">usage: cli.py [-h] &#123;create,delete&#125; ...</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  &#123;create,delete&#125;  commands</span><br><span class="line">    create         Create a directory</span><br><span class="line">    delete         Remove a directory</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>       show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p>直接指定 <code>delete -h</code> 来查看 <code>delete</code> 子命令支持的参数选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 cli.py delete -h</span><br><span class="line"></span><br><span class="line">usage: cli.py delete [-h] [--recursive] dirname</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  dirname          The directory to remove</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>       show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  --recursive, -r  Recursively remove the directory</span><br></pre></td></tr></table></figure>
<h2 id="自定义动作"><a href="#自定义动作" class="headerlink" title="自定义动作"></a>自定义动作</h2><p>在上一篇“深入 argparse （一）”的文章中介绍过 8 种参数动作，可以说是覆盖了绝大部分场景。但是也会有一些特定需求无法被满足，比如希望获取到的参数值都是大写。在这种情况下，自定义动作就派上了用场。</p>
<p>实现一个自定义动作类，需继承自 <code>argparse.Action</code>，这个自定义动作类要传入到 <code>ArgumentParser.add_argument</code> 的 <code>action</code> 入参。当解析器解析参数时，会调用该类的 <code>__call__</code> 方法，该方法的签名为 <code>__call__(self, parser, namespace, values, option_string=None)</code>，其中：</p>
<ul>
<li>parser 为解析器实例</li>
<li>namespace 存放解析结果</li>
<li>values 即命令行中传入的参数值</li>
<li>option_string 为参数选项</li>
</ul>
<p>在下面的例子中，我们通过 <code>--words</code> 传入单词，并在自定义动作类中将其值转换为大写：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cli.py</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordsAction</span><span class="params">(argparse.Action)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, parser, namespace, values,</span></span></span><br><span class="line"><span class="function"><span class="params">                 option_string=None)</span>:</span></span><br><span class="line">        print(<span class="string">f'parser = <span class="subst">&#123;parser&#125;</span>'</span>)</span><br><span class="line">        print(<span class="string">f'values = <span class="subst">&#123;values!r&#125;</span>'</span>)</span><br><span class="line">        print(<span class="string">f'option_string = <span class="subst">&#123;option_string!r&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">        values = [v.upper() <span class="keyword">for</span> v <span class="keyword">in</span> values]</span><br><span class="line">        setattr(namespace, self.dest, values)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line">parser.add_argument(<span class="string">'--words'</span>, nargs=<span class="string">'*'</span>, action=WordsAction)</span><br><span class="line"></span><br><span class="line">results = parser.parse_args()</span><br><span class="line">print(results)</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 cli.py --words foo bar</span><br><span class="line"></span><br><span class="line">parser = ArgumentParser(prog=<span class="string">'cli.py'</span>, usage=None, description=None, formatter_class=&lt;class <span class="string">'argparse.HelpFormatter'</span>&gt;, conflict_handler=<span class="string">'error'</span>, add_help=True)</span><br><span class="line">values = [<span class="string">'foo'</span>, <span class="string">'bar'</span>]</span><br><span class="line">option_string = <span class="string">'--words'</span></span><br><span class="line">Namespace(words=[<span class="string">'FOO'</span>, <span class="string">'BAR'</span>])</span><br></pre></td></tr></table></figure>
<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>通过对 <code>argparse</code>由浅入深的介绍，相信你已经全面了解了 <code>argparse</code> 的威力，也具备了开发命令行工具的能力。但“纸上得来终觉浅，绝知此事要躬行”。</p>
<p>在下篇文章中，将带大家一起用 <code>argparse</code> 实现日常工作中常见的 <code>git</code> 命令，想想是不是有些兴奋呢？</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>argparse</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：深入 argparse（一）</title>
    <url>/2019/08/20/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9A%E6%B7%B1%E5%85%A5-argparse%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p>本文首发于 <a href="https://mp.weixin.qq.com/s/WA--NZ2TPuIaIj4jnKZS6A" target="_blank" rel="noopener">HelloGitHub</a> 公众号。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在第一篇“初探 argparse”的文章中，我们初步掌握了使用 <code>argparse</code> 的四部曲，对它有了一个基本的体感。<br>但是它具体支持哪些类型的参数？这些参数该如何配置？本文将带你深入了解 <code>argparse</code> 的参数们。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<h2 id="参数动作"><a href="#参数动作" class="headerlink" title="参数动作"></a>参数动作</h2><p>你是否还记得？在上一篇四部曲中的第二步是定义参数，在这个步骤中，我们指定了 <code>action</code> 入参：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                    const=sum, default=max,</span><br><span class="line">                    help=<span class="string">'sum the nums (default: find the max)'</span>)</span><br></pre></td></tr></table></figure>
<p>那么这里面的 <code>action</code>，也就是 <code>参数动作</code>，究竟是用来做什么的呢？</p>
<p>想象一下，当我们在命令行输入一串参数后，对于不同类型的参数是希望做不同的处理的。<br>那么 <code>参数动作</code> 其实就是告诉解析器，我们希望对应的参数该被如何处理。比如，参数值是该被存成一个值呢，还是追加到一个列表中？是当成布尔的 True 呢，还是 False？</p>
<p><code>参数动作</code> 被分成了如下 8 个类别：</p>
<ul>
<li><code>store</code> —— 保存参数的值，这是默认的参数动作。它通常用于给一个参数指定值，如指定名字：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--name'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--name'</span>, <span class="string">'Eric'</span>])</span><br><span class="line">Namespace(name=<span class="string">'Eric'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>store_const</code> —— 保存被 <code>const</code> 命名的固定值。当我们想通过是否给定参数来起到标志的作用，给定就取某个值，就可以使用该参数动作，如：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--sum'</span>, action=<span class="string">'store_const'</span>, const=sum)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--sum'</span>])</span><br><span class="line">Namespace(sum=&lt;built-in <span class="keyword">function</span> sum&gt;)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([])</span><br><span class="line">Namespace(sum=None)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>store_true</code> 和 <code>store_false</code> —— 是 <code>store_const</code> 的特殊情况，用来分别保存 True 和 False。如果为指定参数，则其默认值分别为 False 和 True，如：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--use'</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--nouse'</span>, action=<span class="string">'store_false'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--use'</span>, <span class="string">'--nouse'</span>])</span><br><span class="line">Namespace(nouse=False, use=True)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([])</span><br><span class="line">Namespace(nouse=True, use=False)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>append</code> —— 将参数值追加保存到一个列表中。它常常用于命令行中允许多个相同选项，如：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--file'</span>, action=<span class="string">'append'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--file'</span>, <span class="string">'f1'</span>, <span class="string">'--file'</span>, <span class="string">'f2'</span>])</span><br><span class="line">Namespace(file=[<span class="string">'f1'</span>, <span class="string">'f2'</span>])</span><br></pre></td></tr></table></figure>
<ul>
<li><code>append_const</code> —— 将 <code>const</code> 命名的固定值追加保存到一个列表中（<code>const</code> 的默认值为 <code>None</code>）。它常常用于将多个参数所对应的固定值都保存在同一个列表中，相应的需要 <code>dest</code> 入参来配合，以放在同一个列表中，如：</li>
</ul>
<p>不指定 <code>dest</code> 入参，则固定值保存在以参数名命名的变量中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--int'</span>, action=<span class="string">'append_const'</span>, const=int)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--str'</span>, action=<span class="string">'append_const'</span>, const=str)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--int'</span>, <span class="string">'--str'</span>])</span><br><span class="line">Namespace(int=[&lt;class <span class="string">'int'</span>&gt;], str=[&lt;class <span class="string">'str'</span>&gt;])</span><br></pre></td></tr></table></figure>
<p>指定 <code>dest</code> 入参，则固定值保存在 <code>dest</code> 命名的变量中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--int'</span>, dest=<span class="string">'types'</span>, action=<span class="string">'append_const'</span>, const=int)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--str'</span>, dest=<span class="string">'types'</span>, action=<span class="string">'append_const'</span>, const=str)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--int'</span>, <span class="string">'--str'</span>])</span><br><span class="line">Namespace(types=[&lt;class <span class="string">'int'</span>&gt;, &lt;class <span class="string">'str'</span>&gt;])</span><br></pre></td></tr></table></figure>
<ul>
<li><code>count</code> —— 计算参数出现次数，如：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--increase'</span>, <span class="string">'-i'</span>, action=<span class="string">'count'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--increas'</span>, <span class="string">'--increase'</span>])</span><br><span class="line">Namespace(increase=2)</span><br><span class="line">&gt;&gt;&gt;parser.parse_args([<span class="string">'-iii'</span>])</span><br><span class="line">Namespace(increase=3)</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>help</code> —— 打印解析器中所有选项和参数的完整帮助信息，然后退出。</p>
</li>
<li><p><code>version</code> —— 打印命令行版本，通过指定 <code>version</code> 入参来指定版本，调用后退出。如：</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser = argparse.ArgumentParser(prog=<span class="string">'CMD'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--version'</span>, action=<span class="string">'version'</span>, version=<span class="string">'%(prog)s 1.0'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--version'</span>])</span><br><span class="line">CMD 1.0</span><br></pre></td></tr></table></figure>
<h2 id="参数类别"><a href="#参数类别" class="headerlink" title="参数类别"></a>参数类别</h2><p>如果说 <code>参数动作</code> 定义了解析器在接收到参数后该如何处理参数，那么 <code>参数类别</code> 就是告诉解析器这个参数的元信息，也就是参数是什么样的。比如，参数是字符串呢？还是布尔类型呢？参数是在几个值中可选的呢？还是可以给定值，等等。</p>
<p>下面，我们将逐一介绍不同类型的参数。</p>
<h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><p><code>可选参数</code> 顾名思义就是参数是可以加上，或不加上。默认情况下，通过 <code>ArgumentParser.add_argument</code> 添加的参数就是可选参数。</p>
<p>我们可以通过 <code>-</code> 来指定短参数，也就是名称短的参数；也可以通过 <code>--</code> 来指定长参数，也就是名称长的参数。当然也可以两个都指定。</p>
<p>可选参数通常用于：用户提供一个参数以及对应值，则使用该值；若不提供，则使用默认值。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--name'</span>, <span class="string">'-n'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--name'</span>, <span class="string">'Eric'</span>])  <span class="comment"># 通过长参数指定名称</span></span><br><span class="line">Namespace(name=<span class="string">'Eric'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'-n'</span>, <span class="string">'Eric'</span>]) <span class="comment"># 通过短参数指定名称</span></span><br><span class="line">Namespace(name=<span class="string">'Eric'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([]) <span class="comment"># 不指定则默认为 None</span></span><br><span class="line">Namespace(name=None)</span><br></pre></td></tr></table></figure>
<h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><p><code>参数类型</code> 就是解析器参数值是要作为什么类型去解析，默认情况下是 <code>str</code> 类型。我们可以通过 <code>type</code> 入参来指定参数类型。</p>
<p><code>argparse</code> 所支持的参数类型多种多样，可以是 <code>int</code>、<code>float</code>、<code>bool</code>等，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'-i'</span>, <span class="built_in">type</span>=int)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'-f'</span>, <span class="built_in">type</span>=<span class="built_in">float</span>)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'-b'</span>, <span class="built_in">type</span>=bool)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'-i'</span>, <span class="string">'1'</span>, <span class="string">'-f'</span>, <span class="string">'2.1'</span>, <span class="string">'-b'</span>, <span class="string">'0'</span>])</span><br><span class="line">Namespace(b=False, f=2.1, i=1)</span><br></pre></td></tr></table></figure>
<p>更厉害的是，<code>type</code> 入参还可以是可调用(<code>callable</code>)对象。这就给了我们很大的想象空间，可以指定 <code>type=open</code> 来把参数值作为文件进行处理，也可以指定自定义函数来进行类型检查和类型转换。</p>
<p>作为文件进行处理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--file'</span>, <span class="built_in">type</span>=open)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--file'</span>, <span class="string">'README.md'</span>])</span><br><span class="line">Namespace(b=None, f=None, file=&lt;_io.TextIOWrapper name=<span class="string">'README.md'</span> mode=<span class="string">'r'</span> encoding=<span class="string">'cp936'</span>&gt;, i=None)</span><br></pre></td></tr></table></figure>
<p>使用自定义函数进行处理，入参为参数值，需返回转换后的结果。<br>比如，对于参数 <code>--num</code>，我们希望当其值小于 1 时则返回 1，大于 10 时则返回 10：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; def <span class="built_in">limit</span>(string):</span><br><span class="line">...   num = int(string)</span><br><span class="line">...   <span class="keyword">if</span> num &lt; 1:</span><br><span class="line">...     <span class="built_in">return</span> 1</span><br><span class="line">...   <span class="keyword">if</span> num &gt; 10:</span><br><span class="line">...     <span class="built_in">return</span> 10</span><br><span class="line">...   <span class="built_in">return</span> num</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--num'</span>, <span class="built_in">type</span>=<span class="built_in">limit</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--num'</span>, <span class="string">'-1'</span>])  <span class="comment"># num 小于1，则取1</span></span><br><span class="line">Namespace(num=1)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--num'</span>, <span class="string">'15'</span>])  <span class="comment"># num 大于10，则取10</span></span><br><span class="line">Namespace(num=10)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--num'</span>, <span class="string">'5'</span>])  <span class="comment"># num 在1和10之间，则取原来的值</span></span><br><span class="line">Namespace(num=5)</span><br></pre></td></tr></table></figure>
<h3 id="参数默认值"><a href="#参数默认值" class="headerlink" title="参数默认值"></a>参数默认值</h3><p><code>参数默认值</code> 用于在命令行中不传参数值的情况下的默认取值，可通过 <code>default</code> 来指定。如果不指定该值，则参数默认值为 <code>None</code>。</p>
<p>比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'-i'</span>, default=0, <span class="built_in">type</span>=int)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'-f'</span>, default=3.14, <span class="built_in">type</span>=<span class="built_in">float</span>)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'-b'</span>, default=True, <span class="built_in">type</span>=bool)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([])</span><br><span class="line">Namespace(b=True, f=3.14, i=0)</span><br></pre></td></tr></table></figure>
<h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p><code>位置参数</code> 就是通过位置而非是 <code>-</code> 或 <code>--</code> 开头的参数来指定参数值。</p>
<p>比如，我们可以指定两个位置参数 <code>x</code> 和 <code>y</code> ，先添加的 <code>x</code> 位于第一个位置，后加入的 <code>y</code> 位于第二个位置。那么在命令行中输入 <code>1 2</code>的时候，分别对应到的就是 <code>x</code> 和 <code>y</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'x'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'y'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'1'</span>, <span class="string">'2'</span>])</span><br><span class="line">Namespace(x=<span class="string">'1'</span>, y=<span class="string">'2'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="可选值"><a href="#可选值" class="headerlink" title="可选值"></a>可选值</h3><p><code>可选值</code> 就是限定参数值的内容，通过 <code>choices</code> 入参指定。</p>
<p>有些情况下，我们可能需要限制用户输入参数的内容，只能在预设的几个值中选一个，那么 <code>可选值</code> 就派上了用场。</p>
<p>比如，指定文件读取方式限制为 <code>read-only</code> 和 <code>read-write</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--mode'</span>, choices=(<span class="string">'read-only'</span>, <span class="string">'read-write'</span>))</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--mode'</span>, <span class="string">'read-only'</span>])</span><br><span class="line">Namespace(mode=<span class="string">'read-only'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--mode'</span>, <span class="string">'read'</span>])</span><br><span class="line">usage: [-h] [--mode &#123;<span class="built_in">read</span>-only,<span class="built_in">read</span>-write&#125;]</span><br><span class="line">: error: argument --mode: invalid choice: <span class="string">'read'</span> (choose from <span class="string">'read-only'</span>, <span class="string">'read-write'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="互斥参数"><a href="#互斥参数" class="headerlink" title="互斥参数"></a>互斥参数</h3><p><code>互斥参数</code> 就是多个参数之间彼此互斥，不能同时出现。使用互斥参数首先通过 <code>ArgumentParser.add_mutually_exclusive_group</code> 在解析器中添加一个互斥组，然后在这个组里添加参数，那么组内的所有参数都是互斥的。</p>
<p>比如，我们希望通过命令行来告知乘坐的交通工具，要么是汽车，要么是公交，要么是自行车，那么就可以这么写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; group = parser.add_mutually_exclusive_group()</span><br><span class="line">&gt;&gt;&gt; group.add_argument(<span class="string">'--car'</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line">&gt;&gt;&gt; group.add_argument(<span class="string">'--bus'</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line">&gt;&gt;&gt; group.add_argument(<span class="string">'--bike'</span>, action=<span class="string">'store_true'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([])  <span class="comment"># 什么都不乘坐</span></span><br><span class="line">Namespace(bike=False, bus=False, car=False)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--bus'</span>])  <span class="comment"># 乘坐公交</span></span><br><span class="line">Namespace(bike=False, bus=True, car=False)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--bike'</span>])  <span class="comment"># 骑自行车</span></span><br><span class="line">Namespace(bike=True, bus=False, car=False)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--bike'</span>, <span class="string">'--car'</span>])  <span class="comment"># 又想骑车，又想坐车，那是不行的</span></span><br><span class="line">usage: [-h] [--car | --bus | --bike]</span><br><span class="line">: error: argument --car: not allowed with argument --bike</span><br></pre></td></tr></table></figure>
<h3 id="可变参数列表"><a href="#可变参数列表" class="headerlink" title="可变参数列表"></a>可变参数列表</h3><p><code>可变参数列表</code> 用来定义一个参数可以有多个值，且能通过 <code>nargs</code> 来定义值的个数。</p>
<p>若 <code>nargs=N</code>，<code>N</code>为一个数字，则要求该参数提供 N 个值，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--foo'</span>, nargs=2)</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>]))</span><br><span class="line">Namespace(foo=[<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">&gt;&gt;&gt; <span class="built_in">print</span>(parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]))</span><br><span class="line">usage: [-h] [--foo FOO FOO]</span><br><span class="line">: error: unrecognized arguments: c</span><br></pre></td></tr></table></figure>
<p>若 <code>nargs=?</code>，则要求改参数提供 0 或 1 个值，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="string">'?'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--foo'</span>])</span><br><span class="line">Namespace(foo=None)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'a'</span>])</span><br><span class="line">Namespace(foo=<span class="string">'a'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">usage: [-h] [--foo [FOO]]</span><br><span class="line">: error: unrecognized arguments: b</span><br></pre></td></tr></table></figure>
<p>若 <code>nargs=*</code>，则要求改参数提供 0 或多个值，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="string">'*'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--foo'</span>])</span><br><span class="line">Namespace(foo=[])</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'a'</span>])</span><br><span class="line">Namespace(foo=[<span class="string">'a'</span>])</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</span><br><span class="line">Namespace(foo=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</span><br></pre></td></tr></table></figure>
<p>若 <code>nargs=?</code>，则要求改参数至少提供 1 个值，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; parser.add_argument(<span class="string">'--foo'</span>, nargs=<span class="string">'+'</span>)</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--foo'</span>, <span class="string">'a'</span>])</span><br><span class="line">Namespace(foo=[<span class="string">'a'</span>])</span><br><span class="line">&gt;&gt;&gt; parser.parse_args([<span class="string">'--foo'</span>])</span><br><span class="line">usage: [-h] [--foo FOO [FOO ...]]</span><br><span class="line">: error: argument --foo: expected at least one argument</span><br></pre></td></tr></table></figure>
<h2 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h2><p>在了解了参数动作和参数类别后，是不是渐渐开始对使用 <code>argparse</code> 胸有成竹了呢？至少，用现在学到的知识来完成简单的命令行工具已经不再话下了。</p>
<p>在下一篇文章中，我们来继续深入了解 <code>argparse</code> 的功能，如何修改参数前缀，如何定义参数组，如何定义嵌套的解析器，如何编写自定义动作等，让我们拭目以待吧~</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>argparse</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 命令行之旅：初探 argparse</title>
    <url>/2019/08/13/Python-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B9%8B%E6%97%85%EF%BC%9A%E5%88%9D%E6%8E%A2-argparse/</url>
    <content><![CDATA[<p>本文首发于 <a href="https://mp.weixin.qq.com/s/Guz0xDOArbrVGCZMCwx2cg" target="_blank" rel="noopener">HelloGitHub</a> 公众号。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>你是否好奇过在命令行中敲入一段命令后，它是如何被解析执行的？是否考虑过由自己实现一个命令行工具，帮你执行和处理任务？是否了解过陪伴在你身边的 Python 有着丰富的库，来帮你轻松打造命令行工具？</p>
<p>别着急，本文作为 Python 命令行之旅的第一篇将带你逐步揭开命令行解析的面纱，介绍如何使用 Python 内置的 <code>argparse</code> 标准库解析命令行，并在后续的系列文章中介绍各具特色的第三方命令行库，讲讲它们的异同，进而全面地体验这次探索的旅程。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">本系列文章默认使用 Python 3 作为解释器进行讲解。</span><br><span class="line">若你仍在使用 Python 2，请注意两者之间语法和库的使用差异哦~</span><br></pre></td></tr></table></figure>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>argparse</code> 作为 Python 内置的标准库，提供了较为简单的方式来编写命令行接口。当你在程序中定义需要哪些参数，<code>argparse</code> 便会从 <code>sys.argv</code> 中获取命令行输入进行解析，对正确或非法输入做出响应，也可以自动生成帮助信息和使用说明。</p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="设置解析器"><a href="#设置解析器" class="headerlink" title="设置解析器"></a>设置解析器</h3><p>第一步要做的就是设置解析器，后续对命令行的解析就依赖于这个解析器，它能够将命令行字符串转换为 Python 对象。<br>通过实例化 <code>argparse.ArgumentParser</code>，给定一些选填参数，我们就可以设置一个解析器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line">parser = argparse.ArgumentParser(</span><br><span class="line">    description=<span class="string">'My Cmd Line Program'</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="定义参数"><a href="#定义参数" class="headerlink" title="定义参数"></a>定义参数</h3><p>通过 <code>ArgumentParser.add_argument</code> 方法来为解析器设置参数信息，以告诉解析器命令行字符串中的哪些内容应解析为哪些类型的 Python 对象，如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加 nums 参数，在使用信息中显示为 num</span></span><br><span class="line"><span class="comment"># 其类型为 int，且支持输入多个，且至少需要提供一个</span></span><br><span class="line">parser.add_argument(<span class="string">'nums'</span>,  metavar=<span class="string">'num'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                    help=<span class="string">'a num for the accumulator'</span>)</span><br><span class="line"><span class="comment"># 添加 --sum 参数，该参数被 parser 解析后所对应的属性名为 accumulate</span></span><br><span class="line"><span class="comment"># 若不提供 --sum，默认值为 max 函数，否则为 sum 函数</span></span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                    const=sum, default=max,</span><br><span class="line">                    help=<span class="string">'sum the nums (default: find the max)'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="解析命令行"><a href="#解析命令行" class="headerlink" title="解析命令行"></a>解析命令行</h3><p>定义好参数后，就可以使用 <code>ArgumenteParser.parse_args</code> 方法来解析一组命令行参数字符串了。</p>
<p>默认情况下，参数取自 <code>sys.argv[1:]</code>，它就是你在命令行敲入的一段命令（不含文件名）所对应的一个字符串列表。<br>比如，若你输入 <code>python3 cmd.py --sum 1 2 3</code>，那么 <code>sys.argsv[1:]</code> 就是 <code>[&#39;--sum&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;]</code>。</p>
<p>当然，也可以通过 <code>parse_args</code> 入参来指定一组命令行参数字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">args = parser.parse_args([<span class="string">'--sum'</span>, <span class="string">'-1'</span>, <span class="string">'0'</span>, <span class="string">'1'</span>])</span><br><span class="line">print(args) <span class="comment"># 结果：Namespace(accumulate=&lt;built-in function sum&gt;, nums=[-1, 0, 1])</span></span><br></pre></td></tr></table></figure>
<h3 id="业务逻辑"><a href="#业务逻辑" class="headerlink" title="业务逻辑"></a>业务逻辑</h3><p>解析好命令行后，我们就可以从解析结果中获取每个参数的值，进而根据自己的业务需求做进一步的处理。<br>比如，对于上文中所定义的 nums 参数，我们可以通过解析后的结果中的 <code>accumulate</code> 方法对其进行求最大值或求和（取决于是否提供 <code>--sum</code> 参数）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = args.accumulate(args.nums)</span><br><span class="line">print(result)  <span class="comment"># 基于上文的 ['--sum', '-1', '0', '1'] 参数，accumulate 为 sum 函数，其结果为 0</span></span><br></pre></td></tr></table></figure>
<h3 id="代码梳理"><a href="#代码梳理" class="headerlink" title="代码梳理"></a>代码梳理</h3><p>通过上文的讲解，完成一个命令行工具的步骤是不是挺简单易懂呢？我们将上文的代码汇总下，以有一个更清晰的认识：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cmd.py</span></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 设置解析器</span></span><br><span class="line">parser = argparse.ArgumentParser(</span><br><span class="line">    description=<span class="string">'My Cmd Line Program'</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 定义参数</span></span><br><span class="line">parser.add_argument(<span class="string">'nums'</span>,  metavar=<span class="string">'num'</span>, type=int, nargs=<span class="string">'+'</span>,</span><br><span class="line">                    help=<span class="string">'a num for the accumulator'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--sum'</span>, dest=<span class="string">'accumulate'</span>, action=<span class="string">'store_const'</span>,</span><br><span class="line">                    const=sum, default=max,</span><br><span class="line">                    help=<span class="string">'sum the nums (default: find the max)'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 解析命令行</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 业务逻辑</span></span><br><span class="line">result = args.accumulate(args.nums)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure>
<p>若我们需要对一组数字求和，只需执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 cmd.py --sum -1 0 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>若我们需要对一组数字求最大值，只需执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 cmd.py -1 0 1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p>如果给定的参数不是数字，则会报错提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ python3 cmd.py a b c</span><br><span class="line">usage: cmd.py [-h] [--sum] num [num ...]</span><br><span class="line">cmd.py: error: argument num: invalid int value: <span class="string">'a'</span></span><br></pre></td></tr></table></figure>
<p>我们还可以通过 <code>-h</code> 或 <code>--help</code> 参数查看其自动生成的使用说明和帮助：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usage: cmd.py [-h] [--sum] num [num ...]</span><br><span class="line"></span><br><span class="line">My Cmd Line Program</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  num         a num <span class="keyword">for</span> the accumulator</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>  show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  --sum       sum the nums (default: find the max)</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>怎么样？揭开命令行工具的神秘面纱后，是不是发现它并没有想象中的困难？反倒是感受到一种简单而又强大的优雅呢？</p>
<p>不过这还远远不是 <code>argparse</code> 的全部面貌。对于一些复杂的情况，比如各种类型参数、参数前缀、参数组、互斥选项、嵌套解析、自定义帮助等等，我们都还没涉及探讨。</p>
<p>在下一篇文章中，让我们来一起深入了解 <code>argparse</code>，感受它的魅力吧！</p>
<h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><ul>
<li><a href="/2019/08/13/Python-命令行之旅：初探-argparse/" title="Python 命令行之旅：初探 argparse">Python 命令行之旅：初探 argparse</a></li>
<li><a href="/2019/08/20/Python-命令行之旅：深入-argparse（一）/" title="Python 命令行之旅：深入 argparse（一）">Python 命令行之旅：深入 argparse（一）</a></li>
<li><a href="/2019/08/27/Python-命令行之旅：深入-argparse（二）/" title="Python 命令行之旅：深入 argparse（二）">Python 命令行之旅：深入 argparse（二）</a></li>
<li><a href="/2019/09/04/Python-命令行之旅：使用-argparse-实现-git-命令/" title="Python 命令行之旅：使用 argparse 实现 git 命令">Python 命令行之旅：使用 argparse 实现 git 命令</a></li>
<li><a href="/2019/10/09/Python-命令行之旅：初探-docopt/" title="Python 命令行之旅：初探 docopt">Python 命令行之旅：初探 docopt</a></li>
<li><a href="/2019/10/15/Python-命令行之旅：深入-docopt/" title="Python 命令行之旅：深入 docopt">Python 命令行之旅：深入 docopt</a></li>
<li><a href="/2019/10/30/Python-命令行之旅：使用-docopt-实现-git-命令/" title="Python 命令行之旅：使用 docopt 实现 git 命令">Python 命令行之旅：使用 docopt 实现 git 命令</a></li>
<li><a href="/2019/11/04/Python-命令行之旅：初探-click/" title="Python 命令行之旅：初探 click">Python 命令行之旅：初探 click</a></li>
<li><a href="/2019/11/11/Python-命令行之旅：深入-click（一）/" title="Python 命令行之旅：深入 click（一）">Python 命令行之旅：深入 click（一）</a></li>
<li><a href="/2019/11/17/Python-命令行之旅：深入-click（二）/" title="Python 命令行之旅：深入 click（二）">Python 命令行之旅：深入 click（二）</a></li>
<li><a href="/2019/11/25/Python-命令行之旅：深入-click（三）/" title="Python 命令行之旅：深入 click（三）">Python 命令行之旅：深入 click（三）</a></li>
<li><a href="/2019/12/09/Python-命令行之旅：深入-click（四）/" title="Python 命令行之旅：深入 click（四）">Python 命令行之旅：深入 click（四）</a></li>
<li><a href="/2019/12/14/Python-命令行之旅：使用-click-实现-git-命令/" title="Python 命令行之旅：使用 click 实现 git 命令">Python 命令行之旅：使用 click 实现 git 命令</a></li>
<li><a href="/2019/12/22/Python-命令行之旅：初探-fire/" title="Python 命令行之旅：初探 fire">Python 命令行之旅：初探 fire</a></li>
<li><a href="/2019/12/29/Python-命令行之旅：深入-fire（一）/" title="Python 命令行之旅：深入 fire（一）">Python 命令行之旅：深入 fire（一）</a></li>
<li><a href="/2020/01/05/Python-命令行之旅：深入-fire（二）/" title="Python 命令行之旅：深入 fire（二）">Python 命令行之旅：深入 fire（二）</a></li>
<li><a href="/2020/01/12/Python-命令行之旅：使用-fire-实现-git-命令/" title="Python 命令行之旅：使用 fire 实现 git 命令">Python 命令行之旅：使用 fire 实现 git 命令</a></li>
<li><a href="/2020/02/09/Python-命令行之旅：argparse、docopt、click-和-fire-总结篇/" title="Python 命令行之旅：argparse、docopt、click 和 fire 总结篇">Python 命令行之旅：argparse、docopt、click 和 fire 总结篇</a></li>
<li><a href="/2020/07/02/Python-命令行大乱斗/" title="Python 命令行大乱斗">Python 命令行大乱斗</a>
</li>
</ul>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>
]]></content>
      <categories>
        <category>Python</category>
        <category>命令行</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>命令行</tag>
        <tag>argparse</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 跨平台兼容性实践——记 PyCon China 2017 的一次分享</title>
    <url>/2019/04/14/Python-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E5%AE%9E%E8%B7%B5%E2%80%94%E2%80%94%E8%AE%B0-PyCon-China-2017-%E7%9A%84%E4%B8%80%E6%AC%A1%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>2017 年大概 11 月份时在 PyCon China 2017 杭州站分享了  Python 跨平台兼容性实践，讲述了如何让 Python 程序兼容更多的平台。</p>
<p>遗憾的是，当时没有影像资料，又缺少文字记录。现在应朋友的要求，将当时的内容整理成文字。</p>
<p>本文将首先介绍背景，然后介绍如何做到解释器的兼容性，再介绍库的兼容性，最后介绍如何进行多个平台的持续集成，从而达到跨平台兼容性的目的。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>为什么要做跨平台兼容性？</p>
<a id="more"></a>
<p>我们的产品部署架构如下：<br><img src="/2019/04/14/Python-跨平台兼容性实践——记-PyCon-China-2017-的一次分享/deployment-architecture.png"></p>
<p>每一台目标机上需要安装一台 Agent，Agent Server 对这些 Agent 进行管理。而由于目标机众多（成千上万台），其操作系统也可能千差万别。我们需要支持不同的操作系统大类（如 Windows、Linux、AIX 等）、不同的发行版（如 CentOS、Debian 等）、不同的版本（如 CentOS 5、6、7）。而 Agent 是由 Python 编写的，这就对 Python 程序的兼容性提出了很高的要求。<br><img src="/2019/04/14/Python-跨平台兼容性实践——记-PyCon-China-2017-的一次分享/agent-systems.png"></p>
<p>若要做好兼容性，我们需要考虑如下内容：</p>
<ul>
<li>解释器兼容性。由于 Agent 自带 Python 解释器，首先需要让 Python 解释器支持目标平台。</li>
<li>库兼容性。每个库都有其特定的平台要求，需要改造所依赖的库以支持目标平台。</li>
<li>多平台持续集成。不同平台构建出的 Agent 程序包是不同的，如何进行有效的构建管理是需要思考的问题。</li>
</ul>
<h1 id="解释器兼容性"><a href="#解释器兼容性" class="headerlink" title="解释器兼容性"></a>解释器兼容性</h1><h2 id="Python-2-还是-3？"><a href="#Python-2-还是-3？" class="headerlink" title="Python 2 还是 3？"></a>Python 2 还是 3？</h2><p>摆在我们眼前的第一个问题就是到底是用 Python 2 还是 3？究竟哪个解释器对跨平台的支持力度更好呢？</p>
<p>我们对它们所支持的操作系统做了一个简单的对比，发现 Python 3 相对于 Python 2 来说少了对 Windows 2003 的支持。<br><img src="/2019/04/14/Python-跨平台兼容性实践——记-PyCon-China-2017-的一次分享/python-system-compare.png"></p>
<p>对我们所依赖的 Python 库做了对比，发现当时的两个核心依赖库对 Python 3 支持的都不好。<br><img src="/2019/04/14/Python-跨平台兼容性实践——记-PyCon-China-2017-的一次分享/python-lib-compare.png"></p>
<p>所以，在这个问题上，我们投 Python 2 一票。</p>
<h2 id="现成的解释器兼容方案"><a href="#现成的解释器兼容方案" class="headerlink" title="现成的解释器兼容方案"></a>现成的解释器兼容方案</h2><p>如果市面上有现成的解释器兼容方案，那么我们就拿来主义即可，不用自己再去折腾。市面上主流的有两个 Python 集成环境：Anaconda 和 ActivePython，我们做了一个对比：<br><img src="/2019/04/14/Python-跨平台兼容性实践——记-PyCon-China-2017-的一次分享/python-product-compare.png"></p>
<p>Anaconda 的优势在于支持运行于 Power 8 处理器的常见操作系统，迭代速度快、开源；而 ActivePython 的优势在于支持 AIX 和 HP-UX 系统。考虑到没钱，我们选择 Anaconda 作为 Windows 和 Linux 平台的基础解释器环境。</p>
<p>当然了，Anaconda 在少数几个平台上会遇到各种无法运行的问题。</p>
<p><strong>在 SUSE 10.0 上</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">linux:~/python-linux-64 # ./bin/python</span><br><span class="line">Floating point exception</span><br></pre></td></tr></table></figure>
<p><strong>在 AIX 6.1 上</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">IBM-P520: ~/python-linux-64# ./bin/python</span><br><span class="line">-bash: ./bin/python: cannot execute binary file: Exec format error</span><br></pre></td></tr></table></figure>
<p>针对于上述情况，我们在特定平台上需要定制的解释器。</p>
<h2 id="特定平台兼容性方案"><a href="#特定平台兼容性方案" class="headerlink" title="特定平台兼容性方案"></a>特定平台兼容性方案</h2><p>所谓的特定平台兼容性方案，其实就是编译，分为两个步骤：</p>
<ol>
<li>编译必要的 Python 依赖库，如：<ul>
<li>sqlite 轻量级数据库</li>
<li>zlib 数据压缩库</li>
<li>readline 交互式文本编辑库</li>
<li>openssl TSL 和 SSL 密码库</li>
</ul>
</li>
<li>编译 Python 2</li>
</ol>
<p>不同平台上的编译方法略有差异。</p>
<h3 id="在-Linux-上编译"><a href="#在-Linux-上编译" class="headerlink" title="在 Linux 上编译"></a>在 Linux 上编译</h3><p><strong>sqlite/zlib/readline</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">linux:~ # CFLAGS=-fPIC ./configure --prefix=/opt/python-suse64/</span><br><span class="line">linux:~ # make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p><strong>openssl</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">linux:~ # CFLAGS=-fPIC ./config shared --prefix=/opt/python-suse64/</span><br><span class="line">linux:~ # make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p><strong>Python 2</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">linux:~ # LDFLAGS="-Wl,-rpath=\$\$ORIGIN/../lib" ./configure --prefix=/opt/python-suse64</span><br><span class="line">linux:~ # make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p><strong>简单验证</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">linux:~/python-suse10<span class="number">-64</span> <span class="comment"># ./bin/python</span></span><br><span class="line">Python <span class="number">2.7</span><span class="number">.13</span> (default, Jul  <span class="number">7</span> <span class="number">2017</span>, <span class="number">04</span>:<span class="number">15</span>:<span class="number">22</span>)</span><br><span class="line">[GCC <span class="number">4.0</span><span class="number">.2</span> <span class="number">20050901</span> (prerelease) (SUSE Linux)] on linux2</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> platform, hashlib, zlib, sqlite3</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>platform.architecture()</span><br><span class="line">(<span class="string">'64bit'</span>, <span class="string">'ELF'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>hashlib.sha1().hexdigest()</span><br><span class="line"><span class="string">'da39a3ee5e6b4b0d3255bfef95601890afd80709'</span></span><br></pre></td></tr></table></figure>
<h3 id="在-AIX-上编译"><a href="#在-AIX-上编译" class="headerlink" title="在 AIX 上编译"></a>在 AIX 上编译</h3><p>确保安装了 bash、gcc 等必要工具。AIX 是 Unix 平台的一个发行版，我们是要使用和 Linux 上一样的编译方法吗？不如照着上面的方法执行一遍。</p>
<p><strong>简单验证</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">IBM-P520:/opt/python-aix<span class="number">-64</span><span class="comment"># ./bin/python</span></span><br><span class="line">Python <span class="number">2.7</span><span class="number">.13</span> (default, Apr <span class="number">20</span> <span class="number">2017</span>, <span class="number">22</span>:<span class="number">45</span>:<span class="number">10</span>)</span><br><span class="line">[GCC <span class="number">4.8</span><span class="number">.4</span>] on aix6</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> platform</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>platform.architecture()</span><br><span class="line">(<span class="string">'32bit'</span>, <span class="string">''</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>quit()</span><br><span class="line">IBM-P520:/opt/python-aix<span class="number">-64</span></span><br><span class="line"><span class="comment"># bootinfo -K</span></span><br><span class="line"><span class="number">64</span></span><br></pre></td></tr></table></figure>
<p>查看上述结果我们发现，AIX 明明是 64 位的，结果却显示 32 位。这是因为 Python 解释器本身是 32 位。那就是说直接套用上一节中的方法还不能编译出系统自身位数的 Python 解释器，还需加以改造。</p>
<p>通过以下方法，我们显式地编译 64 位版本的 Python 解释器。</p>
<p><strong>sqlite</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">IBM-P520:/opt# CC="gcc -maix64" ARFLAGS="-X64 cr" ./configure --prefix=/opt/python-aix64/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改 libtool 中 AR_FLAGS=<span class="string">"cru"</span> 为 AR_FLAGS=<span class="string">"-X64 cru"</span></span></span><br><span class="line">IBM-P520:/opt# OBJECT_MODE=64 make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p><strong>zlib/readline</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">IBM-P520:/opt# CFLAGS="-maix64" ARFLAGS="-X64 cr" ./configure --prefix=/opt/python-aix64/</span><br><span class="line">IBM-P520:/opt# OBJECT_MODE=64 make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p><strong>openssl</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">IBM-P520:/opt# ./Configure threads --prefix=/opt/python-aix64 aix64-gcc</span><br><span class="line">IBM-P520:/opt# make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p><strong>Python 2</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">IBM-P520:/opt# ./configure --prefix=/opt/python-aix64 --with-gcc="gcc -maix64" CXX="g++ -maix64" AR="ar -X64" CFLAGS=-fPIC</span><br><span class="line">IBM-P520:/opt# make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>编译好后，在验证时可能遇到这样的问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> zlib</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ImportError: Could <span class="keyword">not</span> load module /opt/python-aix<span class="number">-64</span>/lib/python2<span class="number">.7</span>/lib-dynload/zlib.so.</span><br><span class="line">        Dependent module /opt/freeware/lib/gcc/powerpc-ibm-aix6<span class="number">.1</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">6.3</span><span class="number">.0</span>/../../../libz.so could <span class="keyword">not</span> be loaded.</span><br><span class="line">Could <span class="keyword">not</span> load module /opt/freeware/lib/gcc/powerpc-ibm-aix6<span class="number">.1</span><span class="number">.0</span><span class="number">.0</span>/<span class="number">6.3</span><span class="number">.0</span>/../../../libz.so.</span><br><span class="line">System error: Exec format error</span><br><span class="line">Could <span class="keyword">not</span> load module /opt/python-aix<span class="number">-64</span>/lib/python2<span class="number">.7</span>/lib-dynload/zlib.so.</span><br><span class="line">        Dependent module /opt/python-aix<span class="number">-64</span>/lib/python2<span class="number">.7</span>/lib-dynload/zlib.so could <span class="keyword">not</span> be loaded.</span><br></pre></td></tr></table></figure>
<p>这是因为当你把编译好的文件夹移动到其他目录后，解释器无法找到动态链接库（编译的时候写死了路径），所以在运行时需要指定 lib 路径：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">LD_LIBRARY_PATH=/opt/python-aix-64/lib ./bin/python</span><br></pre></td></tr></table></figure>
<h3 id="pip"><a href="#pip" class="headerlink" title="pip"></a>pip</h3><p>编译完 Python 后，我们还需要安装 pip，用来后续安装各种 Python 库。不过在 AIX 上安装 pip 库时，你可能会遇到这样的问题：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Modules/ld_so_aix gcc -maix64 -pthread -bI:Modules/python.exp build/temp.aix-6.1-2.7/psutil/_psutil_aix.o build/temp.aix-6.1-2.7/psutil/arch/aix/net_connections.o -lperfstat -o build/lib.aix-6.1-2.7/psutil/_psutil_aix.so</span><br><span class="line">unable to execute 'Modules/ld_so_aix': No such file or directory</span><br><span class="line">error: command 'Modules/ld_so_aix' failed with exit status 1</span><br></pre></td></tr></table></figure>
<p>从报错可以看出，是找不到 <code>Modules/ld_so_aix</code>，那么我们就对症下药，显式地指明这个路径。修改 <code>./lib/python2.7/_sysconfigdata.py</code> 的构建相关参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># system configuration generated and used by the sysconfig module</span></span><br><span class="line">build_time_vars = &#123;</span><br><span class="line">        ...</span><br><span class="line">    <span class="string">'BLDSHARED'</span>: <span class="string">'Modules/ld_so_aix gcc -maix64 -pthread -bI:Modules/python.exp'</span>,</span><br><span class="line">    ...</span><br><span class="line">    <span class="string">'LDSHARED'</span>: <span class="string">'Modules/ld_so_aix gcc -maix64 -pthread -bI:Modules/python.exp'</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>Modules</code> 修改为 <code>./lib/python2.7/config</code> 的绝对路径。</p>
<p>在完成的 Python 的编译和 pip 的安装后，我们就要考虑库的兼容性了。</p>
<h1 id="库兼容性"><a href="#库兼容性" class="headerlink" title="库兼容性"></a>库兼容性</h1><p>考虑到 Agent 主要的作用是采集和控制，那么主要就需要考虑如下几个方面的兼容性：</p>
<ul>
<li>平台参数，如操作系统、发行版、版本号等</li>
<li>进程、系统管理功能，如查看进程、网络等</li>
<li>文件管理功能，如高级拷贝、重命名、删除</li>
<li>进程守护功能，如以服务形式来守护进程</li>
</ul>
<p>以上类别我们都依赖了特定的库，包括标准库和第三方库。我们需要考察所依赖库的兼容性，并对其不兼容的地方加以改造。</p>
<h2 id="平台库-platform"><a href="#平台库-platform" class="headerlink" title="平台库 platform"></a>平台库 platform</h2><p>我们使用 Python 标准库 platform 来检测 Agent 所运行的平台。platform 库在 Ubuntu 发行版上的存在识别出错的问题。</p>
<p><strong>编译的 Python</strong><br>我们所编译的 Python 使用 platform 误将 Ubuntu 识别为了 Debian。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> platform</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>platform.platform()</span><br><span class="line"><span class="string">'Linux-4.4.0-62-generic-x86_64-with-debian-stretch-sid'</span></span><br></pre></td></tr></table></figure>
<p><strong>系统自带的 Python</strong><br>而 Ubuntu 系统自带的 Python 使用 platform 却能正常识别。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> platform</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>platform.platform()</span><br><span class="line"><span class="string">'Linux-4.4.0-62-generic-x86_64-with-Ubuntu-16.04-xenial'</span></span><br></pre></td></tr></table></figure>
<p>这背后是因为 Ubuntu 系统自带的 Python 对 platform 标准库进行了改造。查看其源码，我们可以发现多了如下内容的改造：<br><code>platform.py</code><br><img src="/2019/04/14/Python-跨平台兼容性实践——记-PyCon-China-2017-的一次分享/ubuntu-python-platform-code.png"></p>
<p><code>/etc/lsb-release</code><br><img src="/2019/04/14/Python-跨平台兼容性实践——记-PyCon-China-2017-的一次分享/ubuntu-lsb-release.png"></p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>对平台库来说，我们关注如下几点：</p>
<ul>
<li>系统大类，如 Windows、Linux、UNIX 等</li>
<li>发行版，如 CentOS</li>
<li>发行版本号，如 2003(Win)、7.2.1511(CentOS)</li>
<li>内核版本号，如 10.0.14393(Win)、3.10.0(Linux)</li>
</ul>
<p>而 platform 标准库存在一些不足：</p>
<ul>
<li>行为分裂</li>
<li>结果有疏漏</li>
<li>不够易用</li>
</ul>
<p>在不同平台上，完成相同的目的需要调用不同的函数，而结果往往又很难直接使用。</p>
<p><strong>Windows</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> platform</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>platform.win32_ver()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">'10'</span>, <span class="string">'10.0.14393'</span>, <span class="string">''</span>, <span class="string">u'Multiprocessor Free'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>platform.dist()</span><br><span class="line">(<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>platform.uname()</span><br><span class="line">(<span class="string">'Windows'</span>, <span class="string">'Prodesire'</span>, <span class="string">'10'</span>, <span class="string">'10.0.14393'</span>, <span class="string">'AMD64'</span>, <span class="string">'Intel64 Family 6 Model 94 Stepping 3, GenuineIntel'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>platform.platform()</span><br><span class="line"><span class="string">'Windows-10-10.0.14393'</span></span><br></pre></td></tr></table></figure>
<p><strong>Linux(SUSE)</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> platform</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>platform.linux_distribution()</span><br><span class="line">(<span class="string">'SUSE LINUX '</span>, <span class="string">'10.0'</span>, <span class="string">'X86-64'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>platform.dist()</span><br><span class="line">(<span class="string">'SuSE'</span>, <span class="string">'10.0'</span>, <span class="string">'X86-64'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>platform.uname()</span><br><span class="line">(<span class="string">'Linux'</span>, <span class="string">'linux'</span>, <span class="string">'2.6.13-15-default'</span>, <span class="string">'#1 Tue Sep 13 14:56:15 UTC 2005'</span>, <span class="string">'x86_64'</span>, <span class="string">'x86_64'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>platform.platform()</span><br><span class="line"><span class="string">'Linux-2.6.13-15-default-x86_64-with-SuSE-10.0-X86-64'</span></span><br></pre></td></tr></table></figure>
<p><strong>AIX</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> platform</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>platform.linux_distribution()</span><br><span class="line">(<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>platform.dist()</span><br><span class="line">(<span class="string">''</span>, <span class="string">''</span>, <span class="string">''</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>platform.uname()</span><br><span class="line">(<span class="string">'AIX'</span>, <span class="string">'IBM-P520'</span>, <span class="string">'1'</span>, <span class="string">'6'</span>, <span class="string">'00C59DEF4C00'</span>, <span class="string">'powerpc'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>platform.platform()</span><br><span class="line"><span class="string">'AIX-1-00C59DEF4C00-powerpc-64bit'</span></span><br></pre></td></tr></table></figure>
<h2 id="平台扩展库-pf"><a href="#平台扩展库-pf" class="headerlink" title="平台扩展库 pf"></a>平台扩展库 pf</h2><p>针对 platform 的不足，以及我们的需求，可以设计一个基于 platform 的扩展库 pf。其提供 <code>get_platform</code> 函数用来获取平台，并返回 <code>Platform</code> 命名元组，包含系统大类、发行版<br>、版本、CPU 位数和内核版本等信息。以下是部分代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Platform = namedtuple(<span class="string">'Platform'</span>,</span><br><span class="line">                      [<span class="string">'system'</span>, <span class="string">'dist'</span>, <span class="string">'version'</span>, <span class="string">'cpu'</span>, <span class="string">'kernel'</span>])</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_platform</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> _platform</span><br><span class="line">    <span class="keyword">if</span> _platform <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> _platform</span><br><span class="line"></span><br><span class="line">    version = kernel = <span class="string">''</span></span><br><span class="line">    uname = platform.uname()</span><br><span class="line">    system = uname[<span class="number">0</span>]</span><br><span class="line">    arch = rstrip(platform.architecture()[<span class="number">0</span>], <span class="string">'bit'</span>)</span><br><span class="line">    cpu = <span class="number">32</span> <span class="keyword">if</span> arch == <span class="string">'32'</span> <span class="keyword">else</span> <span class="number">64</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> system == <span class="string">'Windows'</span>:</span><br><span class="line">        dist = <span class="string">'Windows'</span></span><br><span class="line">        kernel = uname[<span class="number">3</span>]</span><br><span class="line">        result = re.findall(<span class="string">'(\d+)'</span>, uname[<span class="number">2</span>])</span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            version = result[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> system == <span class="string">'Linux'</span>:</span><br><span class="line">        platform_str = platform.platform().strip().lower()</span><br><span class="line">        result = re.findall(</span><br><span class="line">                <span class="string">'with-(centos|ubuntu|debian|fedora|redhat|oracle)-'</span>, platform_str)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> result:</span><br><span class="line">            dist = LINUX_DIST_MAP[result[<span class="number">0</span>]]</span><br><span class="line">            <span class="comment"># 针对 RedHat 和 CentOS 发行版</span></span><br><span class="line">                        …</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        <span class="comment"># 针对 openSUSE 和 SUSE 发行版</span></span><br><span class="line">                         …</span><br><span class="line">                    version = platform.linux_distribution()[<span class="number">1</span>]</span><br><span class="line">                    kernel = platform_str.split(<span class="string">'-'</span>)[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 针对 Amazon 发行版</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> dist <span class="keyword">and</span> <span class="string">'amzn'</span> <span class="keyword">in</span> platform_str:</span><br><span class="line">                        …</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Platform(system, dist, version, cpu, kernel)</span><br></pre></td></tr></table></figure>
<h2 id="进程、系统管理库-psutil"><a href="#进程、系统管理库-psutil" class="headerlink" title="进程、系统管理库 psutil"></a>进程、系统管理库 psutil</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><a href="https://github.com/giampaolo/psutil" target="_blank" rel="noopener">psutil(process and system utilities)</a> 是一个跨平台的库，用于检索 Python 中运行的进程和系统利用率（CPU，内存，磁盘，网络，传感器）的信息。</p>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ul>
<li>不对老版 Windows(如 2003)进行维护。(3.4.2 及更早版本支持)</li>
<li>不支持 AIX (最新版 5.4.0 支持，但在低版本的 AIX6 上报错)</li>
<li>在 CentOS/RedHat 5.0 上安装报错</li>
<li>获取常用指标(如 IP、硬盘大小、是否为虚拟机等)不够便捷</li>
</ul>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>由于 psutil 是我们所依赖的核心库之一，改善其不足点非常必要，这甚至需要从源码层面来解决。</p>
<p>这就要了解其项目结构：<br><img src="/2019/04/14/Python-跨平台兼容性实践——记-PyCon-China-2017-的一次分享/psutil-structure.png"></p>
<p>让我们以 psutil 在 CentOS 5.0 上安装报错为例来讲解如何进行优化。</p>
<p><strong>报错</strong><br>pip install psutil==5.3.0 报错：</p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">gcc -pthread -fno-strict-aliasing -g -O2 -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC -DPSUTIL_POSIX=1 -DPSUTIL_VERSION=530 -DPSUTIL_LINUX=1 -DPSUTIL_ETHTOOL_MISSING_TYPES=1 -I/home/project/python-linux64/include/python2.7 -c psutil/_psutil_posix.c -o build/temp.linux-x86_64-2.7/psutil/_psutil_posix.o</span><br><span class="line">   In file included from psutil/_psutil_posix.c:27:</span><br><span class="line">   /usr/include/linux/if_packet.h:52: error: expected specifier-qualifier-list before '__u32'</span><br><span class="line">   error: command 'gcc' failed with exit status 1</span><br></pre></td></tr></table></figure>
<p><strong>错误原因</strong><br>报错大概是说 if_packet.h 中 __u32 有问题，但这个文件其实是系统库的头文件，很有可能是系统问题。经过搜索发现，这确实是个系统 Bug，详见 <a href="https://bugzilla.redhat.com/show_bug.cgi?id=233934" target="_blank" rel="noopener">Red Hat Bugzilla – Bug 233934 The patch “xen: Add PACKET_AUXDATA cmsg” cause /usr/include/linux/if_packet.h broken</a>。</p>
<p><strong>系统 Patch</strong><br>有人提交了一个系统 Patch 来修复这个错误，详见 <a href="https://bugzilla.redhat.com/attachment.cgi?id=150888&amp;action=diff" target="_blank" rel="noopener">Red Hat Bugzilla – Attachment #150888: Include linux/types.h for __u32. for bug #233934</a>：<br><img src="/2019/04/14/Python-跨平台兼容性实践——记-PyCon-China-2017-的一次分享/types-patch.png"></p>
<p><strong>为 psutil 打 Patch</strong><br>由于 Agent 是装在客户环境，我们能不修改客户环境就不修改，那么能否改 psutil 的源码吗？还真可以，为此我提交了一份 patch：<a href="https://github.com/giampaolo/psutil/pull/1139/files" target="_blank" rel="noopener">Fix #1138: error on CentOS 5.0: expected specifier-qualifier-list before ‘__u32’</a>。<br><img src="/2019/04/14/Python-跨平台兼容性实践——记-PyCon-China-2017-的一次分享/psutil-patch.png"></p>
<h2 id="进程、系统管理扩展库-sysutil"><a href="#进程、系统管理扩展库-sysutil" class="headerlink" title="进程、系统管理扩展库 sysutil"></a>进程、系统管理扩展库 sysutil</h2><p>前文我们提到 psutil 在获取常用指标上还不够便捷，为此我们需要开发扩展库 sysutil。</p>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>sysutil 是一个跨平台的库，基于 psutil，用于获取 IP、磁盘、是否为虚拟机等信息。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sysutil</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint(sysutil.network_info())</span><br><span class="line">[snetworkinfo(name=<span class="string">'docker0'</span>, mac=<span class="string">'02:42:c5:0f:df:9c'</span>, ipv4=<span class="string">'172.17.0.1'</span>, ipv6=<span class="string">'fe80::42:c5ff:fe0f:df9c'</span>, netmask=<span class="string">'255.255.0.0'</span>),</span><br><span class="line"> snetworkinfo(name=<span class="string">'eno16777984'</span>, mac=<span class="string">'00:50:56:ab:e9:f6'</span>, ipv4=<span class="string">'10.1.100.100'</span>, ipv6=<span class="string">'fe80::250:56ff:feab:e9f6'</span>, netmask=<span class="string">'255.255.255.0'</span>)]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint(sysutil.disk_info())</span><br><span class="line">[sdiskpart(device=<span class="string">'/dev/mapper/centos-root'</span>, mountpoint=<span class="string">'/'</span>, total=<span class="number">53660876800</span>),</span><br><span class="line"> sdiskpart(device=<span class="string">'/dev/mapper/centos-home'</span>, mountpoint=<span class="string">'/home'</span>, total=<span class="number">424532996096</span>),</span><br><span class="line"> sdiskpart(device=<span class="string">'/dev/sda1'</span>, mountpoint=<span class="string">'/boot'</span>, total=<span class="number">520794112</span>)]</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sysutil.cpu_info()</span><br><span class="line">scpuinfo(brand=<span class="string">'Intel(R) Core(TM) i5-6500 CPU @ 3.20GHz'</span>, frequency=<span class="string">'3.2000 GHz'</span>, family=<span class="number">6</span>, vendor_id=<span class="string">'GenuineIntel'</span>, stepping=<span class="number">3</span>, cache_size=<span class="string">'6144 KB'</span>, model=<span class="number">94</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sysutil.is_virtual_machine()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>以 sysutil 中 is_virtual_machine 函数为例，我们讲解下 sysutil 是如何实现判断当前平台是否是虚拟机。</p>
<p>一个功能函数在多个平台上可能有相同的实现，也可能有不同的实现。我们把入口函数放在 <code>__init__.py</code> 中，相同的实现放在 <code>_common.py</code> 中，不同的实现放在 <code>_sys</code> 开头的系统特定实现文件中。</p>
<p>Windows 和 Linux/Unix 截然不同的判断方式，因此在入口函数处判断是否是 Windows 平台，然后调用特定方法。而 Linux/Unix 平台上不同的发型版所执行的判断命令可能不同，因此其系统特定实现文件中仅仅写上不同的命令即可。</p>
<img src="/2019/04/14/Python-跨平台兼容性实践——记-PyCon-China-2017-的一次分享/sysutil-implement.png">
<h2 id="文件管理库-nfs"><a href="#文件管理库-nfs" class="headerlink" title="文件管理库 nfs"></a>文件管理库 nfs</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>nfs 是一个跨平台的自研库，基于 shutil、tarfile、zipfile 等系统库，用于提供更高层次的文件管理功能。</p>
<h3 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">remove(src, filter_files=<span class="keyword">None</span>, filter_dirs=<span class="keyword">None</span>, exclude_files=<span class="keyword">None</span>, exclude_dirs=<span class="keyword">None</span>)</span><br><span class="line">copy(src, dst, filter_files=<span class="keyword">None</span>, filter_dirs=<span class="keyword">None</span>, exclude_files=<span class="keyword">None</span>, exclude_dirs=<span class="keyword">None</span>, symlinks=<span class="keyword">False</span>, mode=<span class="number">0750</span>)</span><br><span class="line">touch(path)</span><br><span class="line">rename()</span><br><span class="line">compress(src, dst=<span class="string">'.'</span>, name=<span class="keyword">None</span>, root=<span class="keyword">None</span>, postfix=<span class="string">'.tar.gz'</span>)</span><br><span class="line">uncompress(src, dst=<span class="string">'.'</span>, temp_dir=<span class="keyword">None</span>, overwrite=<span class="keyword">True</span>, extract_all=<span class="keyword">False</span>)</span><br></pre></td></tr></table></figure>
<h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>以 <code>remove</code> 为例，在删除文件时我们可能并不在意要删除的是文件还是文件夹，以及我们想要忽略一些特定的文件（夹），标准库 shutil 并不能直接满足我们的需求。此外，在 Windows 平台上删除文件时可能会报无法删除的错误，也需要在发生错误时做一定处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(src,</span></span></span><br><span class="line"><span class="function"><span class="params">           filter_files=None,</span></span></span><br><span class="line"><span class="function"><span class="params">           filter_dirs=None,</span></span></span><br><span class="line"><span class="function"><span class="params">           exclude_files=None,</span></span></span><br><span class="line"><span class="function"><span class="params">           exclude_dirs=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> glob.has_magic(src):</span><br><span class="line">        <span class="keyword">for</span> new_src <span class="keyword">in</span> glob.glob(src):</span><br><span class="line">            remove(new_src, filter_files, filter_dirs, exclude_files,</span><br><span class="line">                   exclude_dirs)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isdir(src):</span><br><span class="line">        filepaths = _get_filenames([src], filter_files, exclude_files)</span><br><span class="line">        <span class="keyword">if</span> filepaths:</span><br><span class="line">            _remove_file(filepaths[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> root, dirnames, filenames <span class="keyword">in</span> walk(src, filter_files, filter_dirs,</span><br><span class="line">                                          exclude_files, exclude_dirs):</span><br><span class="line">        <span class="keyword">for</span> filename <span class="keyword">in</span> filenames:</span><br><span class="line">            _remove_file(join(root, filename))</span><br><span class="line">        <span class="keyword">for</span> dirname <span class="keyword">in</span> dirnames:</span><br><span class="line">            path = join(root, dirname)</span><br><span class="line">            shutil.rmtree(path, onerror=onerror)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.listdir(src):</span><br><span class="line">        shutil.rmtree(src, onerror=onerror)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">onerror</span><span class="params">(func, path, exc_info)</span>:</span></span><br><span class="line">    <span class="keyword">import</span> stat</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.access(path, os.W_OK):</span><br><span class="line">        os.chmod(path, stat.S_IWUSR)</span><br><span class="line">        func(path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span></span><br></pre></td></tr></table></figure>
<h2 id="进程守护库-circle"><a href="#进程守护库-circle" class="headerlink" title="进程守护库 circle"></a>进程守护库 circle</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>circle 是一个跨平台的自研库，基于 <a href="https://github.com/circus-tent/circus" target="_blank" rel="noopener">circus</a>，用于提供进程守护功能。</p>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>我们都知道著名的进程守护库 supervisor，很遗憾的是它不支持 Windows。circus 虽然支持 Windows，但是少了支持配置文件夹、Windows 后台启动的功能。于是，我们就需要基于 circus 做一定的改造。<br><img src="/2019/04/14/Python-跨平台兼容性实践——记-PyCon-China-2017-的一次分享/process-daemon-compare.png"></p>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p><strong>配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[watcher:framework]</span><br><span class="line">cmd=$(CIRCLE.ENV.ANT_PYTHON) -m framework</span><br><span class="line">numprocess=1</span><br><span class="line">stop_children=True</span><br><span class="line"></span><br><span class="line">[env:framework]</span><br><span class="line">ANT_MODULE_ROOT=$ANT_ROOT_DIR</span><br></pre></td></tr></table></figure>
<p><strong>运行</strong></p>
<figure class="highlight console"><table><tr><td class="code"><pre><span class="line">Linux/Unix:</span><br><span class="line">./bin/circled -c circled.ini --daemon</span><br><span class="line">Windows:</span><br><span class="line">.\python .\bin\circled -c circled.ini --daemon</span><br></pre></td></tr></table></figure>
<h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>以后台服务为例<br><code>bin/circled</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="string">"exec"</span> <span class="string">"./embedded/bin/python"</span> <span class="string">"./bin/circled"</span> <span class="string">"$@"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line">    <span class="keyword">from</span> os.path <span class="keyword">import</span> dirname, abspath</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Set module path</span></span><br><span class="line">    root_dir = dirname(dirname(abspath(__file__)))</span><br><span class="line">    sys.path.insert(<span class="number">0</span>, root_dir)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Handle CLI</span></span><br><span class="line">    <span class="keyword">from</span> circle.circled <span class="keyword">import</span> handle_cli</span><br><span class="line">    handle_cli()</span><br></pre></td></tr></table></figure>
<p><code>circle/circled.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_cli</span><span class="params">()</span>:</span></span><br><span class="line">    cli_args = parse_args()</span><br><span class="line">    main(cli_args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(args)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'--daemon'</span>]:</span><br><span class="line">        <span class="keyword">if</span> IS_WINDOWS:</span><br><span class="line">            win_daemonize()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            unix_daemonize()</span><br><span class="line">                ...</span><br></pre></td></tr></table></figure>
<p><code>circle/circled.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">win_daemonize</span><span class="params">()</span>:</span></span><br><span class="line">    logger.info(<span class="string">'Starting deamon mode. The AntCircled service will be started.'</span>)</span><br><span class="line">    args = sys.argv[<span class="number">1</span>:]</span><br><span class="line">    <span class="keyword">if</span> <span class="string">'--daemon'</span> <span class="keyword">in</span> args:</span><br><span class="line">        args.remove(<span class="string">'--daemon'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> CircleWinService.exists():</span><br><span class="line">            CircleWinService.install(*args)</span><br><span class="line">            CircleWinService.start(*args)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            CircleWinService.start(*args)</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">except</span> (AlreadyExist, NotExistError, CallError) <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(e)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CircleWinService</span><span class="params">(object)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">install</span><span class="params">(cls, *args)</span>:</span></span><br><span class="line">        logger.info(<span class="string">'Installing ant-agent service'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(CIRCLED_PATH):</span><br><span class="line">            <span class="keyword">raise</span> CallError(<span class="string">'&#123;&#125; not exists.'</span>.format(CIRCLED_PATH))</span><br><span class="line"></span><br><span class="line">        returncode, output = _nssm_run(<span class="string">'install'</span>, cls.name, BIN_START)</span><br><span class="line">        <span class="keyword">if</span> returncode == <span class="number">0</span> <span class="keyword">and</span> <span class="string">'Administrator access'</span> <span class="keyword">in</span> output:</span><br><span class="line">            <span class="keyword">raise</span> CallError(output)</span><br><span class="line">        <span class="keyword">elif</span> returncode == <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">raise</span> AlreadyExist(cls.exist_msg)</span><br><span class="line">        <span class="keyword">elif</span> returncode != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> CallError(output)</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">'ant-agent installed'</span>)</span><br></pre></td></tr></table></figure>
<h1 id="多平台持续集成"><a href="#多平台持续集成" class="headerlink" title="多平台持续集成"></a>多平台持续集成</h1><p>在完成了解释器和库的兼容性后，我们需要考虑如何根据不同的平台构建出来。</p>
<h2 id="配置化构建"><a href="#配置化构建" class="headerlink" title="配置化构建"></a>配置化构建</h2><p>Python 程序的构建其实就是对文件的操作：移动、复制、git clone、压缩等等。在不同平台上这些操作所对应的命令也不尽相同，那么是否可以做到配置化部署呢？一份配置能够在多个平台上被解析运行。这样就大大减少了我们的维护成本了。</p>
<p>配置化构建，就需要考虑配置是命令式的，还是声明式的。</p>
<ul>
<li>命令式——怎样做到应该做的</li>
<li>声明式——应该做到什么</li>
</ul>
<p>其实并不存在一边倒的选择，我们应该考虑其：</p>
<ul>
<li>灵活性</li>
<li>可读性</li>
<li>细节程度</li>
</ul>
<p>我们希望具备足够的灵活性，并能了解到构建的步骤，所以采用了命令式的配置。在一个名为 <code>build.yml</code> 的文件中写成如下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">windows-64:</span><br><span class="line">  steps:</span><br><span class="line">    - makedirs &#123;t&#125;</span><br><span class="line">    - copy &#123;s&#125;/bin &#123;t&#125; exclude .*</span><br><span class="line">    - support_plat &#123;&#123;&apos;Windows&apos;:[64]&#125;&#125; &#123;t&#125;/manifest.yaml</span><br><span class="line">    - add_date &#123;t&#125;/manifest.yaml</span><br><span class="line">    - rename &#123;t&#125;/proc/win_openresty.ini.disable &#123;t&#125;/proc/openresty.ini.disable</span><br><span class="line">    - remove &#123;t&#125;/bin/*.sh</span><br><span class="line">    - pip_install python-windows-64 &#123;t&#125;/requirements/production.txt</span><br><span class="line">    - copy python-windows-64 &#123;t&#125;</span><br><span class="line">    - rename &#123;t&#125;/python-windows-64 &#123;t&#125;/embedded</span><br><span class="line">    - git clone git@git.gitlab.com:ant/openresty.git &#123;s&#125;/openresty</span><br><span class="line">    - copy &#123;s&#125;/openresty/openresty_win32/ &#123;t&#125;/openresty</span><br><span class="line">    - compress &#123;t&#125; &#123;project_name&#125;-windows-64-&#123;project_version&#125;.zip</span><br><span class="line">    - remove &#123;t&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>build.yml</code> 中：</p>
<ul>
<li>最外层的 windows-64 是一个标签，构建命令通过这个标签找到具体的构建步骤。如果整个构建是针对所有平台，这里可以命名为 all。否则，则可以命名为具体的平台。</li>
<li>steps 则是构建步骤，每个步骤开头都是一个命令，这些命令在全平台是通用的。</li>
<li>{}代表构建程序内置变量，比如{t}代表目标路径，{s}代表源路径</li>
</ul>
<h2 id="持续集成流程"><a href="#持续集成流程" class="headerlink" title="持续集成流程"></a>持续集成流程</h2><p>每个环节都搞定后，我们还要把整个流程串起来。以下是大致的流程：</p>
<ul>
<li>开发 push 代码到 GitLab 服务器</li>
<li>GitLab 通过 WebHook 通知 CI 服务器</li>
<li>CI 服务器通知各平台上的 Agent 进行单元测试、构建和部署测试</li>
<li>Agent 在每个任务执行好后将结果通知给 CI 服务器</li>
<li>CI 服务器将消息发送给 Dingding 服务器</li>
<li>开发人员收到消息后进行下一步操作</li>
</ul>
<p>另一个环节是开发人员可能需要虚拟机用来测试，那么就会在我们的 CI 服务器上申请创建虚拟机，CI 服务器通过调用 VSphere 接口进行创建。</p>
<img src="/2019/04/14/Python-跨平台兼容性实践——记-PyCon-China-2017-的一次分享/ci.png">
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>]]></content>
      <categories>
        <category>Python</category>
        <category>跨平台</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>跨平台</tag>
        <tag>兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title>如何加密你的 Python 代码 —— 记 PyCon China 2018 的一次分享</title>
    <url>/2019/01/06/%E5%A6%82%E4%BD%95%E5%8A%A0%E5%AF%86%E4%BD%A0%E7%9A%84-Python-%E4%BB%A3%E7%A0%81-%E2%80%94%E2%80%94-%E8%AE%B0-PyCon-China-2018-%E7%9A%84%E4%B8%80%E6%AC%A1%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>去年11月在PyCon China 2018 杭州站分享了 <a href="http://cn.pycon.org/2018/city_hangzhou.html" target="_blank" rel="noopener">Python 源码加密</a>，讲述了如何通过修改 Python 解释器达到加解密 Python 代码的目的。然而因为笔者拖延症发作，一直没有及时整理成文字版，现在终于战胜了它，才有了本文。</p>
<p>本文将首先介绍下现有源码加密方案的思路、方法、优点与不足，进而介绍如何通过定制 Python 解释器来达到更好地加解密源码的目的。</p>
<h1 id="现有加密方案"><a href="#现有加密方案" class="headerlink" title="现有加密方案"></a>现有加密方案</h1><p>由于 Python 的动态特性和开源特点，导致 Python 代码很难做到很好的加密。社区中的一些声音认为这样的限制是事实，应该通过法律手段而不是加密源码达到商业保护的目的；而还有一些声音则是不论如何都希望能有一种手段来加密。于是乎，人们想出了各种或加密、或混淆的方案，借此来达到保护源码的目的。</p>
<p>常见的源码保护手段有如下几种：</p>
<ul>
<li>发行 <code>.pyc</code> 文件</li>
<li>代码混淆</li>
<li>使用 <code>py2exe</code></li>
<li>使用 <code>Cython</code></li>
</ul>
<p>下面来简单说说这些方案。</p>
<a id="more"></a>
<h2 id="发行-pyc-文件"><a href="#发行-pyc-文件" class="headerlink" title="发行 .pyc 文件"></a>发行 .pyc 文件</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>大家都知道，Python 解释器在执行代码的过程中会首先生成 <code>.pyc</code> 文件，然后解释执行 <code>.pyc</code> 文件中的内容。当然了，Python 解释器也能够直接执行 <code>.pyc</code> 文件。而 <code>.pyc</code> 文件是二进制文件，无法直接看出源码内容。如果发行代码到客户环境时都是 <code>.pyc</code> 而非 <code>.py</code> 文件的话，那岂不是能达到保护 Python 代码的目的？</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>把 <code>.py</code> 文件编译为 <code>.pyc</code> 文件，是件非常轻松地事情，可不需要把所有代码跑一遍，然后去捞生成的 <code>.pyc</code> 文件。</p>
<p>事实上，Python 标准库中提供了一个名为 <a href="https://docs.python.org/2/library/compileall.html" target="_blank" rel="noopener">compileall</a> 的库，可以轻松地进行编译。</p>
<p>执行如下命令能够将遍历 <code>&lt;src&gt;</code> 目录下的所有 <code>.py</code> 文件，将之编译为 <code>.pyc</code> 文件：</p>
<p>python -m compileall <code>&lt;src&gt;</code><br>然后删除 <code>&lt;src&gt;</code> 目录下所有 <code>.py</code> 文件就可以打包发布了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ find &lt;src&gt; -name <span class="string">'*.py'</span> -<span class="built_in">type</span> f -<span class="built_in">print</span> -<span class="built_in">exec</span> rm &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li>简单方便，提高了一点源码破解门槛</li>
<li>平台兼容性好，<code>.py</code> 能在哪里运行，<code>.pyc</code> 就能在哪里运行</li>
</ul>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ul>
<li>解释器兼容性差，<code>.pyc</code> 只能在特定版本的解释器上运行</li>
<li>有现成的反编译工具，破解成本低</li>
</ul>
<p><a href="https://github.com/rocky/python-uncompyle6" target="_blank" rel="noopener">python-uncompyle6</a> 就是这样一款反编译工具，效果出众。</p>
<p>执行如下命令，即可将 <code>.pyc</code> 文件反编译为 <code>.py</code> 文件：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ uncompyle6 *compiled-python-file-pyc-or-pyo*</span><br></pre></td></tr></table></figure></p>
<h2 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h2><p>如果代码被混淆到一定程度，连作者看着都费劲的话，是不是也能达到保护源码的目的呢？</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>既然我们的目的是混淆，就是通过一系列的转换，让代码逐渐不那么让人容易明白，那就可以这样下手：</p>
<ul>
<li>移除注释和文档。没有这些说明，在一些关键逻辑上就没那么容易明白了。</li>
<li>改变缩进。完美的缩进看着才舒服，如果缩进忽长忽短，看着也一定闹心。</li>
<li>在tokens中间加入一定空格。这就和改变缩进的效果差不多。</li>
<li>重命名函数、类、变量。命名直接影响了可读性，乱七八糟的名字可是阅读理解的一大障碍。</li>
<li>在空白行插入无效代码。这就是障眼法，用无关代码来打乱阅读节奏。</li>
</ul>
<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><h4 id="方法一：使用-oxyry-进行混淆"><a href="#方法一：使用-oxyry-进行混淆" class="headerlink" title="方法一：使用 oxyry 进行混淆"></a>方法一：使用 oxyry 进行混淆</h4><p><a href="http://pyob.oxyry.com/" target="_blank" rel="noopener">http://pyob.oxyry.com/</a> 是一个在线混淆 Python 代码的网站，使用它可以方便地进行混淆。</p>
<p>假定我们有这样一段 Python 代码，涉及到了类、函数、参数等内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Description</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y, default=None)</span>:</span></span><br><span class="line">        self.z = x + y</span><br><span class="line">        self.default = default</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'No Name'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">always</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line">a = A(num, <span class="number">999</span>, <span class="number">100</span>)</span><br><span class="line">a.name()</span><br><span class="line">always()</span><br></pre></td></tr></table></figure>
<p>经过 <code>Oxyry</code> 的混淆，得到如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="params">(object )</span>:</span><span class="comment">#line:4</span></span><br><span class="line">    <span class="string">""</span><span class="comment">#line:7</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> <span class="params">(O0O0O0OO00OO000O0 ,OO0O0OOOO0000O0OO ,OO0OO00O00OO00OOO ,OO000OOO0O000OOO0 =None )</span>:</span><span class="comment">#line:9</span></span><br><span class="line">        O0O0O0OO00OO000O0 .z =OO0O0OOOO0000O0OO +OO0OO00O00OO00OOO <span class="comment">#line:10</span></span><br><span class="line">        O0O0O0OO00OO000O0 .default =OO000OOO0O000OOO0 <span class="comment">#line:11</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span> <span class="params">(O000O0O0O00O0O0OO )</span>:</span><span class="comment">#line:13</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'No Name'</span><span class="comment">#line:14</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">always</span> <span class="params">()</span>:</span><span class="comment">#line:17</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span> <span class="comment">#line:18</span></span><br><span class="line">num =<span class="number">1</span> <span class="comment">#line:21</span></span><br><span class="line">a =A (num ,<span class="number">999</span> ,<span class="number">100</span> )<span class="comment">#line:22</span></span><br><span class="line">a .name ()<span class="comment">#line:23</span></span><br><span class="line">always ()</span><br></pre></td></tr></table></figure>
<p>混淆后的代码主要在注释、参数名称和空格上做了些调整，稍微带来了点阅读上的障碍。</p>
<h4 id="方法二：使用-pyobfuscate-库进行混淆"><a href="#方法二：使用-pyobfuscate-库进行混淆" class="headerlink" title="方法二：使用 pyobfuscate 库进行混淆"></a>方法二：使用 pyobfuscate 库进行混淆</h4><p><a href="https://github.com/astrand/pyobfuscate" target="_blank" rel="noopener">pyobfuscate</a> 算是一个颇具年头的 Python 代码混淆库了，但却是“老当益壮”了。</p>
<p>对上述同样一段 Python 代码，经 <code>pyobfuscate</code> 混淆后效果如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">if</span> <span class="number">64</span> - <span class="number">64</span>: i11iIiiIii</span><br><span class="line"><span class="keyword">if</span> <span class="number">65</span> - <span class="number">65</span>: O0 / iIii1I11I1II1 % OoooooooOO - i1IIi</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">o0OO00</span> <span class="params">( object )</span> :</span></span><br><span class="line"> <span class="keyword">if</span> <span class="number">78</span> - <span class="number">78</span>: i11i . oOooOoO0Oo0O</span><br><span class="line"> <span class="keyword">if</span> <span class="number">10</span> - <span class="number">10</span>: IIiI1I11i11</span><br><span class="line"> <span class="keyword">if</span> <span class="number">54</span> - <span class="number">54</span>: i11iIi1 - oOo0O0Ooo</span><br><span class="line"> <span class="keyword">if</span> <span class="number">2</span> - <span class="number">2</span>: o0 * i1 * ii1IiI1i % OOooOOo / I11i / Ii1I</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> <span class="params">( self , x , y , default = None )</span> :</span></span><br><span class="line">  self . z = x + y</span><br><span class="line">  self . default = default</span><br><span class="line">  <span class="keyword">if</span> <span class="number">48</span> - <span class="number">48</span>: iII111i % IiII + I1Ii111 / ooOoO0o * Ii1I</span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">name</span> <span class="params">( self )</span> :</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">'No Name'</span></span><br><span class="line">  <span class="keyword">if</span> <span class="number">46</span> - <span class="number">46</span>: ooOoO0o * I11i - OoooooooOO</span><br><span class="line">  <span class="keyword">if</span> <span class="number">30</span> - <span class="number">30</span>: o0 - O0 % o0 - OoooooooOO * O0 * OoooooooOO</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Oo0o</span> <span class="params">( )</span> :</span></span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"> <span class="keyword">if</span> <span class="number">60</span> - <span class="number">60</span>: i1 + I1Ii111 - I11i / i1IIi</span><br><span class="line"> <span class="keyword">if</span> <span class="number">40</span> - <span class="number">40</span>: oOooOoO0Oo0O / O0 % ooOoO0o + O0 * i1IIi</span><br><span class="line">I1Ii11I1Ii1i = <span class="number">1</span></span><br><span class="line">Ooo = o0OO00 ( I1Ii11I1Ii1i , <span class="number">999</span> , <span class="number">100</span> )</span><br><span class="line">Ooo . name ( )</span><br><span class="line">Oo0o ( ) <span class="comment"># dd678faae9ac167bc83abf78e5cb2f3f0688d3a3</span></span><br></pre></td></tr></table></figure></p>
<p>相比于方法一，方法二的效果看起来更好些。除了类和函数进行了重命名、加入了一些空格，最明显的是插入了若干段无关的代码，变得更加难读了。</p>
<h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul>
<li>简单方便，提高了一点源码破解门槛</li>
<li>兼容性好，只要源码逻辑能做到兼容，混淆代码亦能</li>
</ul>
<h3 id="不足-1"><a href="#不足-1" class="headerlink" title="不足"></a>不足</h3><ul>
<li>只能对单个文件混淆，无法做到多个互相有联系的源码文件的联动混淆</li>
<li>代码结构未发生变化，也能获取字节码，破解难度不大</li>
</ul>
<h2 id="使用-py2exe"><a href="#使用-py2exe" class="headerlink" title="使用 py2exe"></a>使用 py2exe</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p><a href="http://py2exe.org/" target="_blank" rel="noopener">py2exe</a> 是一款将 Python 脚本转换为 Windows 平台上的可执行文件的工具。其原理是将源码编译为 <code>.pyc</code> 文件，加之必要的依赖文件，一起打包成一个可执行文件。</p>
<p>如果最终发行由 <code>py2exe</code> 打包出的二进制文件，那岂不是达到了保护源码的目的？</p>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><p>使用 <code>py2exe</code> 进行打包的步骤较为简便。</p>
<ol>
<li><p>编写入口文件。本示例中取名为 <code>hello.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> <span class="string">'Hello World'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编写 <code>setup.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">import</span> py2exe</span><br><span class="line"></span><br><span class="line">setup(console=[<span class="string">'hello.py'</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成可执行文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python setup.py py2exe</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>生成的可执行文件位于 <code>dist\hello.exe</code>。</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul>
<li>能够直接打包成 exe，方便分发和执行</li>
<li>破解门槛比 .pyc 更高一些</li>
</ul>
<h3 id="不足-2"><a href="#不足-2" class="headerlink" title="不足"></a>不足</h3><ul>
<li>兼容性差，只能运行在 Windows 系统上</li>
<li>生成的可执行文件内的布局是明确、公开的，可以找到源码对应的 <code>.pyc</code> 文件，进而反编译出源码</li>
</ul>
<h2 id="使用-Cython"><a href="#使用-Cython" class="headerlink" title="使用 Cython"></a>使用 Cython</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>虽说 <code>Cython</code> 的主要目的是带来性能的提升，但是基于它的原理：将 <code>.py</code>/<code>.pyx</code> 编译为 <code>.c</code> 文件，再将 <code>.c</code> 文件编译为 <code>.so</code>(Unix) 或 <code>.pyd</code>(Windows)，其带来的另一个好处就是难以破解。</p>
<h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h3><p>使用 <code>Cython</code> 进行开发的步骤也不复杂。</p>
<ol>
<li><p>编写文件 <code>hello.pyx</code> 或 <code>hello.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写 <code>setup.py</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">setup(name=<span class="string">'Hello World app'</span>,</span><br><span class="line">     ext_modules=cythonize(<span class="string">'hello.pyx'</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译为 <code>.c</code>，再进一步编译为 <code>.so</code> 或 <code>.pyd</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python setup.py build_ext --inplace</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>执行 <code>python -c &quot;from hello import hello;hello()&quot;</code> 即可直接引用生成的二进制文件中的 <code>hello()</code> 函数。</p>
<h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul>
<li>生成的二进制 .so 或 .pyd 文件难以破解</li>
<li>同时带来了性能提升</li>
</ul>
<h3 id="不足-3"><a href="#不足-3" class="headerlink" title="不足"></a>不足</h3><ul>
<li>兼容性稍差，对于不同版本的操作系统，可能需要重新编译</li>
<li>虽然支持大多数 Python 代码，但如果一旦发现部分代码不支持，完善成本较高</li>
</ul>
<h1 id="定制-Python-解释器"><a href="#定制-Python-解释器" class="headerlink" title="定制 Python 解释器"></a>定制 Python 解释器</h1><p>考虑前文所述的几个方案，均是从源码的加工入手，或多或少都有些不足。假设我们从解释器的改造入手，会不会能够更好的保护代码呢？</p>
<p>由于发行商业 Python 程序到客户环境时通常会包含一个 Python 解释器，如果改造解释器能解决源码保护的问题，那么也是可选的一条路。</p>
<p>假定我们有一个算法，能够加密原始的 Python 代码，这些加密后代码随发行程序一起，可被任何人看到，却难以破解。另一方面，有一个定制好的 Python 解释器，它能够解密这些被加密的代码，然后解释执行。而由于 Python 解释器本身是二进制文件，人们也就无法从解释器中获取解密的关键数据。从而达到了保护源码的目的。</p>
<p>要实现上述的设想，我们首先需要掌握基本的加解密算法，其次探究 Python 执行代码的方式从而了解在何处进行加解密，最后禁用字节码用以防止通过 <code>.pyc</code> 反编译。</p>
<h2 id="加解密算法"><a href="#加解密算法" class="headerlink" title="加解密算法"></a>加解密算法</h2><h3 id="对称密钥加密算法"><a href="#对称密钥加密算法" class="headerlink" title="对称密钥加密算法"></a>对称密钥加密算法</h3><p>对称密钥加密（Symmetric-key algorithm）又称为对称加密、私钥加密、共享密钥加密，是密码学中的一类加密算法。这类算法在加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。</p>
<p>对称加密算法的特点是算法公开、计算量小、加密速度快、加密效率高。</p>
<p>常见的对称加密算法有：DES、3DES、AES、Blowfish、IDEA、RC5、RC6 等。</p>
<p>对称密钥加解密过程如下：</p>
<img src="/2019/01/06/如何加密你的-Python-代码-——-记-PyCon-China-2018-的一次分享/symmetric-cryptography.png">
<p>明文通过密钥加密成密文，密文也可通过相同的密钥解密为明文。</p>
<p>通过 openssl 工具，我们能够方便选择对称加密算法进行加解密。下面我们以 AES 算法为例，介绍其用法。</p>
<p><strong>AES 加密</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定密码进行对称加密</span></span><br><span class="line">$ openssl enc -aes-128-cbc -<span class="keyword">in</span> test.py -out entest.py -pass pass:123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定文件进行对称加密</span></span><br><span class="line">$ openssl enc -aes-128-cbc -<span class="keyword">in</span> test.py -out entest.py -pass file:passwd.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定环境变量进行对称加密</span></span><br><span class="line">$ openssl enc -aes-128-cbc -<span class="keyword">in</span> test.py -out entest.py -pass env:passwd</span><br></pre></td></tr></table></figure></p>
<p><strong>AES 解密</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定密码进行对称解密</span></span><br><span class="line">$ openssl enc -aes-128-cbc -d -<span class="keyword">in</span> entest.py -out test.py -pass pass:123456</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定文件进行对称解密</span></span><br><span class="line">$ openssl enc -aes-128-cbc -d -<span class="keyword">in</span> entest.py -out test.py -pass file:passwd.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定环境变量进行对称解密</span></span><br><span class="line">$ openssl enc -aes-128-cbc -d -<span class="keyword">in</span> entest.py -out test.py -pass env:passwd</span><br></pre></td></tr></table></figure></p>
<h3 id="非对称密钥加密算法"><a href="#非对称密钥加密算法" class="headerlink" title="非对称密钥加密算法"></a>非对称密钥加密算法</h3><p>密钥加密（英语：public-key cryptography，又译为公开密钥加密），也称为非对称加密（asymmetric cryptography），一种密码学算法类型，在这种密码学方法中，需要一对密钥，一个是私钥，另一个则是公钥。这两个密钥是数学相关，用某用户公钥加密后所得的信息，只能用该用户的私钥才能解密。</p>
<p>非对称加密算法的特点是算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。</p>
<p>常见的对称加密算法有：RSA、Elgamal、背包算法、Rabin、D-H、ECC 等。</p>
<p>非对称密钥加解密过程如下：</p>
<img src="/2019/01/06/如何加密你的-Python-代码-——-记-PyCon-China-2018-的一次分享/asymmetric-cryptography.png">
<p>明文通过公钥加密成密文，密文通过与公钥对应的私钥解密为明文。</p>
<p>通过 openssl 工具，我们能够方便选择非对称加密算法进行加解密。下面我们以 RSA 算法为例，介绍其用法。</p>
<p><strong>生成私钥、公钥</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 辅以 AES-128 算法，生成 2048 比特长度的私钥</span></span><br><span class="line">$ openssl genrsa -aes128 -out private.pem 2048</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据私钥来生成公钥</span></span><br><span class="line">$ openssl rsa -<span class="keyword">in</span> private.pem -outform PEM -pubout -out public.pem</span><br></pre></td></tr></table></figure></p>
<p><strong>RSA 加密</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用公钥进行加密</span></span><br><span class="line">openssl rsautl -encrypt -<span class="keyword">in</span> passwd.txt -inkey public.pem -pubin -out enpasswd.txt</span><br></pre></td></tr></table></figure></p>
<p><strong>RSA 解密</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用私钥进行解密</span></span><br><span class="line">openssl rsautl -decrypt -<span class="keyword">in</span> enpasswd.txt -inkey private.pem -out passwd.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="基于加密算法实现源码保护"><a href="#基于加密算法实现源码保护" class="headerlink" title="基于加密算法实现源码保护"></a>基于加密算法实现源码保护</h2><p>对称加密适合加密源码文件，而非对称加密适合加密密钥。如果将两者结合，就能达到加解密源码的目的。</p>
<h3 id="在构建环境进行加密"><a href="#在构建环境进行加密" class="headerlink" title="在构建环境进行加密"></a>在构建环境进行加密</h3><p>我们发行出去安装包中，源码应该是被加密过的，那么就需要在构建阶段对源码进行加密。加密的过程如下：</p>
<img src="/2019/01/06/如何加密你的-Python-代码-——-记-PyCon-China-2018-的一次分享/encrypt-process.png">
<ol>
<li>随机生成一个密钥。这个密钥实际上是一个用于对称加密的密码。</li>
<li>使用该密钥对源代码进行对称加密，生成加密后的代码。</li>
<li>使用公钥（生成方法见 非对称密钥加密算法）对该密钥进行非对称加密，生成加密后的密钥。</li>
</ol>
<p>不论是加密后的代码还是加密后的密钥，都会放在安装包中。它们能够被用户看到，却无法被破译。而 Python 解释器该如何执行加密后的代码呢？</p>
<h3 id="Python-解释器进行解密"><a href="#Python-解释器进行解密" class="headerlink" title="Python 解释器进行解密"></a>Python 解释器进行解密</h3><p>假定我们发行的 Python 解释器中内置了与公钥相对应的私钥，有了它就有了解密的可能。而由于 Python 解释器本身是二进制文件，所以不需要担心内置的私钥会被看到。解密的过程如下：</p>
<img src="/2019/01/06/如何加密你的-Python-代码-——-记-PyCon-China-2018-的一次分享/decrypt-process.png">
<ol>
<li>Python 解释器执行加密代码时需要被传入指示加密密钥的参数，通过这个参数，解释器获取到了加密密钥</li>
<li>Python 解释器使用内置的私钥，对该加密密钥进行非对称解密，得到原始密钥</li>
<li>Python 解释器使用原始密钥对加密代码进行对称解密，得到原始代码</li>
<li>Python 解释器执行这段原始代码</li>
</ol>
<p>可以看到，通过改造构建环节、定制 Python 解释器的执行过程，便可以实现保护源码的目的。改造构建环节是容易的，但是如何定制 Python 解释器呢？我们需要深入了解解释器执行脚本和模块的方式，才能在特定的入口进行控制。</p>
<h2 id="脚本、模块的执行与解密"><a href="#脚本、模块的执行与解密" class="headerlink" title="脚本、模块的执行与解密"></a>脚本、模块的执行与解密</h2><h3 id="执行-Python-代码的几种方式"><a href="#执行-Python-代码的几种方式" class="headerlink" title="执行 Python 代码的几种方式"></a>执行 Python 代码的几种方式</h3><p>为了找到 Python 解释器执行 Python 代码时的所有入口，我们需要首先执行 Python 解释器都能以怎样的方式执行代码。</p>
<p><strong>直接运行脚本</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python test.py</span><br></pre></td></tr></table></figure></p>
<p><strong>直接运行语句</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">"print 'hello'"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>直接运行模块</strong><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<p><strong>导入、重载模块</strong><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> test  <span class="comment"># 导入模块</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reload(test)  <span class="comment"># 重载模块</span></span><br></pre></td></tr></table></figure></p>
<p><strong>直接运行语句</strong> 的方式接收的就是明文的代码，我们也无需对这种方式做额外处理。<br><strong>直接运行模块</strong>和<strong>导入、重载模块</strong>这两种方式在流程上是殊途同归的，所以接下来会一起来看。<br>因此我们将分两种情况：运行脚本和加载模块来进一步探究各自的过程和解密方式。</p>
<h3 id="运行脚本时解密"><a href="#运行脚本时解密" class="headerlink" title="运行脚本时解密"></a>运行脚本时解密</h3><p><strong>运行脚本的过程</strong><br>Python 解释器在运行脚本时的代码调用逻辑如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">       main            WinMain</span><br><span class="line">[Modules/python.c] [PC/WinMain.c]</span><br><span class="line">             \         /</span><br><span class="line">              \       /</span><br><span class="line">               \     /</span><br><span class="line">                \   /</span><br><span class="line">                 \ /</span><br><span class="line">               Py_Main</span><br><span class="line">           [Moduls/main.c]</span><br></pre></td></tr></table></figure></p>
<p>Python 解释器运行脚本的入口函数因操作系统而异，在 Linux/Unix 系统上，主入口函数是 <code>Modules/python.c</code> 中的 <code>main</code> 函数，在 Windows系统上，则是 <code>PC/WinMain.c</code> 中的 <code>WinMain</code> 函数。不过这两个函数最终都会调用 <code>Moduls/main.c</code> 中的 <code>Py_Main</code> 函数。</p>
<p>我们不妨来看看 <code>Py_Main</code> 函数中的相关逻辑：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[Modules/Main.c]</span><br><span class="line">--------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">Py_Main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (command) &#123;</span><br><span class="line">        <span class="comment">// 处理 python -c &lt;command&gt;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">module</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理 python -m &lt;module&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 处理 python &lt;file&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        fp = fopen(filename, <span class="string">"r"</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>处理<code>&lt;command&gt;</code>和<code>&lt;module&gt;</code>的部分我们暂且先不管，在处理文件（通过直接运行脚本的方式）的逻辑中，可以看到解释打开了文件，获得了文件指针。那么如果我们把这里的 <code>fopen</code> 换成是自定义的 <code>decrypt_open</code> 函数，这个函数用来打开一个加密文件，然后进行解密，并返回一个文件指针，这个指针指向解密后的文件。那么，不就可以实现解密脚本的目的了吗？</p>
<p><strong>自定义 decrypt_open</strong><br>我们不妨新增一个 <code>Modules/crypt.c</code> 文件，用来存放一些自定义的加解密函数。</p>
<p><code>decrypt_open</code> 函数大概实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[Modules/crypt.c]</span><br><span class="line">--------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 以解密方式打开文件 */</span></span><br><span class="line">FILE *</span><br><span class="line">decrypt_open(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> plainlen = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> *plaintext = <span class="literal">NULL</span>;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aes_passwd == <span class="literal">NULL</span>)</span><br><span class="line">        fp = fopen(filename, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        plainlen = aes_decrypt(filename, aes_passwd, &amp;plaintext);</span><br><span class="line">        <span class="comment">// 如果无法解密，返回源文件描述符</span></span><br><span class="line">        <span class="keyword">if</span> (plainlen &lt; <span class="number">0</span>)</span><br><span class="line">            fp = fopen(filename, <span class="string">"r"</span>);</span><br><span class="line">        <span class="comment">// 否则，转换为内存文件描述符</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fp = fmemopen(plaintext, plainlen, <span class="string">"r"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的 <code>aes_passwd</code> 是一个全局变量，代表对称加密算法中的密钥。我们暂时假定已经获取该密钥了，后文会说明如何获得。而 <code>aes_decrypt</code> 是自定义的一个使用AES算法进行对称解密的函数，限于篇幅，此函数的实现不再贴出。</p>
<p><code>decrypt_open</code> 逻辑如下：</p>
<ul>
<li>判断是否获得了对称密钥，如果没获得，直接打开该文件并返回文件指针</li>
<li>如果获得了，则尝试使用对称算法进行解密<ul>
<li>如果解密失败，可能就是一段非加密的脚本，直接打开该文件并返回文件指针</li>
<li>如果解密成功，我们通过解密后的内容创建一个内存文件对象，并返回该文件指针</li>
</ul>
</li>
</ul>
<p>实现了上述这些函数后，我们就能够实现在直接运行脚本时，解密执行被加密代码的目的。</p>
<h3 id="加载模块时解密"><a href="#加载模块时解密" class="headerlink" title="加载模块时解密"></a>加载模块时解密</h3><p><strong>加载模块的过程</strong><br>加载模块的逻辑主要实现在 <code>Python/import.c</code> 文件中，其过程如下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">                                             Py_Main</span><br><span class="line">                                         [Moduls/main.c]</span><br><span class="line">                                                |</span><br><span class="line">    builtin___import__                      RunModule</span><br><span class="line">            |                                   |</span><br><span class="line">PyImport_ImportModuleLevel &lt;----┐     PyImport_ImportModule</span><br><span class="line">            |                   |               |</span><br><span class="line">    import_module_level         └------- PyImport_Import</span><br><span class="line">            |</span><br><span class="line">         load_next                         builtin_reload</span><br><span class="line">            |                                   |</span><br><span class="line">      import_submodule                PyImport_ReloadModule</span><br><span class="line">            |                                   |</span><br><span class="line">        find_module &lt;---------------------------┘</span><br></pre></td></tr></table></figure></p>
<ul>
<li>通过 <code>python -m &lt;module&gt;</code> 的方式来加载模块时，其入口函数是 <code>Py_Main</code> 函数</li>
<li>通过 <code>import &lt;module&gt;</code> 的方式来加载模块时，其入口函数是 <code>builtin___import__</code> 函数</li>
<li>通过 <code>reload(&lt;module&gt;)</code> 的方式来加载模块时，其入口函数是 <code>builtin_reload</code> 函数</li>
</ul>
<p>但不论是哪种方式，最终都会调用 <code>find_module</code> 函数，我们看看这个函数中是否暗藏乾坤呢？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[Python/<span class="keyword">import</span>.c]</span><br><span class="line">--------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">filedescr</span> *</span></span><br><span class="line"><span class="class"><span class="title">find_module</span>(<span class="title">char</span> *<span class="title">fullname</span>, <span class="title">char</span> *<span class="title">subname</span>, <span class="title">PyObject</span> *<span class="title">path</span>, <span class="title">char</span> *<span class="title">buf</span>,</span></span><br><span class="line"><span class="class">            <span class="title">size_t</span> <span class="title">buflen</span>, <span class="title">FILE</span> **<span class="title">p_fp</span>, <span class="title">PyObject</span> **<span class="title">p_loader</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    fp = fopen(buf, filemode);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 <code>find_module</code> 函数中找到了打开文件的逻辑，如果直接改成前文实现的 <code>decrypt_open</code>，岂不是就能达成加载模块时解密的目的了？</p>
<p>总体思路是这样的，但有个细节需要注意，<code>buf</code> 不一定就是 <code>.py</code> 文件，也可能是 <code>.pyc</code> 文件，我们只对 <code>.py</code> 文件做改动，则可以这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[Python/<span class="keyword">import</span>.c]</span><br><span class="line">--------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">filedescr</span> *</span></span><br><span class="line"><span class="class"><span class="title">find_module</span>(<span class="title">char</span> *<span class="title">fullname</span>, <span class="title">char</span> *<span class="title">subname</span>, <span class="title">PyObject</span> *<span class="title">path</span>, <span class="title">char</span> *<span class="title">buf</span>,</span></span><br><span class="line"><span class="class">            <span class="title">size_t</span> <span class="title">buflen</span>, <span class="title">FILE</span> **<span class="title">p_fp</span>, <span class="title">PyObject</span> **<span class="title">p_loader</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (fdp-&gt;type == PY_SOURCE) &#123;</span><br><span class="line">        fp = decrypt_open(buf, filemode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        fp = fopen(buf, filemode);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过上述改动，就实现了加载模块时解密的目的了。</p>
<h3 id="支持指定密钥文件"><a href="#支持指定密钥文件" class="headerlink" title="支持指定密钥文件"></a>支持指定密钥文件</h3><p>前文中还留有一个待解决的问题：我们一开始是假定解释器已获取到了密钥内容并存放在了全局变量 <code>aes_passwd</code> 中，那么密钥内容怎么获取呢？</p>
<p>我们需要 Python 解释器能支持一个新的参数选项，通过它来指定已加密的密钥文件，然后再通过非对称算法进行解密，得到 <code>aes_passed</code>。</p>
<p>假定这个参数选项是 <code>-k &lt;filename&gt;</code>，则可使用如 <code>python -k enpasswd.txt</code> 的方式来告知解释器加密密钥的文件路径。其实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[Modules/main.c]</span><br><span class="line">--------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 命令行选项，注意k:是新增的内容 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE_OPTS <span class="meta-string">"3bBc:dEhiJk:m:OQ:RsStuUvVW:xX?"</span></span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* Long usage message, split into parts &lt; 512 bytes */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *usage_1 = <span class="string">"\</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">-k key : decrypt source file by using key file\n\</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">"</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">Py_Main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">char</span> *keyfilename = <span class="literal">NULL</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">while</span> ((c = _PyOS_GetOpt(argc, argv, PROGRAM_OPTS)) != EOF) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'k'</span>:</span><br><span class="line">            keyfilename = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(_PyOS_optarg) + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (keyfilename == <span class="literal">NULL</span>)</span><br><span class="line">                Py_FatalError(</span><br><span class="line">                   <span class="string">"not enough memory to copy -k argument"</span>);</span><br><span class="line">            <span class="built_in">strcpy</span>(keyfilename, _PyOS_optarg);</span><br><span class="line">            keyfilename[<span class="built_in">strlen</span>(_PyOS_optarg)] = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (keyfilename != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> passwdlen;</span><br><span class="line">        <span class="keyword">char</span> *passwd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        passwdlen = rsa_decrypt(keyfilename, &amp;passwd);</span><br><span class="line">        set_aes_passwd(passwd);</span><br><span class="line">        <span class="keyword">if</span> (passwdlen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s: parsing key file '%s' error\n"</span>, argv[<span class="number">0</span>], keyfilename);</span><br><span class="line">            <span class="built_in">free</span>(keyfilename);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">free</span>(keyfilename);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其逻辑如下：</p>
<ul>
<li><code>k:</code>中的 <code>k</code> 表示支持 <code>-k</code> 选项；<code>:</code> 表示选项后跟一个参数，即这里的已加密密钥文件的路径</li>
<li>解释器在处理到 <code>-k</code> 参数时，获取其后所跟的文件路径，记录在 <code>keyfilename</code> 中</li>
<li>使用自定义的 <code>rsa_decrypt</code> 函数（限于篇幅，不列出如何实现的逻辑）对已加密密钥文件进行非对称解密，获得密钥的原始内容</li>
<li>将该密钥内容写入到 <code>aes_passwd</code> 中</li>
</ul>
<p>由此，通过显示地指定已加密密钥文件，解释器获得了原始密钥，进而通过该密钥解密已加密代码，再执行原始代码。但是，这里面还潜藏着一个<strong>风险</strong>：执行代码的过程中会生成 <code>.pyc</code> 文件，通过它反编译出的 <code>.py</code> 文件是未加密的。换句话说，恶意用户可以通过这种手段绕过限制。所以，我们需要 <strong>禁用字节码</strong></p>
<h2 id="禁用字节码"><a href="#禁用字节码" class="headerlink" title="禁用字节码"></a>禁用字节码</h2><h3 id="不生成-pyc-文件"><a href="#不生成-pyc-文件" class="headerlink" title="不生成 .pyc 文件"></a>不生成 .pyc 文件</h3><p>首先要做的就是不生成 <code>.pyc</code> 文件，这样，恶意用户就没法直接根据 <code>.pyc</code> 文件来得到源码。</p>
<p>我们知道，通过 <code>-B</code> 选项可以告知 Python 解释器不生成 <code>.pyc</code> 文件。既然定制的 Python 解释器就不生成 <code>.pyc</code> 我们干脆禁用这个选项：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[Modules/main.c]</span><br><span class="line">--------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 命令行选项，注意移除了B */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BASE_OPTS <span class="meta-string">"3bc:dEhiJm:OQ:RsStuUvVW:xX?"</span></span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* Long usage message, split into parts &lt; 512 bytes */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *usage_1 = <span class="string">"\</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">//-B     : don't write .py[co] files on import; also PYTHONDONTWRITEBYTECODE=x\n\</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">"</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">Py_Main(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 不生成 py[co]</span></span><br><span class="line">    Py_DontWriteBytecodeFlag++;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除此以外，Python 解释器还会从环境变量中获取是否不生成 <code>.pyc</code> 文件，因此也需要做处理：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[Python/pythonrun.c]</span><br><span class="line">--------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">Py_InitializeEx(<span class="keyword">int</span> install_sigs)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    f ((p = Py_GETENV(<span class="string">"PYTHONDEBUG"</span>)) &amp;&amp; *p != <span class="string">'\0'</span>)</span><br><span class="line">        Py_DebugFlag = add_flag(Py_DebugFlag, p);</span><br><span class="line">    <span class="keyword">if</span> ((p = Py_GETENV(<span class="string">"PYTHONVERBOSE"</span>)) &amp;&amp; *p != <span class="string">'\0'</span>)</span><br><span class="line">        Py_VerboseFlag = add_flag(Py_VerboseFlag, p);</span><br><span class="line">    <span class="keyword">if</span> ((p = Py_GETENV(<span class="string">"PYTHONOPTIMIZE"</span>)) &amp;&amp; *p != <span class="string">'\0'</span>)</span><br><span class="line">        Py_OptimizeFlag = add_flag(Py_OptimizeFlag, p);</span><br><span class="line">    <span class="comment">// 移除对 PYTHONDONTWRITEBYTECODE 的处理</span></span><br><span class="line">    <span class="keyword">if</span> ((p = Py_GETENV(<span class="string">"PYTHONDONTWRITEBYTECODE"</span>)) &amp;&amp; *p != <span class="string">'\0'</span>)</span><br><span class="line">        Py_DontWriteBytecodeFlag = add_flag(Py_DontWriteBytecodeFlag, p);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="禁止访问字节码对象-co-code"><a href="#禁止访问字节码对象-co-code" class="headerlink" title="禁止访问字节码对象 co_code"></a>禁止访问字节码对象 co_code</h3><p>仅仅是不生成 <code>.pyc</code> 文件还是不够的，恶意用户已然可以访问对象的 co_code 属性来获取字节码，进而通过反编译的手段获取到源码。因此，我们也需要禁止用户访问字节码对象：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[Objects/codeobject.c]</span><br><span class="line">--------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyMemberDef code_memberlist[] = &#123;</span><br><span class="line">    &#123;<span class="string">"co_argcount"</span>,     T_INT,          OFF(co_argcount),       READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">"co_nlocals"</span>,      T_INT,          OFF(co_nlocals),        READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">"co_stacksize"</span>,T_INT,              OFF(co_stacksize),      READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">"co_flags"</span>,        T_INT,          OFF(co_flags),          READONLY&#125;,</span><br><span class="line">    <span class="comment">// &#123;"co_code",         T_OBJECT,       OFF(co_code),           READONLY&#125;,</span></span><br><span class="line">    &#123;<span class="string">"co_consts"</span>,       T_OBJECT,       OFF(co_consts),         READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">"co_names"</span>,        T_OBJECT,       OFF(co_names),          READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">"co_varnames"</span>,     T_OBJECT,       OFF(co_varnames),       READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">"co_freevars"</span>,     T_OBJECT,       OFF(co_freevars),       READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">"co_cellvars"</span>,     T_OBJECT,       OFF(co_cellvars),       READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">"co_filename"</span>,     T_OBJECT,       OFF(co_filename),       READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">"co_name"</span>,         T_OBJECT,       OFF(co_name),           READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">"co_firstlineno"</span>, T_INT,           OFF(co_firstlineno),    READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">"co_lnotab"</span>,       T_OBJECT,       OFF(co_lnotab),         READONLY&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>&#125;      <span class="comment">/* Sentinel */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>到此，一个定制的 Python 解释器完成了。</p>
<h1 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h1><h2 id="运行脚本"><a href="#运行脚本" class="headerlink" title="运行脚本"></a>运行脚本</h2><p>通过 <code>-k</code> 选项执行已加密密钥文件，Python 解释器可以运行已加密和未加密的 Python 文件。<br><img src="/2019/01/06/如何加密你的-Python-代码-——-记-PyCon-China-2018-的一次分享/run-script.gif"></p>
<h2 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h2><p>可以通过 <code>-m &lt;module&gt;</code> 的方式加载已加密和未加密的模块，也可以通过 <code>import &lt;module&gt;</code> 的方式来加载已加密和未加密的模块。<br><img src="/2019/01/06/如何加密你的-Python-代码-——-记-PyCon-China-2018-的一次分享/load-module.gif"></p>
<h2 id="禁用字节码-1"><a href="#禁用字节码-1" class="headerlink" title="禁用字节码"></a>禁用字节码</h2><p>通过禁用字节码，我们达到以下效果：</p>
<ul>
<li>不会生成 <code>.pyc</code> 文件</li>
<li>可以访问函数的 func_code</li>
<li>无法访问代码对象的 co_code，即本示例中的 f.func_code.co_code</li>
<li>无法使用dis模块来获取字节码</li>
</ul>
<img src="/2019/01/06/如何加密你的-Python-代码-——-记-PyCon-China-2018-的一次分享/forbiden.gif">
<h2 id="异常堆栈信息"><a href="#异常堆栈信息" class="headerlink" title="异常堆栈信息"></a>异常堆栈信息</h2><p>尽管代码是加密的，但是不会影响异常时的堆栈信息。<br><img src="/2019/01/06/如何加密你的-Python-代码-——-记-PyCon-China-2018-的一次分享/exception.gif"></p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p>加密的代码也是允许调试的，但是输出的代码内容会是加密的，这正是我们所期望的。<br><img src="/2019/01/06/如何加密你的-Python-代码-——-记-PyCon-China-2018-的一次分享/debug.gif"></p>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ol>
<li>如何防止通过内存操作的方式找到对象的co_code?</li>
<li>如何进一步提升私钥被逆向工程探知的难度？</li>
<li>如何能在调试并希望看到源码的时候看到?</li>
</ol>
<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>]]></content>
      <categories>
        <category>Python</category>
        <category>解释器</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Python 解释器</tag>
        <tag>加解密</tag>
        <tag>源码保护</tag>
      </tags>
  </entry>
  <entry>
    <title>开始写博客啦~</title>
    <url>/2018/12/29/%E5%BC%80%E5%A7%8B%E5%86%99%E5%8D%9A%E5%AE%A2%E5%95%A6/</url>
    <content><![CDATA[<div align="center"><br><img src="/images/wechatPublicAccount.png" alt><br></div>]]></content>
  </entry>
</search>
